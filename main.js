/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind2) => {
  var result = kind2 > 1 ? void 0 : kind2 ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind2 ? decorator(target, key, result) : decorator(result)) || result;
  if (kind2 && result) __defProp(target, key, result);
  return result;
};

// src/features/chat/context/VoiceContext.tsx
var init_VoiceContext = __esm({
  "src/features/chat/context/VoiceContext.tsx"() {
    "use strict";
  }
});

// src/utils/audioPlayback.ts
var audioPlayback_exports = {};
__export(audioPlayback_exports, {
  AudioMemoryManager: () => AudioMemoryManager,
  getPreferredAudioFormat: () => getPreferredAudioFormat,
  isAudioFormatSupported: () => isAudioFormatSupported,
  playAudioBlob: () => playAudioBlob
});
async function playAudioBlob(audioBlob, onStateChange, onComplete, onError) {
  return new Promise((resolve, reject) => {
    if (!audioBlob || audioBlob.size === 0) {
      const error = new Error("Invalid audio blob provided");
      console.error("playAudioBlob: Invalid audio blob");
      onError?.(error);
      reject(error);
      return;
    }
    let objectUrl = null;
    let audioElement = null;
    const cleanup = () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
        objectUrl = null;
      }
      if (audioElement) {
        audioElement.removeEventListener("ended", handleEnded);
        audioElement.removeEventListener("error", handleError);
        audioElement.removeEventListener("play", handlePlay);
        audioElement.removeEventListener("pause", handlePause);
        audioElement.src = "";
        audioElement = null;
      }
    };
    const handleEnded = () => {
      console.log("Audio playback completed");
      onStateChange("idle" /* VOICE_IDLE */);
      onComplete?.();
      cleanup();
    };
    const handleError = (event) => {
      const audioError = event.target?.error;
      const error = new Error(`Audio playback error: ${audioError?.message || "Unknown error"}`);
      console.error("Audio playback error:", audioError);
      onStateChange("error" /* VOICE_ERROR */);
      onError?.(error);
      cleanup();
      reject(error);
    };
    const handlePlay = () => {
      console.log("Audio playback started");
      onStateChange("speaking" /* VOICE_AI_SPEAKING */);
    };
    const handlePause = () => {
      console.log("Audio playback paused");
    };
    try {
      objectUrl = URL.createObjectURL(audioBlob);
      audioElement = new Audio(objectUrl);
      audioElement.addEventListener("ended", handleEnded);
      audioElement.addEventListener("error", handleError);
      audioElement.addEventListener("play", handlePlay);
      audioElement.addEventListener("pause", handlePause);
      audioElement.preload = "auto";
      audioElement.autoplay = false;
      console.log("Starting audio playback:", {
        blobSize: audioBlob.size,
        blobType: audioBlob.type,
        objectUrl
      });
      const playPromise = audioElement.play();
      if (playPromise !== void 0) {
        playPromise.then(() => {
          console.log("Audio play promise resolved");
          resolve();
        }).catch((error) => {
          console.error("Audio play promise rejected:", error);
          const playError = new Error(`Failed to start audio playback: ${error.message}`);
          onStateChange("error" /* VOICE_ERROR */);
          onError?.(playError);
          cleanup();
          reject(playError);
        });
      } else {
        resolve();
      }
    } catch (error) {
      console.error("Error setting up audio playback:", error);
      const setupError = new Error(`Audio setup error: ${error instanceof Error ? error.message : "Unknown error"}`);
      onStateChange("error" /* VOICE_ERROR */);
      onError?.(setupError);
      cleanup();
      reject(setupError);
    }
  });
}
function isAudioFormatSupported(mimeType) {
  const audio = new Audio();
  const canPlay = audio.canPlayType(mimeType);
  return canPlay === "probably" || canPlay === "maybe";
}
function getPreferredAudioFormat() {
  if (isAudioFormatSupported("audio/mp3")) {
    return "mp3";
  } else if (isAudioFormatSupported("audio/wav")) {
    return "wav";
  } else if (isAudioFormatSupported("audio/ogg; codecs=opus")) {
    return "opus";
  }
  return "mp3";
}
var AudioMemoryManager;
var init_audioPlayback = __esm({
  "src/utils/audioPlayback.ts"() {
    "use strict";
    init_VoiceContext();
    AudioMemoryManager = class {
      static trackUrl(url) {
        this.activeUrls.add(url);
      }
      static releaseUrl(url) {
        if (this.activeUrls.has(url)) {
          URL.revokeObjectURL(url);
          this.activeUrls.delete(url);
        }
      }
      static cleanup() {
        this.activeUrls.forEach((url) => {
          URL.revokeObjectURL(url);
        });
        this.activeUrls.clear();
      }
      static getActiveUrlCount() {
        return this.activeUrls.size;
      }
    };
    AudioMemoryManager.activeUrls = /* @__PURE__ */ new Set();
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = Symbol.for("react.element");
    var n = Symbol.for("react.portal");
    var p = Symbol.for("react.fragment");
    var q = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t = Symbol.for("react.provider");
    var u = Symbol.for("react.context");
    var v = Symbol.for("react.forward_ref");
    var w = Symbol.for("react.suspense");
    var x = Symbol.for("react.memo");
    var y = Symbol.for("react.lazy");
    var z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a) return null;
      a = z && a[z] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var C = Object.assign;
    var D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray;
    var J = Object.prototype.hasOwnProperty;
    var K = { current: null };
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k) a = null;
      var h = false;
      if (null === a) h = true;
      else switch (k) {
        case "string":
        case "number":
          h = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case l:
            case n:
              h = true;
          }
      }
      if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
        return a2;
      })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a)) for (var g = 0; g < a.length; g++) {
        k = a[g];
        var f = d + Q(k, g);
        h += R(k, b, e, f, c);
      }
      else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (null == a) return a;
      var d = [], c = 0;
      R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status) return a._result.default;
      throw a._result;
    }
    var U = { current: null };
    var V = { transition: null };
    var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f) d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
    "use strict";
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
          else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var l;
    var p;
    var q;
    var r = [];
    var t = [];
    var u = 1;
    var v = null;
    var y = 3;
    var z = false;
    var A = false;
    var B = false;
    var D = "function" === typeof setTimeout ? setTimeout : null;
    var E = "function" === typeof clearTimeout ? clearTimeout : null;
    var F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h(t);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r)) A = true, I(J);
      else {
        var b = h(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r) && k(r);
            G(b);
          } else k(r);
          v = h(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    var N = false;
    var O = null;
    var L = -1;
    var P = 5;
    var Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    var T;
    var U;
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_scheduler_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
    "use strict";
    var aa = require_react();
    var ca = require_scheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set();
    var ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++) da.add(b[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
    var ja = Object.prototype.hasOwnProperty;
    var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var la = {};
    var ma = {};
    function oa(a) {
      if (ja.call(ma, a)) return true;
      if (ja.call(la, a)) return false;
      if (ka.test(a)) return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b, c, d) {
      if (null !== c && 0 === c.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d) return false;
          if (null !== c) return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b, c, d) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
      if (d) return false;
      if (null !== c) switch (c.type) {
        case 3:
          return !b;
        case 4:
          return false === b;
        case 5:
          return isNaN(b);
        case 6:
          return isNaN(b) || 1 > b;
      }
      return false;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var va = Symbol.for("react.element");
    var wa = Symbol.for("react.portal");
    var ya = Symbol.for("react.fragment");
    var za = Symbol.for("react.strict_mode");
    var Aa = Symbol.for("react.profiler");
    var Ba = Symbol.for("react.provider");
    var Ca = Symbol.for("react.context");
    var Da = Symbol.for("react.forward_ref");
    var Ea = Symbol.for("react.suspense");
    var Fa = Symbol.for("react.suspense_list");
    var Ga = Symbol.for("react.memo");
    var Ha = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var Ia = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.cache");
    Symbol.for("react.tracing_marker");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a) return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign;
    var La;
    function Ma(a) {
      if (void 0 === La) try {
        throw Error();
      } catch (c) {
        var b = c.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b) {
      if (!a || Na) return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b) if (b = function() {
          throw Error();
        }, Object.defineProperty(b.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l) {
            var d = l;
          }
          Reflect.construct(a, [], b);
        } else {
          try {
            b.call();
          } catch (l) {
            d = l;
          }
          a.call(b.prototype);
        }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && "string" === typeof l.stack) {
          for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
          for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
            if (1 !== g || 1 !== h) {
              do
                if (g--, h--, 0 > h || e[g] !== f[h]) {
                  var k = "\n" + e[g].replace(" at new ", " at ");
                  a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                  return k;
                }
              while (1 <= g && 0 <= h);
            }
            break;
          }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a) return null;
      if ("function" === typeof a) return a.displayName || a.name || null;
      if ("string" === typeof a) return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a) switch (a.$$typeof) {
        case Ca:
          return (a.displayName || "Context") + ".Consumer";
        case Ba:
          return (a._context.displayName || "Context") + ".Provider";
        case Da:
          var b = a.render;
          a = a.displayName;
          a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          return a;
        case Ga:
          return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
        case Ha:
          b = a._payload;
          a = a._init;
          try {
            return Qa(a(b));
          } catch (c) {
          }
      }
      return null;
    }
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2;
          f.call(this, a2);
        } });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a) return false;
      var b = a._valueTracker;
      if (!b) return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a) return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d = b.type;
      if (null != c) if ("number" === d) {
        if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function cb(a, b, c) {
      if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b) throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length) throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb;
    var nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
        for (; b.firstChild; ) a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b) if (b.hasOwnProperty(c)) {
        var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
        "float" === c && (c = "cssFloat");
        d ? a.setProperty(c, e) : a[c] = e;
      }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (-1 === a.indexOf("-")) return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib) return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c) return null;
      var d = Db(c);
      if (null === d) return null;
      c = d[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d;
          break a;
        default:
          a = false;
      }
      if (a) return null;
      if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = false;
    if (ia) try {
      Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a) {
      Lb = false;
    }
    var Mb;
    function Nb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    var Ob = false;
    var Pb = null;
    var Qb = false;
    var Rb = null;
    var Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b, c, d, e, f, g, h, k) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f, g, h, k) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || (Qb = true, Rb = l);
      }
    }
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate) for (; b.return; ) b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a) throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b) throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c) return Xb(e), a;
            if (f === d) return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return) c = e, d = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d = f;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c.alternate !== d) throw Error(p(190));
      }
      if (3 !== c.tag) throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag) return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b) return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback;
    var bc = ca.unstable_cancelCallback;
    var cc = ca.unstable_shouldYield;
    var dc = ca.unstable_requestPaint;
    var B = ca.unstable_now;
    var ec = ca.unstable_getCurrentPriorityLevel;
    var fc = ca.unstable_ImmediatePriority;
    var gc = ca.unstable_UserBlockingPriority;
    var hc = ca.unstable_NormalPriority;
    var ic = ca.unstable_LowPriority;
    var jc = ca.unstable_IdlePriority;
    var kc = null;
    var lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot) try {
        lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
      } catch (b) {
      }
    }
    var oc = Math.clz32 ? Math.clz32 : nc;
    var pc = Math.log;
    var qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64;
    var sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c) return 0;
      var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
      } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
      if (0 === d) return 0;
      if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
      0 !== (d & 4) && (d |= c & 16);
      b = a.entangledLanes;
      if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
        } else k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++) b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b);
        c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec;
    var Fc;
    var Gc;
    var Hc;
    var Ic;
    var Jc = false;
    var Kc = [];
    var Lc = null;
    var Mc = null;
    var Nc = null;
    var Oc = /* @__PURE__ */ new Map();
    var Pc = /* @__PURE__ */ new Map();
    var Qc = [];
    var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f) {
      if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d, e), true;
        case "pointerover":
          var f = e.pointerId;
          Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb(c), null !== b) {
              a.blockedOn = b;
              Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn) return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d;
          c.target.dispatchEvent(d);
          wb = null;
        } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig;
    var dd = true;
    function ed(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function gd(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (null === e) hd(a, b, d, id, c), Sc(a, d);
        else if (Uc(e, a, b, c, d)) d.stopPropagation();
        else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e; ) {
            var f = Cb(e);
            null !== f && Ec(f);
            f = Yc(a, b, c, d);
            null === f && hd(a, b, d, id, c);
            if (f === e) break;
            e = f;
          }
          null !== e && d.stopPropagation();
        } else hd(a, b, d, null, c);
      }
    }
    var id = null;
    function Yc(a, b, c, d) {
      id = null;
      a = xb(d);
      a = Wc(a);
      if (null !== a) if (b = Vb(a), null === b) a = null;
      else if (c = b.tag, 13 === c) {
        a = Wb(b);
        if (null !== a) return a;
        a = null;
      } else if (3 === c) {
        if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
        a = null;
      } else b !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md) return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++) ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 };
    var td = rd(sd);
    var ud = A({}, sd, { view: 0, detail: 0 });
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } });
    var Bd = rd(Ad);
    var Cd = A({}, Ad, { dataTransfer: 0 });
    var Dd = rd(Cd);
    var Ed = A({}, ud, { relatedTarget: 0 });
    var Fd = rd(Ed);
    var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Hd = rd(Gd);
    var Id = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } });
    var Jd = rd(Id);
    var Kd = A({}, sd, { data: 0 });
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } });
    var Rd = rd(Qd);
    var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
    var Td = rd(Sd);
    var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
    var Vd = rd(Ud);
    var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Xd = rd(Wd);
    var Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = ia && "CompositionEvent" in window;
    var be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be;
    var de = ia && (!ae || be && 8 < be && 11 >= be);
    var ee = String.fromCharCode(32);
    var fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    function ne(a, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null;
    var qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b)) return a;
    }
    function ve(a, b) {
      if ("change" === a) return b;
    }
    var we = false;
    if (ia) {
      if (ia) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re, b);
      }
    }
    function Ce(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
    }
    function Ee(a, b) {
      if ("click" === a) return te(b);
    }
    function Fe(a, b) {
      if ("input" === a || "change" === a) return te(b);
    }
    function Ge(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b)) return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length) return false;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja.call(b, e) || !He(a[e], b[e])) return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; ) a = a.firstChild;
      return a;
    }
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b) return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c) a = b.contentWindow;
        else break;
        b = Xa(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (null !== d && Ne(c)) {
          if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d.start, e);
            d = void 0 === d.end ? f : Math.min(d.end, e);
            !a.extend && f > d && (e = d, d = f, f = e);
            e = Ke(c, f);
            var g = Ke(
              c,
              d
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te = false;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
    var Xe = {};
    var Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a]) return Xe[a];
      if (!We[a]) return a;
      var b = We[a], c;
      for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
      return a;
    }
    var $e = Ze("animationend");
    var af = Ze("animationiteration");
    var bf = Ze("animationstart");
    var cf = Ze("transitionend");
    var df = /* @__PURE__ */ new Map();
    var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    for (gf = 0; gf < ef.length; gf++) {
      hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    var hf;
    var jf;
    var kf;
    var gf;
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b) for (var g = d.length - 1; 0 <= g; g--) {
            var h = d[g], k = h.instance, l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
          else for (g = 0; g < d.length; g++) {
            h = d[g];
            k = h.instance;
            l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
        }
      }
      if (Qb) throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b) {
      var c = b[of];
      void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, false), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4);
      pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    function hd(a, b, c, d, e) {
      var f = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
        if (null === d) return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h = d.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e) break;
          if (4 === g) for (g = d.return; null !== g; ) {
            var k = g.tag;
            if (3 === k || 4 === k) {
              if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
            }
            g = g.return;
          }
          for (; null !== h; ) {
            g = Wc(h);
            if (null === g) return;
            k = g.tag;
            if (5 === k || 6 === k) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
      Jb(function() {
        var d2 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (void 0 !== h2) {
            var k2 = td, n = a;
            switch (a) {
              case "keypress":
                if (0 === od(c)) break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus";
                k2 = Fd;
                break;
              case "focusout":
                n = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d2, u; null !== w; ) {
              u = w;
              var F = u.stateNode;
              5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
              if (J) break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a || "pointerover" === a;
            k2 = "mouseout" === a || "pointerout" === a;
            if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
            if (k2 || h2) {
              h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k2) {
                if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
              } else k2 = null, n = d2;
              if (k2 !== n) {
                t = Bd;
                F = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                J = null == k2 ? h2 : ue(k2);
                u = null == n ? h2 : ue(n);
                h2 = new t(F, w + "leave", k2, c, e2);
                h2.target = J;
                h2.relatedTarget = u;
                F = null;
                Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                J = F;
                if (k2 && n) b: {
                  t = k2;
                  x = n;
                  w = 0;
                  for (u = t; u; u = vf(u)) w++;
                  u = 0;
                  for (F = x; F; F = vf(F)) u++;
                  for (; 0 < w - u; ) t = vf(t), w--;
                  for (; 0 < u - w; ) x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || null !== x && t === x.alternate) break b;
                    t = vf(t);
                    x = vf(x);
                  }
                  t = null;
                }
                else t = null;
                null !== k2 && wf(g2, h2, k2, t, false);
                null !== n && null !== J && wf(g2, J, n, t, true);
              }
            }
          }
          a: {
            h2 = d2 ? ue(d2) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
            else if (me(h2)) if (we) na = Fe;
            else {
              na = De;
              var xa = Ce;
            }
            else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d2);
            "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae) b: {
            switch (a) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
          else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; null !== a; ) {
        var e = a, f = e.stateNode;
        5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
        a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (null === a) return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (null !== k && k === d) break;
        5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g;
    var yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c) throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null;
    var Df = null;
    function Ef(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
    var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    var Hf = "function" === typeof Promise ? Promise : void 0;
    var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
          if (0 === d) {
            a.removeChild(e);
            bd(b);
            return;
          }
          d--;
        } else "$" !== c && "$?" !== c && "$!" !== c || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b) return a;
            b--;
          } else "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2);
    var Of = "__reactFiber$" + Nf;
    var Pf = "__reactProps$" + Nf;
    var uf = "__reactContainer$" + Nf;
    var of = "__reactEvents$" + Nf;
    var Qf = "__reactListeners$" + Nf;
    var Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b) return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
            if (c = a[Of]) return c;
            a = Mf(a);
          }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag) return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [];
    var Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    var Vf = {};
    var H = Uf(Vf);
    var Wf = Uf(false);
    var Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c) return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c) e[f] = b[f];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext) return c;
      d = d.getChildContext();
      for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d) throw Error(p(169));
      c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c);
    }
    var eg = null;
    var fg = false;
    var gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    var kg = [];
    var lg = 0;
    var mg = null;
    var ng = 0;
    var og = [];
    var pg = 0;
    var qg = null;
    var rg = 1;
    var sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e);
      c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d & (1 << g) - 1).toString(32);
        d >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c << e | d;
        sg = f + a;
      } else rg = 1 << f | c << e | d, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null;
    var yg = null;
    var I = false;
    var zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a)) throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a)) throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg) return false;
      if (!I) return Fg(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a)) throw Hg(), Error(p(418));
        for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a) throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; ) a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a) void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    var Mg = Uf(null);
    var Ng = null;
    var Og = null;
    var Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b = Mg.current;
      E(Mg);
      a._currentValue = b;
    }
    function Sg(a, b, c) {
      for (; null !== a; ) {
        var d = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a === c) break;
        a = a.return;
      }
    }
    function Tg(a, b) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b = a._currentValue;
      if (Pg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
        if (null === Ng) throw Error(p(308));
        Og = a;
        Ng.dependencies = { lanes: 0, firstContext: a };
      } else Og = Og.next = a;
      return b;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b, c, d) {
      var e = b.interleaved;
      null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return Zg(a, d);
    }
    function Zg(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b, c) {
      var d = a.updateQueue;
      if (null === d) return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e = d.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d.pending = b;
        return Zg(a, c);
      }
      e = d.interleaved;
      null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
      d.interleaved = b;
      return Zg(a, c);
    }
    function eh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    function fh(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (null !== d && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f ? e = f = g : f = f.next = g;
            c = c.next;
          } while (null !== c);
          null === f ? e = f = b : f = f.next = b;
        } else e = f = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    function gh(a, b, c, d) {
      var e = a.updateQueue;
      $g = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        null === g ? f = l : g.next = l;
        g = k;
        var m = a.alternate;
        null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m = l = k = null;
        h = f;
        do {
          var r = h.lane, y = h.eventTime;
          if ((d & r) === r) {
            null !== m && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              r = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  n = t.payload;
                  r = "function" === typeof n ? n.call(y, q, r) : n;
                  if (null === r || void 0 === r) break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
          } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
          h = h.next;
          if (null === h) if (h = e.shared.pending, null === h) break;
          else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
        } while (1);
        null === m && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else null === f && (e.shared.lanes = 0);
        hh |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    function ih(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a) for (b = 0; b < a.length; b++) {
        var d = a[b], e = d.callback;
        if (null !== e) {
          d.callback = null;
          d = c;
          if ("function" !== typeof e) throw Error(p(191, e));
          e.call(d);
        }
      }
    }
    var jh = new aa.Component().refs;
    function kh(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = L(), e = lh(a), f = ch(d, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = dh(a, f, e);
      null !== b && (mh(b, a, e, d), eh(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = L(), e = lh(a), f = ch(d, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = dh(a, f, e);
      null !== b && (mh(b, a, e, d), eh(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = L(), d = lh(a), e = ch(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = dh(a, e, d);
      null !== b && (mh(b, a, d, c), eh(b, a, d));
    } };
    function oh(a, b, c, d, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
    }
    function ph(a, b, c) {
      var d = false, e = Vf;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = nh;
      a.stateNode = b;
      b._reactInternals = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function qh(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && nh.enqueueReplaceState(b, b.state, null);
    }
    function rh(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = jh;
      ah(a);
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag) throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d) throw Error(p(147, a));
          var e = d, f = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
          b = function(a2) {
            var b2 = e.refs;
            b2 === jh && (b2 = e.refs = {});
            null === a2 ? delete b2[f] : b2[f] = a2;
          };
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a) throw Error(p(284));
        if (!c._owner) throw Error(p(290, a));
      }
      return a;
    }
    function th(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function uh(a) {
      var b = a._init;
      return b(a._payload);
    }
    function vh(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a) return null;
        for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        a2 = wh(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f(b2, c2, d2) {
        b2.index = d2;
        if (!a) return b2.flags |= 1048576, c2;
        d2 = b2.alternate;
        if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
        b2.flags |= 2;
        return c2;
      }
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h(a2, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag) return b2 = xh(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k(a2, b2, c2, d2) {
        var f2 = c2.type;
        if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
        if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && uh(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = sh(a2, b2, c2), d2.return = a2, d2;
        d2 = yh(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = sh(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l(a2, b2, c2, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = zh(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function m(a2, b2, c2, d2, f2) {
        if (null === b2 || 7 !== b2.tag) return b2 = Ah(c2, a2.mode, d2, f2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function q(a2, b2, c2) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = zh(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d2 = b2._init;
              return q(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2)) return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
          th(a2, b2);
        }
        return null;
      }
      function r(a2, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            case Ha:
              return e2 = c2._init, r(
                a2,
                b2,
                e2(c2._payload),
                d2
              );
          }
          if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
          th(a2, c2);
        }
        return null;
      }
      function y(a2, b2, c2, d2, e2) {
        if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
            case wa:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            case Ha:
              var f2 = d2._init;
              return y(a2, b2, c2, f2(d2._payload), e2);
          }
          if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
          th(b2, d2);
        }
        return null;
      }
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r(e2, u, h2[w], k2);
          if (null === n2) {
            null === u && (u = x);
            break;
          }
          a && u && null === n2.alternate && b(e2, u);
          g2 = f(n2, g2, w);
          null === m2 ? l2 = n2 : m2.sibling = n2;
          m2 = n2;
          u = x;
        }
        if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
        if (null === u) {
          for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
          I && tg(e2, w);
          return l2;
        }
        for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if ("function" !== typeof l2) throw Error(p(150));
        h2 = l2.call(h2);
        if (null == h2) throw Error(p(151));
        for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
          m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
          var t2 = r(e2, m2, n2.value, k2);
          if (null === t2) {
            null === m2 && (m2 = x);
            break;
          }
          a && m2 && null === t2.alternate && b(e2, m2);
          g2 = f(t2, g2, w);
          null === u ? l2 = t2 : u.sibling = t2;
          u = t2;
          m2 = x;
        }
        if (n2.done) return c(
          e2,
          m2
        ), I && tg(e2, w), l2;
        if (null === m2) {
          for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          I && tg(e2, w);
          return l2;
        }
        for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        a && m2.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      function J(a2, d2, f2, h2) {
        "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
        if ("object" === typeof f2 && null !== f2) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                  if (l2.key === k2) {
                    k2 = f2.type;
                    if (k2 === ya) {
                      if (7 === l2.tag) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props.children);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                    } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && uh(k2) === l2.type) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props);
                      d2.ref = sh(a2, l2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d2 = Ah(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = yh(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = sh(a2, d2, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; null !== d2; ) {
                  if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                    c(a2, d2.sibling);
                    d2 = e(d2, f2.children || []);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  } else {
                    c(a2, d2);
                    break;
                  }
                  else b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = zh(f2, a2.mode, h2);
                d2.return = a2;
                a2 = d2;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
          }
          if (eb(f2)) return n(a2, d2, f2, h2);
          if (Ka(f2)) return t(a2, d2, f2, h2);
          th(a2, f2);
        }
        return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = xh(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
      }
      return J;
    }
    var Bh = vh(true);
    var Ch = vh(false);
    var Dh = {};
    var Eh = Uf(Dh);
    var Fh = Uf(Dh);
    var Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh) throw Error(p(174));
      return a;
    }
    function Ih(a, b) {
      G(Gh, b);
      G(Fh, a);
      G(Eh, Dh);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(Eh);
      G(Eh, b);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b = Hh(Eh.current);
      var c = lb(b, a.type);
      b !== c && (G(Fh, a), G(Eh, c));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher;
    var Qh = ua.ReactCurrentBatchConfig;
    var Rh = 0;
    var N = null;
    var O = null;
    var P = null;
    var Sh = false;
    var Th = false;
    var Uh = 0;
    var Vh = 0;
    function Q() {
      throw Error(p(321));
    }
    function Wh(a, b) {
      if (null === b) return false;
      for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
      return true;
    }
    function Xh(a, b, c, d, e, f) {
      Rh = f;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c(d, e);
      if (Th) {
        f = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f) throw Error(p(301));
          f += 1;
          P = O = null;
          b.updateQueue = null;
          Ph.current = $h;
          a = c(d, e);
        } while (Th);
      }
      Ph.current = ai;
      b = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b) throw Error(p(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else a = O.next;
      var b = null === P ? N.memoizedState : P.next;
      if (null !== b) P = b, O = a;
      else {
        if (null === a) throw Error(p(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function fi(a) {
      var b = di(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = O, e = d.baseQueue, f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d = d.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Rh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            null === k ? (h = k = q, g = d) : k = k.next = q;
            N.lanes |= m;
            hh |= m;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? g = d : k.next = h;
        He(d, b.memoizedState) || (Ug = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f = e.lane, N.lanes |= f, hh |= f, e = e.next;
        while (e !== a);
      } else null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function gi(a) {
      var b = di(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (Ug = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d];
    }
    function hi() {
    }
    function ii(a, b) {
      var c = N, d = di(), e = b(), f = !He(d.memoizedState, e);
      f && (d.memoizedState = e, Ug = true);
      d = d.queue;
      ji(ki.bind(null, c, d, a), [a]);
      if (d.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
        c.flags |= 2048;
        li(9, mi.bind(null, c, d, e, b), void 0, null);
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(c, b, e);
      }
      return e;
    }
    function ni(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    function mi(a, b, c, d) {
      b.value = c;
      b.getSnapshot = d;
      oi(b) && pi(a);
    }
    function ki(a, b, c) {
      return c(function() {
        oi(b) && pi(a);
      });
    }
    function oi(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d) {
        return true;
      }
    }
    function pi(a) {
      var b = Zg(a, 1);
      null !== b && mh(b, a, 1, -1);
    }
    function qi(a) {
      var b = ci();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b.memoizedState, a];
    }
    function li(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b, c, d) {
      var e = ci();
      N.flags |= a;
      e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function ui(a, b, c, d) {
      var e = di();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== O) {
        var g = O.memoizedState;
        f = g.destroy;
        if (null !== d && Wh(d, g.deps)) {
          e.memoizedState = li(b, c, f, d);
          return;
        }
      }
      N.flags |= a;
      e.memoizedState = li(1 | b, c, f, d);
    }
    function vi(a, b) {
      return ti(8390656, 8, a, b);
    }
    function ji(a, b) {
      return ui(2048, 8, a, b);
    }
    function wi(a, b) {
      return ui(4, 2, a, b);
    }
    function xi(a, b) {
      return ui(4, 4, a, b);
    }
    function yi(a, b) {
      if ("function" === typeof b) return a = a(), b(a), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
        b.current = null;
      };
    }
    function zi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b, a), c);
    }
    function Ai() {
    }
    function Bi(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Wh(b, d[1])) return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function Ci(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Wh(b, d[1])) return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function Di(a, b, c) {
      if (0 === (Rh & 21)) return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
      He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
      return b;
    }
    function Ei(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Qh.transition = d;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b, c) {
      var d = lh(a);
      c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a)) Ii(b, c);
      else if (c = Yg(a, b, c, d), null !== c) {
        var e = L();
        mh(c, a, d, e);
        Ji(c, b, d);
      }
    }
    function ri(a, b, c) {
      var d = lh(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a)) Ii(b, e);
      else {
        var f = a.alternate;
        if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
          var g = b.lastRenderedState, h = f(g, c);
          e.hasEagerState = true;
          e.eagerState = h;
          if (He(h, g)) {
            var k = b.interleaved;
            null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
            b.interleaved = e;
            return;
          }
        } catch (l) {
        } finally {
        }
        c = Yg(a, b, e, d);
        null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
      }
    }
    function Hi(a) {
      var b = a.alternate;
      return a === N || null !== b && b === N;
    }
    function Ii(a, b) {
      Th = Sh = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    function Ji(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false };
    var Yh = { readContext: Vg, useCallback: function(a, b) {
      ci().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ti(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ti(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = ci();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, useReducer: function(a, b, c) {
      var d = ci();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d.memoizedState, a];
    }, useRef: function(a) {
      var b = ci();
      a = { current: a };
      return b.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = N, e = ci();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(d, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      e.queue = f;
      vi(ki.bind(
        null,
        d,
        f,
        a
      ), [a]);
      d.flags |= 2048;
      li(9, mi.bind(null, d, f, c, b), void 0, null);
      return c;
    }, useId: function() {
      var a = ci(), b = R.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Uh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: false };
    var Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b = di();
        return Di(b, O.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b = di().memoizedState;
        return [a, b];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    };
    var $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b = di();
      return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b = di().memoizedState;
      return [a, b];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Li(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    function Mi(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Pi || (Pi = true, Qi = d);
        Mi(a, b);
      };
      return c;
    }
    function Ri(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          return d(e);
        };
        c.callback = function() {
          Mi(a, b);
        };
      }
      var f = a.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
        Mi(a, b);
        "function" !== typeof d && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      if (null === d) {
        d = a.pingCache = new Ni();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
    }
    function Vi(a) {
      do {
        var b;
        if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b) return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b, c, d, e) {
      if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    var Xi = ua.ReactCurrentOwner;
    var Ug = false;
    function Yi(a, b, c, d) {
      b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
    }
    function Zi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      Tg(b, e);
      d = Xh(a, b, c, d, f, e);
      c = bi();
      if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && c && vg(b);
      b.flags |= 1;
      Yi(a, b, d, e);
      return b.child;
    }
    function aj(a, b, c, d, e) {
      if (null === a) {
        var f = c.type;
        if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
        a = yh(c.type, null, d, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
      }
      b.flags |= 1;
      a = wh(f, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function cj(a, b, c, d, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie(f, d) && a.ref === b.ref) if (Ug = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = true);
        else return b.lanes = a.lanes, $i(a, b, e);
      }
      return dj(a, b, c, d, e);
    }
    function ej(a, b, c) {
      var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
      if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
      else {
        if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d = null !== f ? f.baseLanes : c;
        G(fj, gj);
        gj |= d;
      }
      else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
      Yi(a, b, e, c);
      return b.child;
    }
    function hj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
    }
    function dj(a, b, c, d, e) {
      var f = Zf(c) ? Xf : H.current;
      f = Yf(b, f);
      Tg(b, e);
      c = Xh(a, b, c, d, f, e);
      d = bi();
      if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && d && vg(b);
      b.flags |= 1;
      Yi(a, b, c, e);
      return b.child;
    }
    function ij(a, b, c, d, e) {
      if (Zf(c)) {
        var f = true;
        cg(b);
      } else f = false;
      Tg(b, e);
      if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = true;
      else if (null === a) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
        q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
        $g = false;
        var r = b.memoizedState;
        g.state = r;
        gh(b, d, g, e);
        k = b.memoizedState;
        h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g = b.stateNode;
        bh(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Lg(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
        $g = false;
        r = b.memoizedState;
        g.state = r;
        gh(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
      }
      return kj(a, b, c, d, f, e);
    }
    function kj(a, b, c, d, e, f) {
      hj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g) return e && dg(b, c, false), $i(a, b, f);
      d = b.stateNode;
      Xi.current = b;
      var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
      b.memoizedState = d.state;
      e && dg(b, c, true);
      return b.child;
    }
    function lj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
      Ih(a, b.containerInfo);
    }
    function mj(a, b, c, d, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Yi(a, b, c, d);
      return b.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b, c) {
      var d = b.pendingProps, e = M.current, f = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h) f = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState) e |= 1;
      G(M, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d.children;
        a = d.fallback;
        return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
        f.return = b;
        d.return = b;
        d.sibling = f;
        b.child = d;
        d = f;
        f = b.child;
        g = a.child.memoizedState;
        g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = nj;
        return d;
      }
      f = a.child;
      a = f.sibling;
      d = wh(f, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c);
      d.return = b;
      d.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function rj(a, b) {
      b = qj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    function tj(a, b, c, d) {
      null !== d && Jg(d);
      Bh(b, a.child, null, c);
      a = rj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    function sj(a, b, c, d, e, f, g) {
      if (c) {
        if (b.flags & 256) return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
        if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
        f = d.fallback;
        e = b.mode;
        d = qj({ mode: "visible", children: d.children }, e, 0, null);
        f = Ah(f, e, g, null);
        f.flags |= 2;
        d.return = b;
        f.return = b;
        d.sibling = f;
        b.child = d;
        0 !== (b.mode & 1) && Bh(b, a.child, null, g);
        b.child.memoizedState = oj(g);
        b.memoizedState = nj;
        return f;
      }
      if (0 === (b.mode & 1)) return tj(a, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d) var h = d.dgst;
        d = h;
        f = Error(p(419));
        d = Li(f, d, void 0);
        return tj(a, b, g, d);
      }
      h = 0 !== (g & a.childLanes);
      if (Ug || h) {
        d = R;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
        }
        uj();
        d = Li(Error(p(421)));
        return tj(a, b, g, d);
      }
      if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
      a = f.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
      b = rj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function wj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      null !== d && (d.lanes |= b);
      Sg(a.return, b, c);
    }
    function xj(a, b, c, d, e) {
      var f = a.memoizedState;
      null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
    }
    function yj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      Yi(a, b, d.children, c);
      d = M.current;
      if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
          if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);
          else if (19 === a.tag) wj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b) break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b) break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
        d &= 1;
      }
      G(M, d);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c = b.child;
          for (e = null; null !== c; ) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
          c = e;
          null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
          xj(b, false, e, c, f);
          break;
        case "backwards":
          c = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a = e.alternate;
            if (null !== a && null === Mh(a)) {
              b.child = e;
              break;
            }
            a = e.sibling;
            e.sibling = c;
            c = e;
            e = a;
          }
          xj(b, true, c, null, f);
          break;
        case "together":
          xj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    function jj(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function $i(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      hh |= b.lanes;
      if (0 === (c & b.childLanes)) return null;
      if (null !== a && b.child !== a.child) throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = wh(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function zj(a, b, c) {
      switch (b.tag) {
        case 3:
          lj(b);
          Ig();
          break;
        case 5:
          Kh(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          Ih(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Mg, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
            G(M, M.current & 1);
            a = $i(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d) return yj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(M, M.current);
          if (d) break;
          else return null;
        case 22:
        case 23:
          return b.lanes = 0, ej(a, b, c);
      }
      return $i(a, b, c);
    }
    var Aj;
    var Bj;
    var Cj;
    var Dj;
    Aj = function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b) break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b) return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        Hh(Eh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d = Ya(a, d);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d = gb(a, d);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
          var h = e[l];
          for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          h = null != e ? e[l] : void 0;
          if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else c || (f || (f = []), f.push(
            l,
            c
          )), c = k;
          else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l) b.flags |= 4;
      }
    };
    Dj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Ej(a, b) {
      if (!I) switch (a.tailMode) {
        case "hidden":
          b = a.tail;
          for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a.tail;
          for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
          null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
      }
    }
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
      if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d;
      a.childLanes = c;
      return b;
    }
    function Fj(a, b, c) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b);
          S(b);
          return null;
        case 5:
          Lh(b);
          var e = Hh(Gh.current);
          c = b.type;
          if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), D("invalid", d);
              }
              ub(c, f);
              e = null;
              for (var g in f) if (f.hasOwnProperty(g)) {
                var h = f[g];
                "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                  d.textContent,
                  h,
                  a
                ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
              }
              switch (c) {
                case "input":
                  Va(d);
                  db(d, f, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d.onclick = Bf);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
              a[Of] = b;
              a[Pf] = d;
              Aj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e);
                h = e;
                for (f in h) if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
            c = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.memoizedProps;
              d[Of] = b;
              if (f = d.nodeValue !== c) {
                if (a = xg, null !== a) switch (a.tag) {
                  case 3:
                    Af(d.nodeValue, c, 0 !== (a.mode & 1));
                    break;
                  case 5:
                    true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                }
              }
              f && (b.flags |= 4);
            } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(M);
          d = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
            else if (f = Gg(b), null !== d && null !== d.dehydrated) {
              if (null === a) {
                if (!f) throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f) throw Error(p(317));
                f[Of] = b;
              } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f = false;
            } else null !== zg && (Gj(zg), zg = null), f = true;
            if (!f) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return b.lanes = c, b;
          d = null !== d;
          d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return Rg(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(M);
          f = b.memoizedState;
          if (null === f) return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g) if (d) Ej(f, false);
          else {
            if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
              g = Mh(a);
              if (null !== g) {
                b.flags |= 128;
                Ej(f, false);
                d = g.updateQueue;
                null !== d && (b.updateQueue = d, b.flags |= 4);
                b.subtreeFlags = 0;
                d = c;
                for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(M, M.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
            null !== f.tail && B() > Hj && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
          }
          else {
            if (!d) if (a = Mh(g), null !== a) {
              if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
            } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
          }
          if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Jj(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Lh(b), null;
        case 13:
          E(M);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false;
    var U = false;
    var Lj = "function" === typeof WeakSet ? WeakSet : Set;
    var V = null;
    function Mj(a, b) {
      var c = a.ref;
      if (null !== c) if ("function" === typeof c) try {
        c(null);
      } catch (d) {
        W(a, b, d);
      }
      else c.current = null;
    }
    function Nj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Oj = false;
    function Pj(a, b) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
        else a: {
          c = (c = a.ownerDocument) && c.defaultView || window;
          var d = c.getSelection && c.getSelection();
          if (d && 0 !== d.rangeCount) {
            c = d.anchorNode;
            var e = d.anchorOffset, f = d.focusNode;
            d = d.focusOffset;
            try {
              c.nodeType, f.nodeType;
            } catch (F) {
              c = null;
              break a;
            }
            var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
            b: for (; ; ) {
              for (var y; ; ) {
                q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                3 === q.nodeType && (g += q.nodeValue.length);
                if (null === (y = q.firstChild)) break;
                r = q;
                q = y;
              }
              for (; ; ) {
                if (q === a) break b;
                r === c && ++l === e && (h = g);
                r === f && ++m === d && (k = g);
                if (null !== (y = q.nextSibling)) break;
                q = r;
                r = q.parentNode;
              }
              q = y;
            }
            c = -1 === h || -1 === k ? null : { start: h, end: k };
          } else c = null;
        }
        c = c || { start: 0, end: 0 };
      } else c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
      else for (; null !== V; ) {
        b = V;
        try {
          var n = b.alternate;
          if (0 !== (b.flags & 1024)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (null !== n) {
                var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
                x.__reactInternalSnapshotBeforeUpdate = w;
              }
              break;
            case 3:
              var u = b.stateNode.containerInfo;
              1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(p(163));
          }
        } catch (F) {
          W(b, b.return, F);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
      n = Oj;
      Oj = false;
      return n;
    }
    function Qj(a, b, c) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Nj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Rj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Sj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    function Tj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Tj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a: for (; ; ) {
        for (; null === a.sibling; ) {
          if (null === a.return || Uj(a.return)) return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2) continue a;
          if (null === a.child || 4 === a.tag) continue a;
          else a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2)) return a.stateNode;
      }
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
    }
    function Xj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a; ) Xj(a, b, c), a = a.sibling;
    }
    var X2 = null;
    var Yj = false;
    function Zj(a, b, c) {
      for (c = c.child; null !== c; ) ak(a, b, c), c = c.sibling;
    }
    function ak(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
        lc.onCommitFiberUnmount(kc, c);
      } catch (h) {
      }
      switch (c.tag) {
        case 5:
          U || Mj(c, b);
        case 6:
          var d = X2, e = Yj;
          X2 = null;
          Zj(a, b, c);
          X2 = d;
          Yj = e;
          null !== X2 && (Yj ? (a = X2, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X2.removeChild(c.stateNode));
          break;
        case 18:
          null !== X2 && (Yj ? (a = X2, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X2, c.stateNode));
          break;
        case 4:
          d = X2;
          e = Yj;
          X2 = c.stateNode.containerInfo;
          Yj = true;
          Zj(a, b, c);
          X2 = d;
          Yj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e = d = d.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag;
              void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
              e = e.next;
            } while (e !== d);
          }
          Zj(a, b, c);
          break;
        case 1:
          if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
            d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
          } catch (h) {
            W(c, b, h);
          }
          Zj(a, b, c);
          break;
        case 21:
          Zj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
          break;
        default:
          Zj(a, b, c);
      }
    }
    function bk(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Lj());
        b.forEach(function(b2) {
          var d = ck.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function dk(a, b) {
      var c = b.deletions;
      if (null !== c) for (var d = 0; d < c.length; d++) {
        var e = c[d];
        try {
          var f = a, g = b, h = g;
          a: for (; null !== h; ) {
            switch (h.tag) {
              case 5:
                X2 = h.stateNode;
                Yj = false;
                break a;
              case 3:
                X2 = h.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X2 = h.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h = h.return;
          }
          if (null === X2) throw Error(p(160));
          ak(f, g, e);
          X2 = null;
          Yj = false;
          var k = e.alternate;
          null !== k && (k.return = null);
          e.return = null;
        } catch (l) {
          W(e, b, l);
        }
      }
      if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) ek(b, a), b = b.sibling;
    }
    function ek(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b, a);
          fk(a);
          if (d & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Qj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          dk(b, a);
          fk(a);
          d & 512 && null !== c && Mj(c, c.return);
          break;
        case 5:
          dk(b, a);
          fk(a);
          d & 512 && null !== c && Mj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && (e = a.stateNode, null != e)) {
            var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k) try {
              "input" === h && "radio" === f.type && null != f.name && ab(e, f);
              vb(h, g);
              var l = vb(h, f);
              for (g = 0; g < k.length; g += 2) {
                var m = k[g], q = k[g + 1];
                "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
              }
              switch (h) {
                case "input":
                  bb(e, f);
                  break;
                case "textarea":
                  ib(e, f);
                  break;
                case "select":
                  var r = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f.multiple;
                  var y = f.value;
                  null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                    e,
                    !!f.multiple,
                    f.defaultValue,
                    true
                  ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
              }
              e[Pf] = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 6:
          dk(b, a);
          fk(a);
          if (d & 4) {
            if (null === a.stateNode) throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          dk(b, a);
          fk(a);
          if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
            bd(b.containerInfo);
          } catch (t) {
            W(a, a.return, t);
          }
          break;
        case 4:
          dk(b, a);
          fk(a);
          break;
        case 13:
          dk(b, a);
          fk(a);
          e = a.child;
          e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
          d & 4 && bk(a);
          break;
        case 22:
          m = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
          fk(a);
          if (d & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
              for (q = V = m; null !== V; ) {
                r = V;
                y = r.child;
                switch (r.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Qj(4, r, r.return);
                    break;
                  case 1:
                    Mj(r, r.return);
                    var n = r.stateNode;
                    if ("function" === typeof n.componentWillUnmount) {
                      d = r;
                      c = r.return;
                      try {
                        b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                      } catch (t) {
                        W(d, c, t);
                      }
                    }
                    break;
                  case 5:
                    Mj(r, r.return);
                    break;
                  case 22:
                    if (null !== r.memoizedState) {
                      hk(q);
                      continue;
                    }
                }
                null !== y ? (y.return = r, V = y) : hk(q);
              }
              m = m.sibling;
            }
            a: for (m = null, q = a; ; ) {
              if (5 === q.tag) {
                if (null === m) {
                  m = q;
                  try {
                    e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m) try {
                  q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                } catch (t) {
                  W(a, a.return, t);
                }
              } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                q.child.return = q;
                q = q.child;
                continue;
              }
              if (q === a) break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a) break a;
                m === q && (m = null);
                q = q.return;
              }
              m === q && (m = null);
              q.sibling.return = q.return;
              q = q.sibling;
            }
          }
          break;
        case 19:
          dk(b, a);
          fk(a);
          d & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Uj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f = Vj(a);
              Xj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Vj(a);
              Wj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function ik(a, b, c) {
      V = a;
      jk(a, b, c);
    }
    function jk(a, b, c) {
      for (var d = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Kj;
          if (!g) {
            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
            h = Kj;
            var l = U;
            Kj = g;
            if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
            for (; null !== f; ) V = f, jk(f, b, c), f = f.sibling;
            V = e;
            Kj = h;
            U = l;
          }
          lk(a, b, c);
        } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Rj(5, b);
                break;
              case 1:
                var d = b.stateNode;
                if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                  d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
                var f = b.updateQueue;
                null !== f && ih(b, f, d);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  c = null;
                  if (null !== b.child) switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                  ih(b, g, c);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c && b.flags & 4) {
                  c = h;
                  var k = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k.autoFocus && c.focus();
                      break;
                    case "img":
                      k.src && (c.src = k.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l = b.alternate;
                  if (null !== l) {
                    var m = l.memoizedState;
                    if (null !== m) {
                      var q = m.dehydrated;
                      null !== q && bd(q);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p(163));
            }
            U || b.flags & 512 && Sj(b);
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Rj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    var mk = Math.ceil;
    var nk = ua.ReactCurrentDispatcher;
    var ok = ua.ReactCurrentOwner;
    var pk = ua.ReactCurrentBatchConfig;
    var K = 0;
    var R = null;
    var Y = null;
    var Z = 0;
    var gj = 0;
    var fj = Uf(0);
    var T = 0;
    var qk = null;
    var hh = 0;
    var rk = 0;
    var sk = 0;
    var tk = null;
    var uk = null;
    var gk = 0;
    var Hj = Infinity;
    var vk = null;
    var Pi = false;
    var Qi = null;
    var Si = null;
    var wk = false;
    var xk = null;
    var yk = 0;
    var zk = 0;
    var Ak = null;
    var Bk = -1;
    var Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    function lh(a) {
      if (0 === (a.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a) return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b, c, d) {
      if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
      Ac(a, c, d);
      if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    function Ek(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === R ? Z : 0);
      if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        null != c && bc(c);
        if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
          0 === (K & 6) && jg();
        }), c = null;
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Gk(c, Hk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Hk(a, b) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c = a.callbackNode;
      if (Ik() && a.callbackNode !== c) return null;
      var d = uc(a, a === R ? Z : 0);
      if (0 === d) return null;
      if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f = Kk();
        if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
        do
          try {
            Mk();
            break;
          } catch (h) {
            Nk(a, h);
          }
        while (1);
        Qg();
        nk.current = f;
        K = e;
        null !== Y ? b = 0 : (R = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
        if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
        if (6 === b) Dk(a, d);
        else {
          e = a.current.alternate;
          if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d);
              if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
                if (0 !== uc(a, 0)) break;
                e = a.suspendedLanes;
                if ((e & d) !== d) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d);
              if ((d & 4194240) === d) break;
              b = a.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f;
              }
              d = e;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
              if (10 < d) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c ? Hk.bind(null, a) : null;
    }
    function Ok(a, b) {
      var c = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
      a = Jk(a, b);
      2 !== a && (b = uk, uk = c, null !== b && Gj(b));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
            var e = c[d], f = e.getSnapshot;
            e = e.value;
            try {
              if (!He(f(), e)) return false;
            } catch (g) {
              return false;
            }
          }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
        else {
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Dk(a, b) {
      b &= ~sk;
      b &= ~rk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6)) throw Error(p(327));
      Ik();
      var b = uc(a, 0);
      if (0 === (b & 1)) return Ek(a, B()), null;
      var c = Jk(a, b);
      if (0 !== a.tag && 2 === c) {
        var d = xc(a);
        0 !== d && (b = d, c = Ok(a, d));
      }
      if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
      if (6 === c) throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b = K;
      K |= 1;
      var c = pk.transition, d = C;
      try {
        if (pk.transition = null, C = 1, a) return a();
      } finally {
        C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf(c));
      if (null !== Y) for (c = Y.return; null !== c; ) {
        var d = c;
        wg(d);
        switch (d.tag) {
          case 1:
            d = d.type.childContextTypes;
            null !== d && void 0 !== d && $f();
            break;
          case 3:
            Jh();
            E(Wf);
            E(H);
            Oh();
            break;
          case 5:
            Lh(d);
            break;
          case 4:
            Jh();
            break;
          case 13:
            E(M);
            break;
          case 19:
            E(M);
            break;
          case 10:
            Rg(d.type._context);
            break;
          case 22:
          case 23:
            Ij();
        }
        c = c.return;
      }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b = 0; b < Wg.length; b++) if (c = Wg[b], d = c.interleaved, null !== d) {
          c.interleaved = null;
          var e = d.next, f = c.pending;
          if (null !== f) {
            var g = f.next;
            f.next = e;
            d.next = g;
          }
          c.pending = d;
        }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b) {
      do {
        var c = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d = N.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c || null === c.return) {
            T = 1;
            qk = b;
            Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l = k, m = h, q = m.tag;
              if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r = m.alternate;
                r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Vi(g);
              if (null !== y) {
                y.flags &= -257;
                Wi(y, g, h, f, b);
                y.mode & 1 && Ti(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Ti(f, l, b);
                  uj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Vi(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Wi(J, g, h, f, b);
                Jg(Ki(k, h));
                break a;
              }
            }
            f = k = Ki(k, h);
            4 !== T && (T = 2);
            null === tk ? tk = [f] : tk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Oi(f, k, b);
                  fh(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F = Ri(f, h, b);
                    fh(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Tk(c);
        } catch (na) {
          b = na;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b) {
      var c = K;
      K |= 2;
      var d = Kk();
      if (R !== a || Z !== b) vk = null, Lk(a, b);
      do
        try {
          Uk();
          break;
        } catch (e) {
          Nk(a, e);
        }
      while (1);
      Qg();
      K = c;
      nk.current = d;
      if (null !== Y) throw Error(p(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; ) Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); ) Vk(Y);
    }
    function Vk(a) {
      var b = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b ? Tk(a) : Y = b;
      ok.current = null;
    }
    function Tk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Fj(c, b, gj), null !== c) {
            Y = c;
            return;
          }
        } else {
          c = Jj(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Qk(a, b, c) {
      var d = C, e = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b, c, d);
      } finally {
        pk.transition = e, C = d;
      }
      return null;
    }
    function Xk(a, b, c, d) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6)) throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c) return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current) throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc(a, f);
      a === R && (Y = R = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = pk.transition;
        pk.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        ok.current = null;
        Pj(a, c);
        ek(c, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        ik(c, a, e);
        dc();
        K = h;
        C = g;
        pk.transition = f;
      } else a.current = c;
      wk && (wk = false, xk = a, yk = e);
      f = a.pendingLanes;
      0 === f && (Si = null);
      mc(c.stateNode, d);
      Ek(a, B());
      if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Pi) throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f = a.pendingLanes;
      0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b = pk.transition, c = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk) var d = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f = V, g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m, f);
                      }
                      var q = m.child;
                      if (null !== q) q.return = m, V = q;
                      else for (; null !== V; ) {
                        m = V;
                        var r = m.sibling, y = m.return;
                        Tj(m);
                        if (m === l) {
                          V = null;
                          break;
                        }
                        if (null !== r) {
                          r.return = y;
                          V = r;
                          break;
                        }
                        V = y;
                      }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
              else b: for (; null !== V; ) {
                f = V;
                if (0 !== (f.flags & 2048)) switch (f.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, f, f.return);
                }
                var x = f.sibling;
                if (null !== x) {
                  x.return = f.return;
                  V = x;
                  break b;
                }
                V = f.return;
              }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
              else b: for (g = w; null !== V; ) {
                h = V;
                if (0 !== (h.flags & 2048)) try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Rj(9, h);
                  }
                } catch (na) {
                  W(h, h.return, na);
                }
                if (h === g) {
                  V = null;
                  break b;
                }
                var F = h.sibling;
                if (null !== F) {
                  F.return = h.return;
                  V = F;
                  break b;
                }
                V = h.return;
              }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
              lc.onPostCommitFiberRoot(kc, a);
            } catch (na) {
            }
            d = true;
          }
          return d;
        } finally {
          C = c, pk.transition = b;
        }
      }
      return false;
    }
    function Yk(a, b, c) {
      b = Ki(c, b);
      b = Oi(a, b, 1);
      a = dh(a, b, 1);
      b = L();
      null !== a && (Ac(a, 1, b), Ek(a, b));
    }
    function W(a, b, c) {
      if (3 === a.tag) Yk(a, a, c);
      else for (; null !== b; ) {
        if (3 === b.tag) {
          Yk(b, a, c);
          break;
        } else if (1 === b.tag) {
          var d = b.stateNode;
          if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
            a = Ki(c, a);
            a = Ri(b, a, 1);
            b = dh(b, a, 1);
            a = L();
            null !== b && (Ac(b, 1, a), Ek(b, a));
            break;
          }
        }
        b = b.return;
      }
    }
    function Ui(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      b = L();
      a.pingedLanes |= a.suspendedLanes & c;
      R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
      Ek(a, b);
    }
    function Zk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c = L();
      a = Zg(a, b);
      null !== a && (Ac(a, b, c), Ek(a, c));
    }
    function vj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Zk(a, c);
    }
    function ck(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Zk(a, c);
    }
    var Wk;
    Wk = function(a, b, c) {
      if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = true;
      else {
        if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = false, zj(a, b, c);
        Ug = 0 !== (a.flags & 131072) ? true : false;
      }
      else Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          jj(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          Tg(b, c);
          e = Xh(null, b, d, a, e, c);
          var f = bi();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            jj(a, b);
            a = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = $k(d);
            a = Lg(d, a);
            switch (e) {
              case 0:
                b = dj(null, b, d, a, c);
                break a;
              case 1:
                b = ij(null, b, d, a, c);
                break a;
              case 11:
                b = Zi(null, b, d, a, c);
                break a;
              case 14:
                b = aj(null, b, d, Lg(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
        case 3:
          a: {
            lj(b);
            if (null === a) throw Error(p(387));
            d = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            bh(a, b);
            gh(b, d, null, c);
            var g = b.memoizedState;
            d = g.element;
            if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
              e = Ki(Error(p(423)), b);
              b = mj(a, b, d, c, e);
              break a;
            } else if (d !== e) {
              e = Ki(Error(p(424)), b);
              b = mj(a, b, d, c, e);
              break a;
            } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig();
              if (d === e) {
                b = $i(a, b, c);
                break a;
              }
              Yi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return pj(a, b, c);
        case 4:
          return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
        case 7:
          return Yi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Mg, d._currentValue);
            d._currentValue = g;
            if (null !== f) if (He(f.value, g)) {
              if (f.children === e.children && !Wf.current) {
                b = $i(a, b, c);
                break a;
              }
            } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
              var h = f.dependencies;
              if (null !== h) {
                g = f.child;
                for (var k = h.firstContext; null !== k; ) {
                  if (k.context === d) {
                    if (1 === f.tag) {
                      k = ch(-1, c & -c);
                      k.tag = 2;
                      var l = f.updateQueue;
                      if (null !== l) {
                        l = l.shared;
                        var m = l.pending;
                        null === m ? k.next = k : (k.next = m.next, m.next = k);
                        l.pending = k;
                      }
                    }
                    f.lanes |= c;
                    k = f.alternate;
                    null !== k && (k.lanes |= c);
                    Sg(
                      f.return,
                      c,
                      b
                    );
                    h.lanes |= c;
                    break;
                  }
                  k = k.next;
                }
              } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
              else if (18 === f.tag) {
                g = f.return;
                if (null === g) throw Error(p(341));
                g.lanes |= c;
                h = g.alternate;
                null !== h && (h.lanes |= c);
                Sg(g, c, b);
                g = f.sibling;
              } else g = f.child;
              if (null !== g) g.return = f;
              else for (g = f; null !== g; ) {
                if (g === b) {
                  g = null;
                  break;
                }
                f = g.sibling;
                if (null !== f) {
                  f.return = g.return;
                  g = f;
                  break;
                }
                g = g.return;
              }
              f = g;
            }
            Yi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
        case 15:
          return cj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, true, a, c);
        case 19:
          return yj(a, b, c);
        case 22:
          return ej(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Gk(a, b) {
      return ac(a, b);
    }
    function al(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new al(a, b, c, d);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a) return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da) return 11;
        if (a === Ga) return 14;
      }
      return 2;
    }
    function wh(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function yh(a, b, c, d, e, f) {
      var g = 2;
      d = a;
      if ("function" === typeof a) bj(a) && (g = 1);
      else if ("string" === typeof a) g = 5;
      else a: switch (a) {
        case ya:
          return Ah(c.children, e, f, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
        case Ea:
          return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
        case Fa:
          return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
        case Ia:
          return qj(c, e, f, b);
        default:
          if ("object" === typeof a && null !== a) switch (a.$$typeof) {
            case Ba:
              g = 10;
              break a;
            case Ca:
              g = 9;
              break a;
            case Da:
              g = 11;
              break a;
            case Ga:
              g = 14;
              break a;
            case Ha:
              g = 16;
              d = null;
              break a;
          }
          throw Error(p(130, null == a ? a : typeof a, ""));
      }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f;
      return b;
    }
    function Ah(a, b, c, d) {
      a = Bg(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function qj(a, b, c, d) {
      a = Bg(22, a, d, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function zh(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    function bl(a, b, c, d, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b, c, d, e, f, g, h, k) {
      a = new bl(a, b, c, h, k);
      1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
      f = Bg(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f);
      return a;
    }
    function dl(a, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function el(a) {
      if (!a) return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c)) return bg(a, c, b);
      }
      return b;
    }
    function fl(a, b, c, d, e, f, g, h, k) {
      a = cl(c, d, true, a, e, f, g, h, k);
      a.context = el(null);
      c = a.current;
      d = L();
      e = lh(c);
      f = ch(d, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      dh(c, f, e);
      a.current.lanes = e;
      Ac(a, e, d);
      Ek(a, d);
      return a;
    }
    function gl(a, b, c, d) {
      var e = b.current, f = L(), g = lh(e);
      c = el(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = ch(f, g);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a = dh(e, b, g);
      null !== a && (mh(a, e, g, f), eh(a, e, g));
      return g;
    }
    function hl(a) {
      a = a.current;
      if (!a.child) return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function jl(a, b) {
      il(a, b);
      (a = a.alternate) && il(a, b);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      gl(a, b, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b, c, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f = d;
          d = function() {
            var a2 = hl(g);
            f.call(a2);
          };
        }
        var g = fl(b, d, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g;
      }
      for (; e = a.lastChild; ) a.removeChild(e);
      if ("function" === typeof d) {
        var h = d;
        d = function() {
          var a2 = hl(k);
          h.call(a2);
        };
      }
      var k = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k;
      a[uf] = k.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b, k, c, d);
      });
      return k;
    }
    function sl(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = function() {
            var a2 = hl(g);
            h.call(a2);
          };
        }
        gl(b, g, a, e);
      } else g = rl(c, b, a, e, d);
      return hl(g);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b2 = Zg(a, 1);
            if (null !== b2) {
              var c2 = L();
              mh(b2, a, 1, c2);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b = Zg(a, 134217728);
        if (null !== b) {
          var c = L();
          mh(b, a, 134217728, c);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b = lh(a), c = Zg(a, b);
        if (null !== c) {
          var d = L();
          mh(c, a, b, d);
        }
        jl(a, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; ) c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e) throw Error(p(90));
                Wa(d);
                bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, null != b && fb(a, !!c.multiple, b, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
    var ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber) try {
        kc = wl.inject(vl), lc = wl;
      } catch (a) {
      }
    }
    var wl;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    exports.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b)) throw Error(p(200));
      return dl(a, b, null, c);
    };
    exports.createRoot = function(a, b) {
      if (!ol(a)) throw Error(p(299));
      var c = false, d = "", e = ll;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = cl(a, 1, false, null, null, c, false, d, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b);
    };
    exports.findDOMNode = function(a) {
      if (null == a) return null;
      if (1 === a.nodeType) return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render) throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    exports.flushSync = function(a) {
      return Sk(a);
    };
    exports.hydrate = function(a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, true, c);
    };
    exports.hydrateRoot = function(a, b, c) {
      if (!ol(a)) throw Error(p(405));
      var d = null != c && c.hydratedSources || null, e = false, f = "", g = ll;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = fl(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf] = b.current;
      sf(a);
      if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
        c,
        e
      );
      return new nl(b);
    };
    exports.render = function(a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, false, c);
    };
    exports.unmountComponentAtNode = function(a) {
      if (!pl(a)) throw Error(p(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    exports.unstable_batchedUpdates = Rk;
    exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!pl(c)) throw Error(p(200));
      if (null == a || void 0 === a._reactInternals) throw Error(p(38));
      return sl(a, b, c, false, d);
    };
    exports.version = "18.2.0-next-9e3b772b8-20220608";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m = require_react_dom();
    if (true) {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
var require_use_sync_external_store_shim_production = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
    "use strict";
    var React7 = require_react();
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    var useState17 = React7.useState;
    var useEffect14 = React7.useEffect;
    var useLayoutEffect = React7.useLayoutEffect;
    var useDebugValue = React7.useDebugValue;
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      var value = getSnapshot(), _useState = useState17({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      );
      useEffect14(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React7.useSyncExternalStore ? React7.useSyncExternalStore : shim;
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_use_sync_external_store_shim_production();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
    "use strict";
    var f = require_react();
    var k = Symbol.for("react.element");
    var l = Symbol.for("react.fragment");
    var m = Object.prototype.hasOwnProperty;
    var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
    var p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    exports.Fragment = l;
    exports.jsx = q;
    exports.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_jsx_runtime_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoteChatPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // API configuration
  openAiApiKey: "",
  llmModel: "gpt-4o-mini",
  // Default to Best Value model
  // Conversation settings
  conversationHistoryDirectory: "/NoteChat Conversations",
  // Internal settings
  noteFolderPath: ""
};
var OPENAI_MODELS = [
  {
    name: "gpt-4.1",
    displayName: "Ultimate Depth: GPT-4.1",
    description: "When you need rigorous business plans, in-depth technical proposals, or complex code refactoring, choose this. It offers the strongest logic and up to 1M token context\u2014though at the highest cost.",
    isDefault: false
  },
  {
    name: "gpt-4o",
    displayName: "All-Purpose Accelerator: GPT-4o",
    description: "Handle voice, images, and text in one go; first-token latency < 0.5s, perfect for real-time conversations and creative iterations. Mid-range pricing with a top-tier experience.",
    isDefault: false
  },
  {
    name: "gpt-4o-mini",
    displayName: "Best Value: GPT-4o-mini",
    description: "Supports the same 128K context, with reasoning performance close to larger models\u2014but at just 1/15 of the cost. Ideal for everyday writing, batch summarization, and lightweight scripting.",
    isDefault: true
  }
];
var NoteChatSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Sonoria Settings" });
    containerEl.createEl("h3", { text: "OpenAI Configuration" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key for content creation and conversations").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAiApiKey).onChange(async (value) => {
      this.plugin.settings.openAiApiKey = value;
      await this.plugin.saveSettings();
      if (this.plugin.conversationManager) {
        this.plugin.conversationManager.updateSettings();
      }
      new import_obsidian.Notice("OpenAI API Key updated.");
    }));
    new import_obsidian.Setting(containerEl).setName("Content Creation Model").setDesc("Select the OpenAI model for content creation and conversations").addButton((button) => {
      const currentModel = OPENAI_MODELS.find((m) => m.name === this.plugin.settings.llmModel);
      button.setButtonText(currentModel?.displayName || "Select Model").setClass("notechat-model-selector").onClick(() => {
        this.showModelSelector(button.buttonEl);
      });
      if (currentModel) {
        button.buttonEl.title = currentModel.description;
      }
      return button;
    });
    const style = document.createElement("style");
    style.textContent = `
			.notechat-model-selector {
				width: 100%;
				text-align: left;
				justify-content: space-between;
			}
			.notechat-model-selector:after {
				content: "\u25BC";
				font-size: 0.8em;
				opacity: 0.6;
				margin-left: auto;
			}
			.notechat-model-menu {
				position: fixed;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				box-shadow: var(--shadow-l);
				z-index: 100;
				min-width: 200px;
				max-width: 400px;
			}
			.notechat-model-option {
				padding: 8px 12px;
				cursor: pointer;
				border-bottom: 1px solid var(--background-modifier-border);
			}
			.notechat-model-option:last-child {
				border-bottom: none;
			}
			.notechat-model-option:hover {
				background: var(--background-modifier-hover);
			}
			.notechat-model-option.selected {
				background: var(--background-modifier-active);
			}
			.notechat-model-name {
				font-weight: 500;
				margin-bottom: 4px;
			}
			.notechat-model-desc {
				font-size: 0.9em;
				opacity: 0.8;
				line-height: 1.3;
			}
		`;
    containerEl.appendChild(style);
    const infoEl = containerEl.createEl("div", {
      cls: "setting-item-description",
      text: "\u2139\uFE0F TTS and STT models are preset and optimized for best performance"
    });
    infoEl.style.marginTop = "8px";
    infoEl.style.color = "var(--text-muted)";
    infoEl.style.fontSize = "0.9em";
    containerEl.createEl("h3", { text: "Conversation Settings" });
    new import_obsidian.Setting(containerEl).setName("Conversation History Directory").setDesc("Directory where conversation notes will be saved (use / for vault root)").addText((text) => text.setPlaceholder("/NoteChat Conversations").setValue(this.plugin.settings.conversationHistoryDirectory).onChange(async (value) => {
      this.plugin.settings.conversationHistoryDirectory = value;
      await this.plugin.saveSettings();
    }));
  }
  showModelSelector(buttonEl) {
    const existingMenu = document.querySelector(".notechat-model-menu");
    if (existingMenu) {
      existingMenu.remove();
      return;
    }
    const menu = document.createElement("div");
    menu.className = "notechat-model-menu";
    const buttonRect = buttonEl.getBoundingClientRect();
    menu.style.position = "fixed";
    menu.style.top = `${buttonRect.bottom + 5}px`;
    menu.style.left = `${buttonRect.left}px`;
    menu.style.width = `${buttonRect.width}px`;
    OPENAI_MODELS.forEach((model) => {
      const option = document.createElement("div");
      option.className = "notechat-model-option";
      if (model.name === this.plugin.settings.llmModel) {
        option.classList.add("selected");
      }
      const nameEl = document.createElement("div");
      nameEl.className = "notechat-model-name";
      nameEl.textContent = model.displayName;
      const descEl = document.createElement("div");
      descEl.className = "notechat-model-desc";
      descEl.textContent = model.description;
      option.appendChild(nameEl);
      option.appendChild(descEl);
      option.addEventListener("click", async () => {
        this.plugin.settings.llmModel = model.name;
        await this.plugin.saveSettings();
        const button = buttonEl;
        button.textContent = model.displayName;
        button.title = model.description;
        console.log(`NoteChat Settings: Updating model to: ${model.name}`);
        await this.plugin.initializeAIClient();
        if (this.plugin.conversationManager && this.plugin.aiClient) {
          this.plugin.conversationManager.setAIClient(this.plugin.aiClient);
          console.log(`NoteChat Settings: ConversationManager updated with new AI client using model: ${model.name}`);
        }
        if (this.plugin.openAIService) {
          const assistantUpdateSuccess = await this.plugin.openAIService.updateAssistantModel(model.name);
          if (assistantUpdateSuccess) {
            console.log(`NoteChat Settings: Assistant model successfully updated to: ${model.name}`);
          } else {
            console.warn(`NoteChat Settings: Failed to update assistant model to: ${model.name}`);
          }
        }
        new import_obsidian.Notice(`Model updated to: ${model.displayName}`);
        menu.remove();
      });
      menu.appendChild(option);
    });
    document.body.appendChild(menu);
    const closeMenu = (event) => {
      const target = event.target;
      if (menu.contains(target) || buttonEl.contains(target)) {
        return;
      }
      menu.remove();
      document.removeEventListener("click", closeMenu);
    };
    document.addEventListener("click", closeMenu, { passive: true });
    const observer2 = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.removedNodes.length > 0) {
          Array.from(mutation.removedNodes).forEach((node) => {
            if (node === menu) {
              document.removeEventListener("click", closeMenu);
              observer2.disconnect();
            }
          });
        }
      });
    });
    observer2.observe(document.body, { childList: true });
  }
};

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// src/core/services/storageService.ts
var StorageService = class {
  /**
   * Create a new storage service
   * @param plugin - The NoteChat plugin instance
   */
  constructor(plugin) {
    this.conversations = /* @__PURE__ */ new Map();
    this.messages = /* @__PURE__ */ new Map();
    this.notes = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.loadData();
  }
  /**
   * Load conversation data from storage
   */
  async loadData() {
    try {
      if (!this.plugin?.settings) {
        console.log("StorageService: Plugin settings not available yet, skipping load");
        return;
      }
      const data = await this.plugin.loadData();
      if (data?.conversations) {
        const conversations = JSON.parse(data.conversations);
        conversations.forEach((conversation) => {
          this.conversations.set(conversation.id, conversation);
        });
      }
      if (data?.messages) {
        const messages = JSON.parse(data.messages);
        Object.entries(messages).forEach(([conversationId, msgs]) => {
          this.messages.set(conversationId, msgs);
        });
      }
      if (data?.notes) {
        const notes = JSON.parse(data.notes);
        notes.forEach((note) => {
          this.notes.set(note.id, note);
        });
      }
    } catch (error) {
      console.error("Failed to load conversation data:", error);
    }
  }
  /**
   * Save conversation data to storage
   */
  async saveData() {
    try {
      if (!this.plugin?.settings) {
        console.log("StorageService: Plugin settings not available yet, skipping save");
        return;
      }
      const data = {
        conversations: JSON.stringify(Array.from(this.conversations.values())),
        messages: JSON.stringify(Object.fromEntries(this.messages)),
        notes: JSON.stringify(Array.from(this.notes.values()))
      };
      await this.plugin.saveData(data);
    } catch (error) {
      console.error("Failed to save conversation data:", error);
    }
  }
  /**
   * Create a new conversation
   * @param noteId - ID of the note the conversation is about
   * @param title - Title of the conversation
   * @param summary - Optional summary of the note
   * @returns The created conversation
   */
  async createConversation(noteId, title, summary) {
    const id = nanoid();
    const now = Date.now();
    const isoNow = new Date(now).toISOString();
    const conversation = {
      id,
      noteIds: [noteId],
      primaryNoteId: noteId,
      title,
      creationDate: isoNow,
      lastModified: isoNow,
      messages: [],
      summary,
      isArchived: false,
      previous_response_id: null,
      vectorStoreId: null
    };
    this.conversations.set(id, conversation);
    this.messages.set(id, []);
    await this.saveData();
    return conversation;
  }
  /**
   * Create a new conversation with multiple notes
   * @param noteIds - Array of note IDs to include in the conversation
   * @param primaryNoteId - ID of the primary note the conversation is centered on
   * @param title - Title of the conversation
   * @param summary - Optional summary of the notes
   * @param contextNotes - Optional metadata about the context notes
   * @returns The created conversation
   */
  async createMultiNoteConversation(noteIds, primaryNoteId, title, summary, contextNotes) {
    const id = nanoid();
    const now = Date.now();
    const isoNow = new Date(now).toISOString();
    const conversation = {
      id,
      noteIds,
      primaryNoteId,
      title,
      creationDate: isoNow,
      lastModified: isoNow,
      messages: [],
      summary,
      isArchived: false,
      contextNotes,
      previous_response_id: null,
      vectorStoreId: null
    };
    this.conversations.set(id, conversation);
    this.messages.set(id, []);
    await this.saveData();
    return conversation;
  }
  /**
   * Get a conversation by ID
   * @param id - ID of the conversation to get
   * @returns The conversation, or undefined if not found
   */
  getConversation(id) {
    return this.conversations.get(id);
  }
  /**
   * Get all conversations
   * @param noteId - Optional note ID to filter by
   * @returns Array of conversations
   */
  getConversations(noteId) {
    const conversations = Array.from(this.conversations.values());
    if (noteId) {
      return conversations.filter((c) => c.noteIds.includes(noteId));
    }
    return conversations;
  }
  /**
   * Update a conversation
   * @param conversation - The conversation to update
   * @returns The updated conversation
   */
  async updateConversation(conversation) {
    conversation.lastModified = (/* @__PURE__ */ new Date()).toISOString();
    this.conversations.set(conversation.id, conversation);
    await this.saveData();
    return conversation;
  }
  /**
   * Delete a conversation
   * @param id - ID of the conversation to delete
   * @returns True if the conversation was deleted, false otherwise
   */
  async deleteConversation(id) {
    const deleted = this.conversations.delete(id);
    this.messages.delete(id);
    if (deleted) {
      await this.saveData();
    }
    return deleted;
  }
  /**
   * Add a message to a conversation
   * @param conversationId - ID of the conversation to add the message to
   * @param content - Content of the message
   * @param role - Role of the message sender
   * @returns The created message
   */
  async addMessage(conversationId, content, role) {
    const conversation = this.conversations.get(conversationId);
    if (!conversation) {
      throw new Error(`Conversation with ID ${conversationId} not found`);
    }
    const id = nanoid();
    const message = {
      id,
      conversationId,
      content,
      role,
      timestamp: Date.now(),
      isHighlighted: false
    };
    const messages = this.messages.get(conversationId) || [];
    messages.push(message);
    this.messages.set(conversationId, messages);
    conversation.lastModified = (/* @__PURE__ */ new Date()).toISOString();
    conversation.messages = messages;
    this.conversations.set(conversationId, conversation);
    await this.saveData();
    return message;
  }
  /**
   * Get messages for a conversation
   * @param conversationId - ID of the conversation to get messages for
   * @returns Array of messages
   */
  getMessages(conversationId) {
    return this.messages.get(conversationId) || [];
  }
  /**
   * Create a note from a conversation
   * @param conversationId - ID of the conversation to create a note from
   * @param title - Title of the note
   * @param content - Content of the note
   * @param originalNoteId - ID of the original note
   * @returns The created note
   */
  async createNote(conversationId, title, content, originalNoteId) {
    const id = nanoid();
    const noteId = nanoid();
    const note = {
      id,
      conversationId,
      noteId,
      title,
      content,
      createdAt: Date.now(),
      metadata: {
        source: "conversation",
        originalNoteId
      }
    };
    this.notes.set(id, note);
    await this.saveData();
    return note;
  }
  /**
   * Update a note's ID after creation in Obsidian
   * @param noteId - ID of the note to update
   * @param obsidianNoteId - Obsidian note ID
   * @returns The updated note
   */
  async updateNoteId(noteId, obsidianNoteId) {
    const note = Array.from(this.notes.values()).find((n) => n.id === noteId);
    if (!note) {
      return void 0;
    }
    note.noteId = obsidianNoteId;
    this.notes.set(note.id, note);
    await this.saveData();
    return note;
  }
  /**
   * Get all notes
   * @param conversationId - Optional conversation ID to filter by
   * @returns Array of notes
   */
  getNotes(conversationId) {
    const notes = Array.from(this.notes.values());
    if (conversationId) {
      return notes.filter((n) => n.conversationId === conversationId);
    }
    return notes;
  }
  /**
   * Clear all conversation data
   */
  async clearData() {
    this.conversations.clear();
    this.messages.clear();
    this.notes.clear();
    await this.saveData();
  }
};

// src/features/chat/store/conversationContext.tsx
var import_obsidian3 = require("obsidian");

// src/utils/dateUtils.ts
function formatDateForNote(date = /* @__PURE__ */ new Date()) {
  return `Date ${date.toLocaleDateString("en-US", {
    month: "2-digit",
    day: "2-digit",
    year: "numeric"
  })} time ${date.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false
  })}`;
}
function formatDate(date, format = "medium") {
  if (!date) return "";
  const dateObj = typeof date === "object" ? date : new Date(date);
  if (isNaN(dateObj.getTime())) {
    return "";
  }
  switch (format) {
    case "short":
      return dateObj.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    case "long":
      return dateObj.toLocaleString([], {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    case "medium":
    default:
      return dateObj.toLocaleString([], {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
  }
}

// node_modules/mobx/dist/mobx.esm.js
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (false) {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die(false ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop2() {
};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x) {
    return isObject(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Map]";
}
function isPlainES6Map(thing) {
  var mapProto = Object.getPrototypeOf(thing);
  var objectProto = Object.getPrototypeOf(mapProto);
  var nullProto = Object.getPrototypeOf(objectProto);
  return nullProto === null;
}
function isES6Set(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys;
  }
  return [].concat(keys, symbols.filter(function(s) {
    return objectPrototype.propertyIsEnumerable.call(object2, s);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function getFlag(flags, mask) {
  return !!(flags & mask);
}
function setFlag(flags, mask, newValue) {
  if (newValue) {
    flags |= mask;
  } else {
    flags &= ~mask;
  }
  return flags;
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? {
        done: true
      } : {
        done: false,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    if (is20223Decorator(property)) {
      return annotation.decorate_20223_(target, property);
    } else {
      storeAnnotation(target, property, annotation);
    }
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (false) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(prototype, annotation, key);
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (false) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overridden by subclass.");
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
function is20223Decorator(context) {
  return typeof context == "object" && typeof context["kind"] == "string";
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = false ? "Atom@" + getNextId() : "Atom";
    }
    this.name_ = void 0;
    this.flags_ = 0;
    this.observers_ = /* @__PURE__ */ new Set();
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString2() {
    return this.name_;
  };
  return _createClass(Atom2, [{
    key: "isBeingObserved",
    get: function get3() {
      return getFlag(this.flags_, Atom2.isBeingObservedMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get3() {
      return getFlag(this.flags_, Atom2.isPendingUnobservationMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get3() {
      return getFlag(this.flags_, Atom2.diffValueMask_) ? 1 : 0;
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a, b) {
  return a === b;
}
function structuralComparer(a, b) {
  return deepEqual(a, b);
}
function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}
function defaultComparer(a, b) {
  if (Object.is) {
    return Object.is(a, b);
  }
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v, _, name) {
  if (isObservable(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name
    });
  }
  if (isPlainObject(v)) {
    return observable.object(v, void 0, {
      name
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name
    });
  }
  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }
  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === void 0 || v === null) {
    return v;
  }
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name,
      deep: false
    });
  }
  if (isPlainObject(v)) {
    return observable.object(v, void 0, {
      name,
      deep: false
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name,
      deep: false
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name,
      deep: false
    });
  }
  if (false) {
    die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if (false) {
    die("observable.struct should not be used with observable values");
  }
  if (deepEqual(v, oldValue)) {
    return oldValue;
  }
  return v;
}
var OVERRIDE = "override";
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function decorate_20223_$1(mthd, context) {
  if (false) {
    assert20223DecoratorType(context, ["method", "field"]);
  }
  var kind2 = context.kind, name = context.name, addInitializer = context.addInitializer;
  var ann = this;
  var _createAction = function _createAction2(m) {
    var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;
    return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);
  };
  if (kind2 == "field") {
    return function(initMthd) {
      var _ann$options_3;
      var mthd2 = initMthd;
      if (!isAction(mthd2)) {
        mthd2 = _createAction(mthd2);
      }
      if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {
        mthd2 = mthd2.bind(this);
        mthd2.isMobxAction = true;
      }
      return mthd2;
    };
  }
  if (kind2 == "method") {
    var _this$options_2;
    if (!isAction(mthd)) {
      mthd = _createAction(mthd);
    }
    if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {
      addInitializer(function() {
        var self2 = this;
        var bound = self2[name].bind(self2);
        bound.isMobxAction = true;
        self2[name] = bound;
      });
    }
    return mthd;
  }
  die("Cannot apply '" + ann.annotationType_ + "' to '" + String(name) + "' (kind: " + kind2 + "):" + ("\n'" + ann.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function decorate_20223_$2(mthd, context) {
  var _this$options_3;
  if (false) {
    assert20223DecoratorType(context, ["method"]);
  }
  var name = context.name, addInitializer = context.addInitializer;
  if (!isFlow(mthd)) {
    mthd = flow(mthd);
  }
  if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {
    addInitializer(function() {
      var self2 = this;
      var bound = self2[name].bind(self2);
      bound.isMobXFlow = true;
      self2[name] = bound;
    });
  }
  return mthd;
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function decorate_20223_$3(get3, context) {
  if (false) {
    assert20223DecoratorType(context, ["getter"]);
  }
  var ann = this;
  var key = context.name, addInitializer = context.addInitializer;
  addInitializer(function() {
    var adm = asObservableObject(this)[$mobx];
    var options = _extends({}, ann.options_, {
      get: get3,
      context: this
    });
    options.name || (options.name = false ? adm.name_ + "." + key.toString() : "ObservableObject." + key.toString());
    adm.values_.set(key, new ComputedValue(options));
  });
  return function() {
    return this[$mobx].getObservablePropValue_(key);
  };
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get3 = _ref2.get;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function decorate_20223_$4(desc, context) {
  if (false) {
    if (context.kind === "field") {
      throw die("Please use `@observable accessor " + String(context.name) + "` instead of `@observable " + String(context.name) + "`");
    }
    assert20223DecoratorType(context, ["accessor"]);
  }
  var ann = this;
  var kind2 = context.kind, name = context.name;
  var initializedObjects = /* @__PURE__ */ new WeakSet();
  function initializeObservable(target, value) {
    var _ann$options_$enhance, _ann$options_;
    var adm = asObservableObject(target)[$mobx];
    var observable2 = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer, false ? adm.name_ + "." + name.toString() : "ObservableObject." + name.toString(), false);
    adm.values_.set(name, observable2);
    initializedObjects.add(target);
  }
  if (kind2 == "accessor") {
    return {
      get: function get3() {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, desc.get.call(this));
        }
        return this[$mobx].getObservablePropValue_(name);
      },
      set: function set4(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return this[$mobx].setObservablePropValue_(name, value);
      },
      init: function init2(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return value;
      }
    };
  }
  return;
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set4 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set4
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set4
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
function decorate_20223_$5(desc, context) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v, arg2, arg3) {
  if (is20223Decorator(arg2)) {
    return observableAnnotation.decorate_20223_(v, arg2);
  }
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v)) {
    return v;
  }
  if (isPlainObject(v)) {
    return observable.object(v, arg2, arg3);
  }
  if (Array.isArray(v)) {
    return observable.array(v, arg2);
  }
  if (isES6Map(v)) {
    return observable.map(v, arg2);
  }
  if (isES6Set(v)) {
    return observable.set(v, arg2);
  }
  if (typeof v === "object" && v !== null) {
    return v;
  }
  return observable.box(v, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return computedAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  if (false) {
    if (!isFunction(arg1)) {
      die("First argument to `computed` should be an expression.");
    }
    if (isFunction(arg2)) {
      die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
    }
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config;
var _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  if (false) {
    if (!isFunction(fn)) {
      die("`action` can only be invoked on functions");
    }
    if (typeof actionName !== "string" || !actionName) {
      die("actions should have valid names, got: '" + actionName + "'");
    }
  }
  function res() {
    return executeAction(actionName, autoAction2, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  res.toString = function() {
    return fn.toString();
  };
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = false;
  var startTime_ = 0;
  if (false) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  if (false) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var ObservableValue = /* @__PURE__ */ function(_Atom) {
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = false ? "ObservableValue@" + getNextId() : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    if (false) {
      spyReport({
        type: CREATE,
        object: _this,
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }
    return _this;
  }
  _inheritsLoose(ObservableValue2, _Atom);
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set4(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      if (false) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue,
          oldValue
        });
      }
      this.setNewValue_(newValue);
      if (false) {
        spyReportEnd();
      }
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get3() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON2() {
    return this.get();
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var ComputedValue = /* @__PURE__ */ function() {
  function ComputedValue2(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.observers_ = /* @__PURE__ */ new Set();
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.flags_ = 0;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || (false ? "ComputedValue@" + getNextId() : "ComputedValue");
    if (options.set) {
      this.setter_ = createAction(false ? this.name_ + "-setter" : "ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get3() {
    if (this.isComputing) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set4(value) {
    if (this.setter_) {
      if (this.isRunningSetter) {
        die(33, this.name_);
      }
      this.isRunningSetter = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    );
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (false) {
        spyReport({
          observableKind: "computed",
          debugObjectName: this.name_,
          object: this.scope_,
          type: "update",
          oldValue,
          newValue
        });
      }
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
      if (false) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (true) {
      return;
    }
    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return _createClass(ComputedValue2, [{
    key: "isComputing",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isComputingMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isComputingMask_, newValue);
    }
  }, {
    key: "isRunningSetter",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isRunningSetterMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isRunningSetterMask_, newValue);
    }
  }, {
    key: "isBeingObserved",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isBeingObservedMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.diffValueMask_) ? 1 : 0;
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l = obs.length;
      for (var i = 0; i < l; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  if (true) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) {
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
  }
}
function checkIfStateReadsAreAllowed(observable2) {
  if (false) {
    console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    derivation.runId_ === 0 ? 100 : derivation.observing_.length
  );
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (true) {
    return;
  }
  if (derivation.observing_.length !== 0) {
    return;
  }
  if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l = derivation.unboundDepsCount_;
  for (var i = 0; i < l; i++) {
    var dep = observing[i];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l = prevObserving.length;
  while (l--) {
    var _dep = prevObserving[l];
    if (_dep.diffValue === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue === 1) {
      _dep2.diffValue = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0) {
      global2.__mobxGlobals = void 0;
    }
    globalState = new MobXGlobals();
  }
}
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  checkIfStateReadsAreAllowed(observable2);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved && globalState.trackingContext) {
        observable2.isBeingObserved = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (false) {
        logTraceInfo(d, observable2);
      }
      d.onBecomeStale_();
    }
    d.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;
      if (false) {
        logTraceInfo(d, observable2);
      }
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = false ? "Reaction@" + getNextId() : "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.flags_ = 0;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled) {
      this.isScheduled = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed) {
      startBatch();
      this.isScheduled = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending = true;
        try {
          this.onInvalidate_();
          if (false) {
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed) {
      return;
    }
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (false) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }
    this.isRunning = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning = false;
    this.isTrackPending = false;
    if (this.isDisposed) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    if (false) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message = false ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    } else if (false) {
      console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
    }
    if (false) {
      spyReport({
        type: "error",
        name: this.name_,
        message,
        error: "" + error
      });
    }
    globalState.globalReactionErrorHandlers.forEach(function(f) {
      return f(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed) {
      this.isDisposed = true;
      if (!this.isRunning) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString2() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace(this, enterBreakPoint);
  };
  return _createClass(Reaction2, [{
    key: "isDisposed",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isDisposedMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isDisposedMask_, newValue);
    }
  }, {
    key: "isScheduled",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isScheduledMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isScheduledMask_, newValue);
    }
  }, {
    key: "isTrackPending",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isTrackPendingMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isTrackPendingMask_, newValue);
    }
  }, {
    key: "isRunning",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isRunningMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isRunningMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.diffValueMask_) ? 1 : 0;
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f) {
  return f();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error(false ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f) {
    return fn(function() {
      return baseScheduler(f);
    });
  };
}
function isSpyEnabled() {
  return false;
}
function spy(listener) {
  if (true) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l) {
        return l !== listener;
      });
    });
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (is20223Decorator(arg2)) {
      return (autoAction2 ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
    if (false) {
      die("Invalid arguments for `action`");
    }
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (false) {
    if (!isFunction(view)) {
      die("Autorun expects a function as first argument");
    }
    if (isAction(view)) {
      die("Autorun does not accept actions since actions are untrackable");
    }
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : false ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;
  if (runSync) {
    reaction = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction.isDisposed) {
            reaction.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction);
  }
  if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {
    reaction.schedule_();
  }
  return reaction.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f) {
  return f();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
    return setTimeout(f, opts.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options.useProxies, enforceActions = options.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== void 0) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options) {
      globalState[key] = !!options[key];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (false) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }
  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options) {
  if (false) {
    if (arguments.length > 4) {
      die("'extendObservable' expected 2-4 arguments");
    }
    if (typeof target !== "object") {
      die("'extendObservable' expects an object as first argument");
    }
    if (isObservableMap(target)) {
      die("'extendObservable' should not be used on maps, use map.merge instead");
    }
    if (!isPlainObject(properties)) {
      die("'extendObservable' only accepts plain objects as second argument");
    }
    if (isObservable(properties) || isObservable(annotations)) {
      die("Extending an object with another observable (object) is not supported");
    }
  }
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(
        key,
        descriptors[key],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  });
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return flowAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  if (false) {
    die("Flow expects single argument with generator function");
  }
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel)) {
    promise.cancel();
  }
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (false) {
      return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    }
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (false) {
    die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  }
  return _isObservable(value);
}
function trace() {
  if (true) {
    return;
  }
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean") {
    enterBreakPoint = args.pop();
  }
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has(target, name) {
    if (false) {
      warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    }
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set2(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name)) {
      return false;
    }
    if (false) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (false) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    if (false) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    }
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    if (false) {
      warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    }
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options) {
  initObservable(function() {
    var _annotations;
    var adm = asObservableObject(target, options)[$mobx];
    if (false) {
      die("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.");
    }
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  });
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) {
      return adm;
    }
    if (name === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set3(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, false ? name + "[..]" : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0) {
      return values.map(this.dehancer);
    }
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === void 0) {
      index = 0;
    } else if (index > length) {
      index = length;
    } else if (index < 0) {
      index = Math.max(0, length + index);
    }
    if (arguments.length === 1) {
      deleteCount = length - index;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
      return _this.enhancer_(v, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index,
      newValue,
      oldValue
    } : null;
    if (false) {
      spyReportStart(change);
    }
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (false) {
      spyReportEnd();
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (false) {
      spyReportStart(change);
    }
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (false) {
      spyReportEnd();
    }
  };
  _proto.get_ = function get_(index) {
    if (this.legacyMode_ && index >= this.values_.length) {
      console.warn(false ? "[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + index);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index]);
  };
  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;
    if (this.legacyMode_ && index > values.length) {
      die(17, index, values.length);
    }
    if (index < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index + 1 - values.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index);
      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }
    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
var ObservableMap = /* @__PURE__ */ function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = false ? "ObservableMap@" + getNextId() : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    initObservable(function() {
      _this.keysAtom_ = createAtom(false ? _this.name_ + ".keys()" : "ObservableMap.keys()");
      _this.data_ = /* @__PURE__ */ new Map();
      _this.hasMap_ = /* @__PURE__ */ new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has3(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, false ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set4(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (false) {
        spyReportStart(_change);
      }
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      if (false) {
        spyReportEnd();
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (false) {
        spyReportStart(change);
      }
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
      if (false) {
        spyReportEnd();
      }
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, false ? _this4.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (false) {
      spyReportStart(change);
    }
    if (notify) {
      notifyListeners(this, change);
    }
    if (false) {
      spyReportEnd();
    }
  };
  _proto.get = function get3(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[Symbol.iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other)) {
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (!isPlainES6Map(other)) {
          die(19, other);
        }
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear2() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString2() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false) {
      die("`observe` doesn't support fireImmediately=true in combination with maps.");
    }
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  return _createClass(ObservableMap2, [{
    key: "size",
    get: function get3() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get3() {
      return "Map";
    }
  }]);
}();
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function makeIterableForMap(iterator) {
  iterator[Symbol.toStringTag] = "MapIterator";
  return makeIterable(iterator);
}
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map2 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map2.set(key, dataStructure[key]);
    }
    return map2;
  } else {
    return die(21, dataStructure);
  }
}
var ObservableSetMarker = {};
var ObservableSet = /* @__PURE__ */ function() {
  function ObservableSet2(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = false ? "ObservableSet@" + getNextId() : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function() {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear2() {
    var _this2 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (!this.has(value)) {
      transaction(function() {
        _this3.data_.add(_this3.enhancer_(value, void 0));
        _this3.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && false) {
        spyReportStart(_change);
      }
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy && false) {
        spyReportEnd();
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && false) {
        spyReportStart(_change2);
      }
      transaction(function() {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      if (notifySpy && false) {
        spyReportEnd();
      }
      return true;
    }
    return false;
  };
  _proto.has = function has3(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var values = this.values();
    return makeIterableForSet({
      next: function next() {
        var _values$next = values.next(), value = _values$next.value, done = _values$next.done;
        return !done ? {
          value: [value, value],
          done
        } : {
          value: void 0,
          done
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var values2 = this.data_.values();
    return makeIterableForSet({
      next: function next() {
        var _values$next2 = values2.next(), value = _values$next2.value, done = _values$next2.done;
        return !done ? {
          value: self2.dehanceValue_(value),
          done
        } : {
          value: void 0,
          done
        };
      }
    });
  };
  _proto.intersection = function intersection(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.intersection(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.intersection(otherSet);
    }
  };
  _proto.union = function union(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.union(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.union(otherSet);
    }
  };
  _proto.difference = function difference(otherSet) {
    return new Set(this).difference(otherSet);
  };
  _proto.symmetricDifference = function symmetricDifference(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.symmetricDifference(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.symmetricDifference(otherSet);
    }
  };
  _proto.isSubsetOf = function isSubsetOf(otherSet) {
    return new Set(this).isSubsetOf(otherSet);
  };
  _proto.isSupersetOf = function isSupersetOf(otherSet) {
    return new Set(this).isSupersetOf(otherSet);
  };
  _proto.isDisjointFrom = function isDisjointFrom(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.isDisjointFrom(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.isDisjointFrom(otherSet);
    }
  };
  _proto.replace = function replace2(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false) {
      die("`observe` doesn't support fireImmediately=true in combination with sets.");
    }
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.toString = function toString2() {
    return "[object ObservableSet]";
  };
  _proto[Symbol.iterator] = function() {
    return this.values();
  };
  return _createClass(ObservableSet2, [{
    key: "size",
    get: function get3() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get3() {
      return "Set";
    }
  }]);
}();
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
function makeIterableForSet(iterator) {
  iterator[Symbol.toStringTag] = "SetIterator";
  return makeIterable(iterator);
}
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom(false ? this.name_ + ".keys" : "ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
    if (false) {
      die("defaultAnnotation must be valid annotation");
    }
    if (false) {
      this.appliedAnnotations_ = {};
    }
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (false) {
        spyReportStart(_change);
      }
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
      if (false) {
        spyReportEnd();
      }
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, false ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (false) {
        delete this.appliedAnnotations_[key];
      }
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false) {
          spyReportStart(_change2);
        }
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (false) {
          spyReportEnd();
        }
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (false) {
      die("`observe` doesn't support the fire immediately property for observable objects.");
    }
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (false) {
        spyReportStart(change);
      }
      if (notify) {
        notifyListeners(this, change);
      }
      if (false) {
        spyReportEnd();
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (false) {
    die("Options can't be provided for already observable objects.");
  }
  if (hasProp(target, $mobx)) {
    if (false) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (false) {
    die("Cannot make the designated object observable; it is not extensible");
  }
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : false ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get3() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set4(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (false) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  if (false) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (false) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overridden by subclass.");
  }
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var v = false;
  var p = {};
  Object.defineProperty(p, "0", {
    set: function set4() {
      v = true;
    }
  });
  Object.create(p)["0"] = 1;
  return v === false;
}();
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray) {
  function LegacyObservableArray2(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function() {
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _this;
      addHiddenFinalProp(_this, $mobx, adm);
      if (initialValues && initialValues.length) {
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        Object.defineProperty(_this, "0", ENTRY_0);
      }
    });
    return _this;
  }
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      })
    );
  };
  _proto[Symbol.iterator] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  return _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get3() {
      return this[$mobx].getArrayLength_();
    },
    set: function set4(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get3() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
  }
});
function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get3() {
      return this[$mobx].get_(index);
    },
    set: function set4(value) {
      this[$mobx].set_(index, value);
    }
  };
}
function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges);
    untrackedEnd(derivation);
  }
}
var toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a, b, depth);
}
function eq(a, b, depth, aStack, bStack) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  if (a == null || b == null) {
    return false;
  }
  if (a !== a) {
    return b !== b;
  }
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") {
    return false;
  }
  var className = toString.call(a);
  if (className !== toString.call(b)) {
    return false;
  }
  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) {
        return +b !== +b;
      }
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") {
      return false;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) {
      return false;
    }
    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys = Object.keys(a);
    var _length = keys.length;
    if (Object.keys(b).length !== _length) {
      return false;
    }
    for (var i = 0; i < _length; i++) {
      var key = keys[i];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a) {
  if (isObservableArray(a)) {
    return a.slice();
  }
  if (isES6Map(a) || isObservableMap(a)) {
    return Array.from(a.entries());
  }
  if (isES6Set(a) || isObservableSet(a)) {
    return Array.from(a.entries());
  }
  return a;
}
var _getGlobal$Iterator;
var maybeIteratorPrototype = ((_getGlobal$Iterator = getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || {};
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return Object.assign(Object.create(maybeIteratorPrototype), iterator);
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m) {
  var g = getGlobal();
  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}

// src/core/api/PlaceholderAIClient.ts
var import_obsidian2 = require("obsidian");
var PlaceholderAIClient = class {
  constructor(reason = "AI features are disabled. API key missing or invalid.") {
    this.provider = "placeholder";
    this.model = "placeholder_model";
    this.reason = reason;
    console.warn(`PlaceholderAIClient initialized. Reason: ${this.reason}`);
  }
  initialize(_apiKey, _model) {
    console.warn("PlaceholderAIClient: initialize called, but it's a no-op.");
  }
  updateApiKey(_apiKey) {
    new import_obsidian2.Notice("Placeholder AI Client: API key update ignored. Configure a real AI provider.");
    console.warn("PlaceholderAIClient: updateApiKey called.");
  }
  updateModel(_model) {
    new import_obsidian2.Notice("Placeholder AI Client: Model update ignored. Configure a real AI provider.");
    console.warn("PlaceholderAIClient: updateModel called.");
  }
  async handleConversationMessage(_messages, _systemPrompt) {
    console.warn("PlaceholderAIClient: handleConversationMessage called. Reason:", this.reason);
    new import_obsidian2.Notice(this.reason, 1e4);
    return Promise.resolve(this.reason);
  }
  async generateStructuredNote(_messages, _context) {
    console.warn("PlaceholderAIClient: generateStructuredNote called. Reason:", this.reason);
    new import_obsidian2.Notice(this.reason, 1e4);
    return Promise.resolve(`# Placeholder Note

${this.reason}`);
  }
  async generateNoteSummary(_text) {
    console.warn("PlaceholderAIClient: generateNoteSummary called. Reason:", this.reason);
    new import_obsidian2.Notice(this.reason, 1e4);
    return Promise.resolve(`Summary not available. ${this.reason}`);
  }
  async generateBriefNoteSummary(_text) {
    console.warn("PlaceholderAIClient: generateBriefNoteSummary called. Reason:", this.reason);
    new import_obsidian2.Notice(this.reason, 1e4);
    return Promise.resolve(`Brief summary not available. ${this.reason}`);
  }
};

// src/utils/StreamSentenceProcessor.ts
var StreamSentenceProcessor = class {
  constructor(onSentenceComplete) {
    this.buffer = "";
    this.firstSentenceEmitted = false;
    this.onSentenceComplete = onSentenceComplete;
  }
  /**
   * Process a text chunk from streaming and extract complete sentences
   * @param chunk - The text chunk from streaming
   * @returns Array of complete sentences found in this chunk
   */
  processTextChunk(chunk) {
    console.log(`StreamSentenceProcessor: Processing chunk: "${chunk}"`);
    if (!chunk) {
      console.log("StreamSentenceProcessor: Empty chunk, returning empty array");
      return [];
    }
    this.buffer += chunk;
    console.log(`StreamSentenceProcessor: Updated buffer: "${this.buffer}"`);
    const sentences = this.extractCompleteSentences(this.buffer);
    console.log(`StreamSentenceProcessor: Extracted ${sentences.length} sentences:`, sentences);
    if (sentences.length > 0) {
      sentences.forEach((sentence, index) => {
        const isFirstSentence = !this.firstSentenceEmitted && index === 0;
        if (isFirstSentence) {
          this.firstSentenceEmitted = true;
        }
        const processedSentence = sentence.startsWith(" ") ? sentence : sentence.trim();
        console.log(`StreamSentenceProcessor: Calling callback for sentence ${index}: "${processedSentence}" (isFirst: ${isFirstSentence})`);
        this.onSentenceComplete(processedSentence, isFirstSentence);
      });
      const remainingText = this.getRemainingText(this.buffer, sentences);
      console.log(`StreamSentenceProcessor: Remaining text in buffer: "${remainingText}"`);
      this.buffer = remainingText;
    } else {
      console.log("StreamSentenceProcessor: No complete sentences found, keeping text in buffer");
    }
    return sentences;
  }
  /**
   * Extract complete sentences from text, handling edge cases
   * @param text - Text to extract sentences from
   * @returns Array of complete sentences
   */
  extractCompleteSentences(text) {
    console.log(`StreamSentenceProcessor.extractCompleteSentences: Processing text: "${text}"`);
    try {
      const sentencePattern = /[.!?]+(?:\s|$)/g;
      const sentences = [];
      let lastIndex = 0;
      let match;
      console.log(`StreamSentenceProcessor.extractCompleteSentences: Starting regex matching`);
      while ((match = sentencePattern.exec(text)) !== null) {
        try {
          console.log(`StreamSentenceProcessor.extractCompleteSentences: Found match at index ${match.index}: "${match[0]}"`);
          const punctuationEnd = match.index + match[0].replace(/\s+$/, "").length;
          const rawSentence = text.substring(lastIndex, punctuationEnd);
          const trimmedSentence = rawSentence.trim();
          console.log(`StreamSentenceProcessor.extractCompleteSentences: Raw sentence: "${rawSentence}", Trimmed: "${trimmedSentence}"`);
          if (this.isLikelyAbbreviation(trimmedSentence)) {
            console.log(`StreamSentenceProcessor.extractCompleteSentences: Skipping abbreviation: "${trimmedSentence}"`);
            continue;
          }
          if (trimmedSentence.length > 3) {
            console.log(`StreamSentenceProcessor.extractCompleteSentences: Adding sentence: "${rawSentence}"`);
            sentences.push(rawSentence);
            lastIndex = punctuationEnd;
          } else {
            console.log(`StreamSentenceProcessor.extractCompleteSentences: Skipping short sentence: "${trimmedSentence}"`);
            lastIndex = punctuationEnd;
          }
        } catch (matchError) {
          console.error(`StreamSentenceProcessor.extractCompleteSentences: Error processing match at index ${match.index}:`, matchError);
          break;
        }
      }
      console.log(`StreamSentenceProcessor.extractCompleteSentences: Completed, found ${sentences.length} sentences`);
      return sentences;
    } catch (error) {
      console.error(`StreamSentenceProcessor.extractCompleteSentences: Critical error in sentence extraction:`, error);
      return [];
    }
  }
  /**
   * Check if a potential sentence is likely an abbreviation
   * @param sentence - The potential sentence to check
   * @returns True if likely an abbreviation
   */
  isLikelyAbbreviation(sentence) {
    const trimmed = sentence.trim();
    const abbreviations = [
      "Dr.",
      "Mr.",
      "Mrs.",
      "Ms.",
      "Prof.",
      "vs.",
      "etc.",
      "i.e.",
      "e.g.",
      "Inc.",
      "Corp.",
      "Ltd.",
      "Co.",
      "Jr.",
      "Sr.",
      "Ph.D.",
      "M.D."
    ];
    if (abbreviations.some((abbr) => trimmed.toLowerCase() === abbr.toLowerCase())) {
      return true;
    }
    if (/^[A-Za-z]\.$/.test(trimmed)) {
      return true;
    }
    if (/^\d+\.\d*$/.test(trimmed.replace(/[^\d.]/g, ""))) {
      return true;
    }
    return false;
  }
  /**
   * Get remaining text after removing complete sentences
   * @param originalText - The original text buffer
   * @param extractedSentences - The sentences that were extracted
   * @returns Remaining text that hasn't formed complete sentences yet
   */
  getRemainingText(originalText, extractedSentences) {
    if (extractedSentences.length === 0) {
      return originalText;
    }
    const sentencePattern = /[.!?]+(?:\s|$)/g;
    let lastProcessedIndex = 0;
    let sentencesFound = 0;
    let match;
    while ((match = sentencePattern.exec(originalText)) !== null && sentencesFound < extractedSentences.length) {
      const punctuationEnd = match.index + match[0].replace(/\s+$/, "").length;
      const rawSentence = originalText.substring(lastProcessedIndex, punctuationEnd);
      const trimmedSentence = rawSentence.trim();
      if (this.isLikelyAbbreviation(trimmedSentence)) {
        continue;
      }
      if (trimmedSentence.length > 3) {
        sentencesFound++;
        lastProcessedIndex = punctuationEnd;
      } else {
        lastProcessedIndex = punctuationEnd;
      }
    }
    return originalText.substring(lastProcessedIndex);
  }
  /**
   * Finalize processing - handle any remaining text as the last sentence
   * @returns The final sentence if any text remains in buffer
   */
  finalize() {
    if (this.buffer.trim().length > 0) {
      const finalSentence = this.buffer.trim();
      this.onSentenceComplete(finalSentence, !this.firstSentenceEmitted);
      this.buffer = "";
      return finalSentence;
    }
    return null;
  }
  /**
   * Reset the processor for a new stream
   */
  reset() {
    this.buffer = "";
    this.firstSentenceEmitted = false;
  }
  /**
   * Get current buffer content (for debugging)
   */
  getCurrentBuffer() {
    return this.buffer;
  }
};

// src/utils/ProgressiveTTSQueue.ts
var ProgressiveTTSQueue = class {
  constructor(openAIService, cache) {
    this.openAIService = openAIService;
    this.cache = cache;
    this.queue = [];
    this.processing = /* @__PURE__ */ new Set();
    this.messageSequences = /* @__PURE__ */ new Map();
    // Track sequence index per message
    this.listeners = {};
    this.isProcessing = false;
  }
  /**
   * Set up event listeners for TTS queue events
   * @param event - Event name to listen for
   * @param callback - Callback function for the event
   */
  on(event, callback) {
    this.listeners[event] = callback;
  }
  /**
   * Remove event listener
   * @param event - Event name to remove listener for
   */
  off(event) {
    delete this.listeners[event];
  }
  /**
   * Queue a sentence for TTS processing
   * @param sentence - The sentence text to convert to speech
   * @param messageId - The message this sentence belongs to
   * @param isFirstSentence - Whether this is the first sentence (gets priority)
   * @returns Promise that resolves when queuing is complete
   */
  async queueSentence(sentence, messageId, isFirstSentence) {
    if (!sentence || sentence.trim().length === 0) {
      console.warn("ProgressiveTTSQueue: Empty sentence ignored");
      return;
    }
    const priority = isFirstSentence ? 1 : 2;
    const sequenceIndex = this.getNextSequenceIndex(messageId);
    if (this.cache) {
      const cacheKey = this.generateCacheKey(sentence);
      const cachedAudio = await this.cache.get(cacheKey);
      if (cachedAudio) {
        console.log(`ProgressiveTTSQueue: Cache hit for sentence ${sequenceIndex} in message ${messageId}`);
        this.emitSentenceGenerated(messageId, sequenceIndex, cachedAudio, isFirstSentence);
        return;
      }
    }
    const task = {
      id: nanoid(),
      sentence,
      priority,
      messageId,
      sequenceIndex,
      timestamp: Date.now()
    };
    this.queue.push(task);
    this.sortQueue();
    console.log(`ProgressiveTTSQueue: Queued sentence ${sequenceIndex} for message ${messageId} (priority: ${priority})`);
    this.processQueueAsync();
  }
  /**
   * Get the next sequence index for a message
   */
  getNextSequenceIndex(messageId) {
    const currentIndex = this.messageSequences.get(messageId) || 0;
    const nextIndex = currentIndex;
    this.messageSequences.set(messageId, currentIndex + 1);
    return nextIndex;
  }
  /**
   * Sort queue by priority (1 = highest priority)
   */
  sortQueue() {
    this.queue.sort((a, b) => {
      if (a.priority !== b.priority) {
        return a.priority - b.priority;
      }
      return a.timestamp - b.timestamp;
    });
  }
  /**
   * Process the queue asynchronously without blocking
   */
  async processQueueAsync() {
    if (this.isProcessing) return;
    this.isProcessing = true;
    try {
      while (this.queue.length > 0) {
        const task = this.queue.shift();
        if (!task) break;
        try {
          await this.processTask(task);
        } catch (error) {
          console.error(`ProgressiveTTSQueue: Error processing task ${task.id}:`, error);
          this.emitError(task.messageId, error instanceof Error ? error.message : "Unknown error", task.sentence);
        }
      }
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Process a single TTS task
   */
  async processTask(task) {
    if (this.processing.has(task.id)) {
      return;
    }
    this.processing.add(task.id);
    try {
      console.log(`ProgressiveTTSQueue: Processing sentence ${task.sequenceIndex} for message ${task.messageId}`);
      const audioBlob = await this.generateTTSWithStreaming(task.sentence);
      if (audioBlob) {
        if (this.cache) {
          const cacheKey = this.generateCacheKey(task.sentence);
          await this.cache.set(cacheKey, audioBlob);
        }
        const isFirstSentence = task.priority === 1;
        this.emitSentenceGenerated(task.messageId, task.sequenceIndex, audioBlob, isFirstSentence);
        console.log(`ProgressiveTTSQueue: Generated audio for sentence ${task.sequenceIndex} in message ${task.messageId}`);
      } else {
        throw new Error("TTS generation returned null");
      }
    } finally {
      this.processing.delete(task.id);
    }
  }
  /**
   * Generate TTS audio for a sentence, with streaming support if available
   */
  async generateTTSWithStreaming(sentence) {
    try {
      const audioBlob = await this.openAIService.textToSpeech(sentence, {
        voice: "alloy",
        format: "mp3"
      });
      return audioBlob;
    } catch (error) {
      console.error("ProgressiveTTSQueue: TTS generation error:", error);
      return null;
    }
  }
  /**
   * Generate cache key for a sentence
   */
  generateCacheKey(sentence) {
    const normalized = sentence.trim().toLowerCase().replace(/\s+/g, " ");
    return `tts_${this.hashString(normalized)}_alloy_mp3`;
  }
  /**
   * Simple hash function for cache keys
   */
  hashString(str2) {
    let hash = 0;
    for (let i = 0; i < str2.length; i++) {
      const char = str2.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  /**
   * Emit sentence generated event
   */
  emitSentenceGenerated(messageId, sequenceIndex, audioBlob, isFirstSentence) {
    if (this.listeners.sentenceGenerated) {
      this.listeners.sentenceGenerated(messageId, sequenceIndex, audioBlob, isFirstSentence);
    }
    if (isFirstSentence && this.listeners.firstSentenceReady) {
      this.listeners.firstSentenceReady(messageId, audioBlob);
    }
  }
  /**
   * Emit error event
   */
  emitError(messageId, error, sentence) {
    if (this.listeners.error) {
      this.listeners.error(messageId, error, sentence);
    }
  }
  /**
   * Clear all tasks for a specific message (useful for cancellation)
   */
  clearMessage(messageId) {
    this.queue = this.queue.filter((task) => task.messageId !== messageId);
    this.messageSequences.delete(messageId);
    console.log(`ProgressiveTTSQueue: Cleared all tasks for message ${messageId}`);
  }
  /**
   * Get queue statistics for monitoring
   */
  getStats() {
    return {
      queueLength: this.queue.length,
      processingCount: this.processing.size,
      messageCount: this.messageSequences.size
    };
  }
  /**
   * Clear all pending tasks
   */
  clear() {
    this.queue = [];
    this.processing.clear();
    this.messageSequences.clear();
    console.log("ProgressiveTTSQueue: Cleared all tasks");
  }
};

// src/utils/ProgressiveAudioPlayback.ts
var ProgressiveAudioPlayback = class {
  constructor() {
    this.audioSequences = /* @__PURE__ */ new Map();
    this.currentlyPlaying = /* @__PURE__ */ new Map();
    this.pausedAt = /* @__PURE__ */ new Map();
    // Track where each message was paused
    this.objectUrls = /* @__PURE__ */ new Map();
    // Track object URLs for cleanup
    this.eventListeners = /* @__PURE__ */ new Map();
    // 🎯 AUTOPLAY FIX: Track user gesture establishment for autoplay permissions
    this.audioContextReady = false;
    this.userGestureEstablished = false;
    this.audioContext = null;
    this.setupUserGestureDetection();
  }
  // 🎯 AUTOPLAY FIX: Set up user gesture detection for autoplay permissions
  setupUserGestureDetection() {
    const establishGesture = () => {
      if (!this.userGestureEstablished) {
        console.log("\u{1F3AF} ProgressiveAudio: User gesture established for autoplay");
        this.userGestureEstablished = true;
        this.initializeAudioContext();
      }
    };
    document.addEventListener("click", establishGesture, { once: false });
    document.addEventListener("keydown", establishGesture, { once: false });
    document.addEventListener("touchstart", establishGesture, { once: false });
    document.addEventListener("mousedown", establishGesture, { once: false });
  }
  // 🎯 AUTOPLAY FIX: Initialize AudioContext to work around autoplay restrictions
  async initializeAudioContext() {
    if (this.audioContextReady) return;
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (this.audioContext.state === "suspended") {
        await this.audioContext.resume();
      }
      this.audioContextReady = true;
      console.log("\u{1F3AF} ProgressiveAudio: AudioContext initialized and ready for autoplay");
    } catch (error) {
      console.warn("\u{1F3AF} ProgressiveAudio: Failed to initialize AudioContext:", error);
    }
  }
  // 🎯 AUTOPLAY FIX: Public method to establish user gesture (called from voice recording)
  establishUserGesture() {
    if (!this.userGestureEstablished) {
      console.log("\u{1F3AF} ProgressiveAudio: User gesture manually established via voice recording");
      this.userGestureEstablished = true;
      this.initializeAudioContext();
    }
  }
  /**
   * Queue sentence audio for progressive playback
   * @param audioBlob - The audio blob for this sentence
   * @param messageId - The message this audio belongs to
   * @param sequenceIndex - The position of this sentence in the message
   * @param isFirstSentence - Whether this is the first sentence
   * @param autoPlay - Whether to auto-start playback (only true in voice conversation mode)
   */
  async queueSentenceAudio(audioBlob, messageId, sequenceIndex, isFirstSentence, autoPlay = false) {
    try {
      const objectUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(objectUrl);
      if (!this.audioSequences.has(messageId)) {
        this.audioSequences.set(messageId, []);
        this.objectUrls.set(messageId, []);
        this.eventListeners.set(messageId, /* @__PURE__ */ new Map());
      }
      const sequence = this.audioSequences.get(messageId);
      const urls = this.objectUrls.get(messageId);
      const listeners = this.eventListeners.get(messageId);
      if (!sequence || !urls || !listeners) {
        console.error(`Progressive Audio: Missing data structures for message ${messageId}`);
        return;
      }
      sequence[sequenceIndex] = audio;
      urls[sequenceIndex] = objectUrl;
      const audioListeners = {
        ended: () => this.playNextSentence(messageId),
        error: (event) => this.handleAudioError(messageId, sequenceIndex, event),
        play: () => {
          console.log(`Progressive Audio: Started playing sentence ${sequenceIndex} for message ${messageId}`);
          this.notifyPlaybackStateChange(messageId, "playing");
        },
        pause: () => {
          console.log(`Progressive Audio: Paused sentence ${sequenceIndex} for message ${messageId}`);
          this.notifyPlaybackStateChange(messageId, "paused");
        }
      };
      listeners.set(sequenceIndex, audioListeners);
      audio.addEventListener("ended", audioListeners.ended);
      audio.addEventListener("error", audioListeners.error);
      audio.addEventListener("play", audioListeners.play);
      audio.addEventListener("pause", audioListeners.pause);
      console.log(`Progressive Audio: Queued sentence ${sequenceIndex} for message ${messageId} (autoPlay: ${autoPlay})`);
      if (autoPlay && isFirstSentence && sequenceIndex === 0 && !this.currentlyPlaying.has(messageId)) {
        console.log(`\u{1F504} Progressive Audio: Auto-starting playback for first sentence in message ${messageId} (voice mode)`);
        console.log(`\u{1F3AF} Progressive Audio: Autoplay status - userGestureEstablished: ${this.userGestureEstablished}, audioContextReady: ${this.audioContextReady}`);
        try {
          await this.startPlayback(messageId);
          console.log(`\u{1F504} Progressive Audio: Auto-playback started successfully for message ${messageId}, currentlyPlaying state updated`);
          console.log(`\u{1F504} Progressive Audio: State Details - isVoiceMode: true, isCurrentlyPlaying: ${this.currentlyPlaying.has(messageId)}, messageId: ${messageId.substring(0, 8)}`);
          this.notifyPlaybackStateChange(messageId, "auto-started");
        } catch (autoPlayError) {
          console.error(`Progressive Audio: Auto-playback failed for message ${messageId}:`, autoPlayError);
          if (!this.userGestureEstablished) {
            console.log(`\u{1F3AF} Progressive Audio: Suggesting user interaction to enable autoplay`);
          }
        }
      } else if (isFirstSentence) {
        console.log(`\u{1F504} Progressive TTS: First sentence ready for message ${messageId.substring(0, 8)}, waiting for manual play`);
        console.log(`Progressive Audio: autoPlay=${autoPlay}, sequenceIndex=${sequenceIndex}, currentlyPlaying=${this.currentlyPlaying.has(messageId)}`);
      }
    } catch (error) {
      console.error(`Progressive Audio: Error queuing sentence ${sequenceIndex} for message ${messageId}:`, error);
    }
  }
  /**
   * 🔧 IMMEDIATE STATE NOTIFICATION: Notify about playback state changes immediately
   * This helps the useTTSPlayback hook sync button states without waiting for polling
   */
  notifyPlaybackStateChange(messageId, eventType) {
    console.log(`\u{1F504} Progressive Audio: Immediate state notification - ${eventType} for message ${messageId.substring(0, 8)}`);
    if (typeof window !== "undefined") {
      const customEvent = new CustomEvent("progressiveTTSStateChange", {
        detail: {
          messageId,
          eventType,
          isPlaying: this.currentlyPlaying.has(messageId),
          timestamp: Date.now()
        }
      });
      window.dispatchEvent(customEvent);
      console.log(`\u{1F504} Progressive Audio: Dispatched state change event for message ${messageId.substring(0, 8)}: ${eventType}`);
    }
  }
  /**
   * Start playback for a message (plays the first available sentence)
   */
  async startPlayback(messageId) {
    const sequence = this.audioSequences.get(messageId);
    if (!sequence || !sequence[0]) {
      console.warn(`Progressive Audio: No first sentence available for message ${messageId}`);
      return;
    }
    try {
      if (!this.audioContextReady) {
        await this.initializeAudioContext();
      }
      this.currentlyPlaying.set(messageId, 0);
      const audio = sequence[0];
      audio.volume = 0.8;
      try {
        await audio.play();
        console.log(`\u{1F3AF} Progressive Audio: Started playback for message ${messageId} successfully`);
      } catch (playError) {
        if (playError instanceof Error && (playError.name === "NotAllowedError" || playError.message.includes("autoplay") || playError.message.includes("user activation"))) {
          console.warn(`\u{1F3AF} Progressive Audio: Autoplay blocked for message ${messageId}, showing user prompt`);
          try {
            const { Notice: Notice15 } = await import("obsidian");
            new Notice15("\u{1F50A} Click the play button to hear the AI response", 4e3);
          } catch (_noticeError) {
            console.log("\u{1F50A} Progressive Audio: Click the play button to hear the AI response");
          }
          this.currentlyPlaying.delete(messageId);
          this.pausedAt.set(messageId, 0);
          return;
        } else {
          throw playError;
        }
      }
    } catch (error) {
      console.error(`Progressive Audio: Error starting playback for message ${messageId}:`, error);
      this.currentlyPlaying.delete(messageId);
    }
  }
  /**
   * Play the next sentence in the sequence
   */
  playNextSentence(messageId) {
    const currentIndex = this.currentlyPlaying.get(messageId);
    if (currentIndex === void 0) {
      console.warn(`Progressive Audio: No current playback found for message ${messageId}`);
      return;
    }
    const nextIndex = currentIndex + 1;
    const sequence = this.audioSequences.get(messageId);
    if (sequence && sequence[nextIndex]) {
      this.currentlyPlaying.set(messageId, nextIndex);
      sequence[nextIndex].play().catch((error) => {
        console.error(`Progressive Audio: Error playing sentence ${nextIndex} for message ${messageId}:`, error);
        this.handlePlaybackComplete(messageId);
      });
      console.log(`Progressive Audio: Advanced to sentence ${nextIndex} for message ${messageId}`);
    } else {
      this.handlePlaybackComplete(messageId);
    }
  }
  /**
   * Handle completion of playback for a message
   */
  handlePlaybackComplete(messageId) {
    this.currentlyPlaying.delete(messageId);
    console.log(`Progressive Audio: Playback completed for message ${messageId}`);
    this.notifyPlaybackStateChange(messageId, "stopped");
    if (this.onPlaybackComplete && typeof this.onPlaybackComplete === "function") {
      console.log(`Progressive Audio: Invoking completion callback for message ${messageId}`);
      try {
        this.onPlaybackComplete(messageId);
      } catch (error) {
        console.warn(`Progressive Audio: Error in completion callback for message ${messageId}:`, error);
      }
    } else {
      console.log(`Progressive Audio: No completion callback set for message ${messageId}`);
    }
  }
  /**
   * Handle audio playback errors
   */
  handleAudioError(messageId, sequenceIndex, event) {
    const audio = event.target;
    const error = audio.error;
    console.error(`Progressive Audio: Playback error for sentence ${sequenceIndex} in message ${messageId}:`, error);
    this.playNextSentence(messageId);
  }
  /**
   * Stop playback for a specific message
   */
  stopPlayback(messageId) {
    const currentIndex = this.currentlyPlaying.get(messageId);
    if (currentIndex !== void 0) {
      const sequence = this.audioSequences.get(messageId);
      if (sequence && sequence[currentIndex]) {
        try {
          sequence[currentIndex].pause();
          this.pausedAt.set(messageId, currentIndex);
          console.log(`Progressive Audio: Paused at sentence ${currentIndex} for message ${messageId}`);
        } catch (error) {
          console.warn(`Progressive Audio: Error stopping playback for message ${messageId}:`, error);
        }
      }
      this.currentlyPlaying.delete(messageId);
      console.log(`Progressive Audio: Stopped playback for message ${messageId}`);
      this.notifyPlaybackStateChange(messageId, "stopped");
      const conversationManager = window.sonoriaPlugin?.conversationManager;
      if (conversationManager && conversationManager.isProcessing) {
        console.log(`Progressive Audio: Resetting conversation manager processing state after pause for message ${messageId}`);
        conversationManager.isProcessing = false;
      }
    }
  }
  /**
   * Check if a message is currently playing
   */
  isPlaying(messageId) {
    return this.currentlyPlaying.has(messageId);
  }
  /**
   * Check if a message is currently paused (has audio but not playing)
   */
  isPaused(messageId) {
    return this.pausedAt.has(messageId);
  }
  /**
   * Get the current playing sentence index for a message
   */
  getCurrentSentenceIndex(messageId) {
    return this.currentlyPlaying.get(messageId) ?? null;
  }
  /**
   * Get the total number of sentences queued for a message
   */
  getSentenceCount(messageId) {
    const sequence = this.audioSequences.get(messageId);
    return sequence ? sequence.filter((audio) => audio !== void 0).length : 0;
  }
  /**
   * Clear all audio for a specific message (cleanup)
   */
  clearMessage(messageId) {
    this.stopPlayback(messageId);
    const listeners = this.eventListeners.get(messageId);
    const sequence = this.audioSequences.get(messageId);
    if (listeners && sequence) {
      sequence.forEach((audio, index) => {
        if (audio && listeners.has(index)) {
          const audioListeners = listeners.get(index);
          if (audioListeners) {
            audio.removeEventListener("ended", audioListeners.ended);
            audio.removeEventListener("error", audioListeners.error);
            audio.removeEventListener("play", audioListeners.play);
            audio.removeEventListener("pause", audioListeners.pause);
          }
        }
      });
    }
    const urls = this.objectUrls.get(messageId);
    if (urls) {
      urls.forEach((url) => {
        if (url) {
          URL.revokeObjectURL(url);
        }
      });
    }
    this.audioSequences.delete(messageId);
    this.objectUrls.delete(messageId);
    this.eventListeners.delete(messageId);
    this.currentlyPlaying.delete(messageId);
    this.pausedAt.delete(messageId);
    console.log(`Progressive Audio: Cleared all audio for message ${messageId}`);
  }
  /**
   * Clear all messages and audio (complete cleanup)
   */
  clearAll() {
    const messageIds = Array.from(this.audioSequences.keys());
    messageIds.forEach((messageId) => this.clearMessage(messageId));
    console.log("Progressive Audio: Cleared all audio data");
  }
  /**
   * Get playback statistics
   */
  getStats() {
    const messageDetails = Array.from(this.audioSequences.keys()).map((messageId) => ({
      messageId,
      sentenceCount: this.getSentenceCount(messageId),
      currentIndex: this.getCurrentSentenceIndex(messageId)
    }));
    return {
      activePlaybacks: this.currentlyPlaying.size,
      totalMessages: this.audioSequences.size,
      totalSentences: messageDetails.reduce((sum, msg) => sum + msg.sentenceCount, 0),
      messageDetails
    };
  }
  /**
   * Check if audio is available for a specific message
   */
  hasAudioForMessage(messageId) {
    const sequence = this.audioSequences.get(messageId);
    return Boolean(sequence && sequence.length > 0 && sequence.some((audio) => audio !== void 0));
  }
  /**
   * Check if a specific message is currently playing
   */
  isPlayingMessage(messageId) {
    return this.isPlaying(messageId);
  }
  /**
   * Start playback for a specific message (public API for play/pause buttons)
   */
  async startPlaybackForMessage(messageId) {
    const sequence = this.audioSequences.get(messageId);
    if (!sequence || sequence.length === 0) {
      throw new Error(`No audio available for message ${messageId}`);
    }
    if (this.currentlyPlaying.has(messageId)) {
      console.log(`Progressive Audio: Message ${messageId} already playing, ignoring duplicate play request`);
      return;
    }
    const pausedPosition = this.pausedAt.get(messageId);
    if (pausedPosition !== void 0 && sequence[pausedPosition]) {
      console.log(`Progressive Audio: Resuming message ${messageId} from sentence ${pausedPosition}`);
      this.currentlyPlaying.set(messageId, pausedPosition);
      this.pausedAt.delete(messageId);
      try {
        await sequence[pausedPosition].play();
        console.log(`Progressive Audio: Successfully resumed playback for message ${messageId} from sentence ${pausedPosition}`);
      } catch (resumeError) {
        console.error(`Progressive Audio: Error resuming playback for message ${messageId}:`, resumeError);
        this.currentlyPlaying.delete(messageId);
        this.pausedAt.set(messageId, pausedPosition);
        throw resumeError;
      }
    } else {
      console.log(`Progressive Audio: Starting message ${messageId} from beginning`);
      await this.startPlayback(messageId);
    }
  }
  /**
   * Stop playback for a specific message (public API for play/pause buttons)
   */
  stopPlaybackForMessage(messageId) {
    this.stopPlayback(messageId);
  }
};

// src/utils/textUtils.ts
function countWords(text) {
  if (!text || typeof text !== "string") {
    return 0;
  }
  const cleanText = text.replace(/```[\s\S]*?```/g, "").replace(/`[^`]+`/g, "").replace(/^#+\s+/gm, "").replace(/(\*\*|__)(.*?)\1/g, "$2").replace(/(\*|_)(.*?)\1/g, "$2").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
  if (!cleanText) {
    return 0;
  }
  const cjkRegex = /[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff]/;
  const hasCJKText = cjkRegex.test(cleanText);
  if (hasCJKText) {
    const cjkChars = cleanText.match(/[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff]/g) || [];
    const westernWords = cleanText.replace(/[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff]/g, " ").split(/\s+/).filter((word) => word.length > 0);
    return Math.ceil(cjkChars.length / 1.5) + westernWords.length;
  } else {
    const words = cleanText.split(/\s+/).filter((word) => word.length > 0);
    return words.length;
  }
}
function truncateToWords(text, wordLimit, suffix = "...") {
  if (!text || typeof text !== "string") {
    return "";
  }
  const words = text.split(/\s+/);
  if (words.length <= wordLimit) {
    return text;
  }
  const truncated = words.slice(0, wordLimit).join(" ");
  return truncated + suffix;
}
function estimateReadingTime(text) {
  const wordCount = countWords(text);
  const wordsPerMinute = 200;
  const minutes = Math.ceil(wordCount / wordsPerMinute);
  return Math.max(1, minutes);
}
function extractTextPreview(text, maxLength = 100) {
  if (!text || typeof text !== "string") {
    return "";
  }
  const cleanText = text.replace(/```[\s\S]*?```/g, "[code block]").replace(/`[^`]+`/g, "[code]").replace(/(\*\*|__)(.*?)\1/g, "$2").replace(/(\*|_)(.*?)\1/g, "$2").replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
  if (cleanText.length <= maxLength) {
    return cleanText;
  }
  const sentences = cleanText.split(/[.!?]+/);
  if (sentences.length > 1 && sentences[0].length <= maxLength) {
    return sentences[0].trim() + ".";
  }
  const truncated = cleanText.substring(0, maxLength);
  const lastSpace = truncated.lastIndexOf(" ");
  if (lastSpace > maxLength * 0.8) {
    return truncated.substring(0, lastSpace) + "...";
  }
  return truncated + "...";
}
function removeCitationAnnotations(text) {
  if (!text || typeof text !== "string") {
    return text;
  }
  const citationPattern = /【\d+:\d+†[^】]+】/g;
  return text.replace(citationPattern, "");
}
function analyzeMessageContent(content, options = {}) {
  const {
    wordThreshold = 30,
    previewLength = 100,
    truncateWords = 25
  } = options;
  const wordCount = countWords(content);
  const shouldCollapse = wordCount > wordThreshold;
  return {
    shouldCollapse,
    wordCount,
    estimatedReadingTime: estimateReadingTime(content),
    preview: extractTextPreview(content, previewLength),
    truncatedContent: truncateToWords(content, truncateWords)
  };
}

// src/features/chat/store/conversationContext.tsx
var ConversationManager = class {
  constructor(plugin, aiClient) {
    this.conversations = [];
    this.currentConversation = null;
    this.hasActiveNote = false;
    this.messages = [];
    this.isLoading = false;
    this.error = void 0;
    this.status = "";
    this.streamingMessage = null;
    this.isStreaming = false;
    // Add streaming state
    this._events = {};
    this.currentNoteContent = null;
    this.isProcessing = false;
    this.lastSentContextKey = null;
    // For context optimization
    // Progressive TTS components
    this.streamSentenceProcessor = null;
    this.progressiveTTSQueue = null;
    this.progressiveAudioPlayback = null;
    this.progressiveTTSInitialized = false;
    // 🎯 PROGRESSIVE TTS TIMING MEASUREMENT
    this.progressiveTTSStartTime = null;
    this.firstSentenceAudioTime = null;
    // 🎯 ON-DEMAND TTS FLAG: Track when Progressive TTS is being used on-demand (user-initiated)
    this.isOnDemandTTSActive = false;
    this.onDemandExpectedSentences = 0;
    this.onDemandCompletedSentences = 0;
    this.onDemandMessageId = null;
    // 🛑 STOP GENERATION: AbortController for cancelling ongoing requests
    this.currentAbortController = null;
    makeObservable(this);
    this.plugin = plugin;
    this.aiClient = aiClient;
    this.noteContextManager = plugin.noteContextManager;
    this.storageService = new StorageService(this.plugin);
    this.noteService = plugin.noteService;
    if (this.aiClient && this.aiClient.provider !== "placeholder") {
      console.log(`ConversationManager: Using ${this.aiClient.provider} client with model ${this.aiClient.model}`);
    } else if (this.aiClient instanceof PlaceholderAIClient) {
      console.warn(`ConversationManager: Initialized with PlaceholderAIClient. Reason: ${this.aiClient.reason}`);
    } else {
      console.warn("ConversationManager: Initialized with NO AI Client (null).");
    }
    this.startConversation = this.startConversation.bind(this);
    this.sendMessage = this.sendMessage.bind(this);
    this.endConversation = this.endConversation.bind(this);
    this.generateNote = this.generateNote.bind(this);
    this.createNoteFromContent = this.createNoteFromContent.bind(this);
    this.on = this.on.bind(this);
    this.off = this.off.bind(this);
    this.emit = this.emit.bind(this);
    this.getNoteService = this.getNoteService.bind(this);
    this.setAIClient = this.setAIClient.bind(this);
    this.saveCurrentConversationToNote = this.saveCurrentConversationToNote.bind(this);
    this.addTurnToConversation = this.addTurnToConversation.bind(this);
    this.addNote = this.addNote.bind(this);
    this.removeNote = this.removeNote.bind(this);
    this.updateConversationNoteIds = this.updateConversationNoteIds.bind(this);
    console.log("ConversationManager: Initialized");
  }
  // Getter for error if UI needs it reactively
  getError() {
    return this.error;
  }
  stopGeneration() {
    if (this.currentAbortController) {
      console.log("ConversationManager.stopGeneration: Cancelling ongoing AI request");
      this.currentAbortController.abort();
      this.currentAbortController = null;
      this.isProcessing = false;
      this.isLoading = false;
      this.isStreaming = false;
      this.setStreamingMessage(null);
      this.setStatus("Generation stopped");
      this.stopProgressiveTTS();
      this.emit("update");
    } else {
      console.log("ConversationManager.stopGeneration: No ongoing request to cancel");
    }
  }
  /**
   * Stop all ongoing Progressive TTS generation and playback
   */
  stopProgressiveTTS() {
    console.log("ConversationManager.stopProgressiveTTS: Stopping TTS generation and playback");
    if (this.progressiveTTSQueue && this.streamingMessage) {
      console.log("ConversationManager.stopProgressiveTTS: Stopping TTS queue generation for streaming message");
      try {
        this.progressiveTTSQueue.clearMessage(this.streamingMessage.id);
        console.log(`ConversationManager.stopProgressiveTTS: Cleared TTS generation for streaming message ${this.streamingMessage.id}`);
      } catch (error) {
        console.warn("ConversationManager.stopProgressiveTTS: Error stopping TTS queue:", error);
      }
    }
    if (this.progressiveAudioPlayback) {
      console.log("ConversationManager.stopProgressiveTTS: Stopping audio playback");
      try {
        if (this.streamingMessage) {
          this.progressiveAudioPlayback.stopPlaybackForMessage(this.streamingMessage.id);
          console.log(`ConversationManager.stopProgressiveTTS: Stopped audio playback for streaming message ${this.streamingMessage.id}`);
        }
        const lastMessage = this.messages[this.messages.length - 1];
        if (lastMessage && lastMessage.id !== this.streamingMessage?.id) {
          this.progressiveAudioPlayback.stopPlaybackForMessage(lastMessage.id);
          console.log(`ConversationManager.stopProgressiveTTS: Stopped audio playback for last message ${lastMessage.id}`);
        }
      } catch (error) {
        console.warn("ConversationManager.stopProgressiveTTS: Error stopping audio playback:", error);
      }
    }
    if (this.isOnDemandTTSActive) {
      console.log("ConversationManager.stopProgressiveTTS: Resetting on-demand TTS state flags to prevent auto-play issues");
      this.isOnDemandTTSActive = false;
      this.onDemandExpectedSentences = 0;
      this.onDemandCompletedSentences = 0;
      this.onDemandMessageId = null;
    }
    this.isProcessing = false;
    console.log("ConversationManager.stopProgressiveTTS: Reset isProcessing flag to prevent blocking next voice interaction");
    this.progressiveTTSStartTime = null;
    this.firstSentenceAudioTime = null;
    console.log("ConversationManager.stopProgressiveTTS: TTS stopping complete, state flags reset");
  }
  // 🛑 STOP GENERATION: Check if generation can be stopped
  canStopGeneration() {
    return this.currentAbortController !== null && this.isProcessing;
  }
  // Helper to generate a key for context comparison
  _generateContextKey(notes) {
    if (!notes || notes.length === 0) return "";
    return notes.map((n) => n.path + n.stat.mtime).sort().join("|");
  }
  /**
   * Initialize progressive TTS components lazily when needed for voice conversations
   */
  ensureProgressiveTTSInitialized() {
    if (this.progressiveTTSInitialized) {
      return true;
    }
    console.log("ConversationManager.ensureProgressiveTTSInitialized: Starting lazy initialization...");
    if (!this.progressiveAudioPlayback) {
      this.progressiveAudioPlayback = new ProgressiveAudioPlayback();
      console.log("ConversationManager.ensureProgressiveTTSInitialized: ProgressiveAudioPlayback initialized");
    }
    let ttsService = null;
    const globalOpenAIService = window.sonoriaPlugin?.openAIService;
    if (globalOpenAIService && typeof globalOpenAIService.textToSpeech === "function") {
      ttsService = globalOpenAIService;
      console.log("ConversationManager.ensureProgressiveTTSInitialized: Using window.sonoriaPlugin.openAIService for TTS");
    } else if (this.plugin.openAIService && typeof this.plugin.openAIService.textToSpeech === "function") {
      ttsService = this.plugin.openAIService;
      console.log("ConversationManager.ensureProgressiveTTSInitialized: Using plugin.openAIService for TTS");
    } else {
      console.warn("ConversationManager.ensureProgressiveTTSInitialized: No TTS-capable service found");
      console.log("ConversationManager.ensureProgressiveTTSInitialized: Available services:");
      console.log(`  - window.sonoriaPlugin?.openAIService: ${!!globalOpenAIService} (textToSpeech: ${typeof globalOpenAIService?.textToSpeech})`);
      console.log(`  - this.plugin.openAIService: ${!!this.plugin.openAIService} (textToSpeech: ${typeof this.plugin.openAIService?.textToSpeech})`);
      console.log(`  - this.plugin.aiClient: ${!!this.plugin.aiClient}`);
      console.log(`  - this.aiClient: ${!!this.aiClient}`);
      if (this.plugin) {
        console.log(`  - plugin properties:`, Object.keys(this.plugin));
      }
      return false;
    }
    if (ttsService) {
      console.log("ConversationManager.ensureProgressiveTTSInitialized: Creating ProgressiveTTSQueue with TTS service...");
      this.progressiveTTSQueue = new ProgressiveTTSQueue(ttsService);
      console.log("ConversationManager.ensureProgressiveTTSInitialized: ProgressiveTTSQueue created successfully");
      this.progressiveTTSQueue.on("sentenceGenerated", (messageId, sequenceIndex, audioBlob, isFirstSentence) => {
        console.log(`\u{1F504} Progressive Audio: Queued sentence ${sequenceIndex} for message ${messageId}`);
        if (isFirstSentence && this.firstSentenceAudioTime === null) {
          this.firstSentenceAudioTime = Date.now();
          const timeToFirstAudio = this.progressiveTTSStartTime ? this.firstSentenceAudioTime - this.progressiveTTSStartTime : 0;
          console.log(`\u{1F3AF} Progressive TTS Timer: First sentence audio ready at ${this.firstSentenceAudioTime}ms`);
          console.log(`\u{1F3C6} PROGRESSIVE TTS SUCCESS: Time-to-first-audio = ${timeToFirstAudio}ms (${timeToFirstAudio / 1e3}s)`);
          if (timeToFirstAudio <= 3e3) {
            console.log(`\u{1F389} TARGET ACHIEVED: Time-to-first-audio \u22643 seconds! (${timeToFirstAudio}ms)`);
          } else {
            console.warn(`\u26A0\uFE0F TARGET MISSED: Time-to-first-audio >3 seconds (${timeToFirstAudio}ms)`);
          }
        }
        if (this.progressiveAudioPlayback) {
          const isRealTimeVoiceMode = this.isVoiceConversationMode() && !this.isOnDemandTTSActive;
          const isUserInitiatedOnDemand = this.isOnDemandTTSActive && sequenceIndex === 0;
          const shouldAutoPlay = isRealTimeVoiceMode || isUserInitiatedOnDemand;
          console.log(`\u{1F504} Progressive Audio: Queueing sentence ${sequenceIndex} for message ${messageId}`);
          console.log(`\u{1F504} Progressive Audio: autoPlay=${shouldAutoPlay} (realTimeVoice: ${isRealTimeVoiceMode}, onDemand: ${isUserInitiatedOnDemand}, sequenceIndex: ${sequenceIndex})`);
          console.log(`\u{1F504} Progressive Audio: State Details - isVoiceMode: ${this.isVoiceConversationMode()}, isOnDemandActive: ${this.isOnDemandTTSActive}, isFirstSentence: ${isFirstSentence}`);
          this.progressiveAudioPlayback.queueSentenceAudio(audioBlob, messageId, sequenceIndex, isFirstSentence, shouldAutoPlay);
          if (this.isOnDemandTTSActive && this.onDemandMessageId === messageId) {
            this.onDemandCompletedSentences++;
            console.log(`\u{1F3AF} On-Demand Progress: ${this.onDemandCompletedSentences}/${this.onDemandExpectedSentences} sentences complete for message ${messageId}`);
            if (this.onDemandCompletedSentences >= this.onDemandExpectedSentences) {
              this.isOnDemandTTSActive = false;
              this.onDemandExpectedSentences = 0;
              this.onDemandCompletedSentences = 0;
              this.onDemandMessageId = null;
              console.log(`\u{1F3AF} On-Demand TTS: All sentences complete, cleared on-demand flag for message ${messageId}`);
            }
          }
        }
      });
      this.progressiveTTSQueue.on("firstSentenceReady", (messageId, _audioBlob) => {
        console.log(`\u{1F504} Progressive TTS: First sentence ready for message ${messageId}, starting playback`);
      });
      this.progressiveTTSQueue.on("error", (messageId, error) => {
        console.error(`Progressive TTS: Error processing sentence for message ${messageId}:`, error);
      });
    } else {
      console.warn("ConversationManager.ensureProgressiveTTSInitialized: No TTS-capable service available - ProgressiveTTSQueue will not be initialized");
      return false;
    }
    if (!this.streamSentenceProcessor) {
      this.streamSentenceProcessor = new StreamSentenceProcessor((sentence, isFirst) => {
        console.log(`ConversationManager: StreamSentenceProcessor callback triggered - sentence: "${sentence}", isFirst: ${isFirst}`);
        console.log(`ConversationManager: Mode check - shouldUseProgressive: ${this.shouldUseProgressiveTTS()}, isVoiceMode: ${this.isVoiceConversationMode()}, progressiveTTSQueue exists: ${!!this.progressiveTTSQueue}, streamingMessage exists: ${!!this.streamingMessage}`);
        if (this.shouldInitializeProgressiveTTS() && this.streamingMessage && this.progressiveTTSQueue) {
          if (this.shouldProcessStreamingTTS()) {
            console.log(`ConversationManager: Calling progressiveTTSQueue.queueSentence for message ${this.streamingMessage.id} (voice mode - real-time)`);
            try {
              this.progressiveTTSQueue.queueSentence(sentence, this.streamingMessage.id, isFirst);
              console.log(`ConversationManager: Successfully queued sentence for TTS: "${sentence.substring(0, 50)}..."`);
            } catch (queueError) {
              console.error(`ConversationManager: Error queuing sentence for TTS:`, queueError);
            }
          } else {
            console.log(`ConversationManager: Skipping real-time TTS for message ${this.streamingMessage.id} (text/dictation mode - on-demand only)`);
          }
        } else {
          console.log(`ConversationManager: Skipping sentence processing - conditions not met:`);
          console.log(`  - shouldInitializeProgressive: ${this.shouldInitializeProgressiveTTS()}`);
          console.log(`  - streamingMessage: ${!!this.streamingMessage}`);
          console.log(`  - progressiveTTSQueue: ${!!this.progressiveTTSQueue}`);
          if (this.streamingMessage) {
            console.log(`  - streamingMessage.id: ${this.streamingMessage.id}`);
          }
        }
      });
      console.log("ConversationManager.ensureProgressiveTTSInitialized: StreamSentenceProcessor initialized");
    }
    this.progressiveTTSInitialized = true;
    console.log("ConversationManager: Progressive TTS components initialized lazily");
    return true;
  }
  /**
   * Check if we should initialize Progressive TTS components (for all modes with audio capability)
   */
  shouldInitializeProgressiveTTS() {
    const globalVoiceConversationMode = window.sonoriaVoiceConversationMode || false;
    const openAIAvailable = !!this.plugin.openAIService;
    const enableProgressive = globalVoiceConversationMode || openAIAvailable;
    console.log(`Progressive TTS Init Check: globalVoice=${globalVoiceConversationMode}, openAIAvailable=${openAIAvailable}, result=${enableProgressive}`);
    return enableProgressive;
  }
  /**
   * Check if we should process TTS during real-time streaming (only voice conversation mode)
   */
  shouldProcessStreamingTTS() {
    const globalVoiceConversationMode = window.sonoriaVoiceConversationMode || false;
    console.log(`Progressive TTS Streaming Check: globalVoiceConversation=${globalVoiceConversationMode}`);
    return globalVoiceConversationMode;
  }
  /**
   * Check if we should use Progressive TTS (now enabled for all modes for better UX)
   * @deprecated Use shouldInitializeProgressiveTTS() and shouldProcessStreamingTTS() instead
   */
  shouldUseProgressiveTTS() {
    return this.shouldInitializeProgressiveTTS();
  }
  /**
   * Check if we're currently in active voice conversation mode (for real-time streaming)
   */
  isVoiceConversationMode() {
    const globalVoiceConversationMode = window.sonoriaVoiceConversationMode || false;
    console.log(`Voice Conversation Mode Check: globalVoiceConversation=${globalVoiceConversationMode}`);
    return globalVoiceConversationMode;
  }
  /**
   * Clean up progressive TTS components
   */
  cleanupProgressiveTTS() {
    if (this.progressiveAudioPlayback) {
      this.progressiveAudioPlayback.clearAll();
    }
    if (this.progressiveTTSQueue) {
      this.progressiveTTSQueue.clear();
    }
    if (this.streamSentenceProcessor) {
      this.streamSentenceProcessor.reset();
    }
    console.log("ConversationManager: Progressive TTS components cleaned up");
  }
  setAIClient(client) {
    if (client) {
      console.log(`ConversationManager: Setting AI client - Provider: ${client.provider}, Model: ${client.model}`);
      this.aiClient = client;
    } else {
      console.warn("ConversationManager: Setting AI client to null");
      this.aiClient = null;
    }
  }
  getAIClient() {
    return this.aiClient;
  }
  async addTurnToConversation(_userMessage, aiMessage, newApiResponseId, shouldUseTTS) {
    if (!this.currentConversation) {
      console.error("ConversationManager: No active conversation to add a turn to.");
      return;
    }
    if (newApiResponseId) {
      this.currentConversation.previous_response_id = newApiResponseId;
    }
    const now = /* @__PURE__ */ new Date();
    const assistantMsg = {
      id: nanoid(),
      role: "assistant",
      content: aiMessage,
      timestamp: now.getTime(),
      // Keep as number
      conversationId: this.currentConversation.id
    };
    this.currentConversation.messages.push(assistantMsg);
    this.currentConversation.lastModified = now.toISOString();
    this.messages = [...this.currentConversation.messages];
    try {
      await this.storageService.updateConversation(this.currentConversation);
      console.log("ConversationManager: Turn added to conversation and stored.");
    } catch (error) {
      console.error("ConversationManager: Failed to save conversation turn to storage", error);
    }
    if (shouldUseTTS) {
      await this.handleTextToSpeech(aiMessage);
    }
    this.emit("update");
  }
  updateSettings() {
    try {
      console.log("ConversationManager: Updating settings (settings object on plugin has changed)");
      console.log("ConversationManager: Settings considered (AI Client managed externally).");
    } catch (error) {
      console.error("ConversationManager: Error reacting to settings update", error);
    }
  }
  on(eventName, listener) {
    if (!this._events[eventName]) {
      this._events[eventName] = [];
    }
    this._events[eventName].push(listener);
    return () => this.off(eventName, listener);
  }
  off(eventName, listenerToRemove) {
    if (!this._events[eventName]) return;
    this._events[eventName] = this._events[eventName].filter((listener) => listener !== listenerToRemove);
  }
  emit(eventName, ...args) {
    if (!this._events[eventName]) return;
    this._events[eventName].forEach((listener) => {
      setTimeout(() => listener(...args), 0);
    });
  }
  setCurrentConversation(conversation) {
    console.log("Setting current conversation:", conversation ? conversation.id : "null");
    this.currentConversation = conversation;
    this.messages = conversation ? [...conversation.messages] : [];
    if (conversation && conversation.noteIds && conversation.noteIds.length > 0) {
      const primaryId = conversation.primaryNoteId || conversation.noteIds[0];
      const primaryFile = primaryId ? this.plugin.app.vault.getAbstractFileByPath(primaryId) : null;
      this.hasActiveNote = !!primaryFile;
    } else {
      this.hasActiveNote = false;
      this.currentNoteContent = null;
    }
    this.lastSentContextKey = null;
    this.emit("update");
  }
  async startConversation(primaryNoteId, _noteContent, additionalNoteIdsParam = []) {
    console.time("CM_startConversation_Total");
    let cmTotalContextPrepLabel = "CM_TotalContextPrep_StartConversation";
    try {
      if (this.isLoading) {
        console.log("ConversationManager.startConversation: Already loading/starting a conversation, ignoring request");
        return;
      }
      console.log(`ConversationManager.startConversation: Initiated. PrimaryNoteID: ${primaryNoteId}, AdditionalNoteIDs: ${additionalNoteIdsParam.join(", ")}`);
      if (!primaryNoteId) throw new Error("Note ID is required to start a new conversation");
      this.isLoading = true;
      this.error = void 0;
      this.setStatus("Starting new conversation...");
      this.emit("update");
      console.log(`ConversationManager.startConversation: Old lastSentContextKey: ${this.lastSentContextKey}`);
      this.setCurrentConversation(null);
      this.messages = [];
      this.currentNoteContent = null;
      const allInitialNoteIds = [primaryNoteId, ...additionalNoteIdsParam].filter((id) => !!id);
      console.log(`ConversationManager.startConversation: Constructing initial note list for new conversation: ${allInitialNoteIds.join(", ")}`);
      const contextNotes = {};
      const activeTFiles = [];
      if (this.currentConversation) {
        cmTotalContextPrepLabel = `CM_TotalContextPrep_StartConversation_${this.currentConversation.id}`;
      }
      console.time(cmTotalContextPrepLabel);
      for (const noteId of allInitialNoteIds) {
        console.log(`ConversationManager.startConversation: Processing noteId: "${noteId}"`);
        const file = this.plugin.app.vault.getAbstractFileByPath(noteId);
        const isTFileCompatible = file && "path" in file && typeof file.path === "string" && "basename" in file && typeof file.basename === "string" && "name" in file && typeof file.name === "string" && "stat" in file && file.stat && typeof file.stat.mtime === "number";
        console.log(`ConversationManager.startConversation: File object for "${noteId}":`, file ? isTFileCompatible ? `TFile-like with basename: ${file.basename}` : `Not TFile-like` : String(file));
        if (isTFileCompatible) {
          const tFile = file;
          activeTFiles.push(tFile);
          contextNotes[noteId] = { title: tFile.basename, included: true };
        } else {
          console.warn(`ConversationManager.startConversation: Note ID ${noteId} not found or not a TFile-compatible object.`);
        }
      }
      console.log(`ConversationManager.startConversation: Active TFiles for initial context: ${activeTFiles.map((f) => f.path).join(", ")}`);
      const newConversationId = v4_default();
      let newVectorStoreId = null;
      const newFileIdMap = {};
      if (this.plugin.openAIService && this.plugin.openAIService.isAssistantConfigured()) {
        console.log(`ConversationManager.startConversation: Attempting to create new vector store for conversation ${newConversationId}`);
        const createVsLabel = this.currentConversation ? `CM_OpenAIService_createVectorStore_${this.currentConversation.id}` : "CM_OpenAIService_createVectorStore";
        console.time(createVsLabel);
        newVectorStoreId = await this.plugin.openAIService.createVectorStore(`NoteChat Session ${newConversationId}`);
        console.timeEnd(createVsLabel);
        console.log(`ConversationManager.startConversation: Created Vector Store ID: ${newVectorStoreId} for conversation ${newConversationId}`);
        if (newVectorStoreId) {
          for (const tFile of activeTFiles) {
            try {
              const fileReadLabel = `CM_FileRead_${tFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
              console.time(fileReadLabel);
              const content = await this.plugin.app.vault.cachedRead(tFile);
              console.timeEnd(fileReadLabel);
              console.log(`ConversationManager.startConversation: Uploading note ${tFile.path} to Vector Store ${newVectorStoreId}`);
              const uploadLabel = `CM_OpenAIService_uploadNoteAsFile_${tFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
              console.time(uploadLabel);
              const fileId = await this.plugin.openAIService.getOrUploadFile(content, tFile.name);
              console.timeEnd(uploadLabel);
              if (fileId) {
                console.log(`ConversationManager.startConversation: Uploaded note ${tFile.path} as File ID: ${fileId}`);
                const addFileToVsLabel = `CM_OpenAIService_addFileToVectorStore_${tFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
                console.time(addFileToVsLabel);
                await this.plugin.openAIService.addFileToVectorStore(newVectorStoreId, fileId);
                console.timeEnd(addFileToVsLabel);
                newFileIdMap[tFile.path] = fileId;
              } else {
                console.error(`ConversationManager.startConversation: Failed to upload note ${tFile.path} to vector store.`);
              }
            } catch (err) {
              console.error(`ConversationManager.startConversation: Error processing file ${tFile.path} for vector store:`, err);
            }
          }
        }
      } else {
        console.warn("ConversationManager.startConversation: OpenAIService not available or not configured for vector store creation.");
      }
      const newConversation = {
        id: newConversationId,
        noteIds: allInitialNoteIds,
        primaryNoteId,
        title: `Chat about ${allInitialNoteIds.length > 1 ? "multiple notes" : activeTFiles[0]?.basename || "note"}`,
        creationDate: (/* @__PURE__ */ new Date()).toISOString(),
        lastModified: (/* @__PURE__ */ new Date()).toISOString(),
        messages: [...this.messages],
        isArchived: false,
        previous_response_id: null,
        vectorStoreId: newVectorStoreId,
        uploadedFileIds: newFileIdMap,
        contextNotes
      };
      this.conversations.push(newConversation);
      await this.storageService.updateConversation(newConversation);
      this.setCurrentConversation(newConversation);
      this.lastSentContextKey = this._generateContextKey(activeTFiles);
      console.log(`ConversationManager.startConversation: New lastSentContextKey: ${this.lastSentContextKey}`);
      console.timeEnd(cmTotalContextPrepLabel);
      this.isLoading = false;
      this.setStatus("Conversation started.");
    } catch (err) {
      const specificErrorMessage = err instanceof Error ? err.message : String(err);
      const errorMessage = `Failed to start conversation: ${specificErrorMessage}`;
      this.error = errorMessage;
      console.error("ConversationManager: Failed to start conversation:", err);
      this.setStatus("Error starting conversation");
      console.timeEnd(cmTotalContextPrepLabel);
      throw new Error(errorMessage);
    } finally {
      this.isProcessing = false;
      this.emit("update");
      console.timeEnd("CM_startConversation_Total");
    }
  }
  async startGeneralChatConversation() {
    console.time("CM_startGeneralChatConversation_Total");
    try {
      if (this.isLoading) {
        console.log("ConversationManager.startGeneralChatConversation: Already loading/starting a conversation, ignoring request");
        return;
      }
      console.log("ConversationManager.startGeneralChatConversation: Initiated for general chat without notes");
      this.isLoading = true;
      this.error = void 0;
      this.setStatus("Starting general chat conversation...");
      this.emit("update");
      this.setCurrentConversation(null);
      this.messages = [];
      this.currentNoteContent = null;
      const newConversationId = v4_default();
      let newVectorStoreId = null;
      if (this.plugin.openAIService && this.plugin.openAIService.isAssistantConfigured()) {
        console.log(`ConversationManager.startGeneralChatConversation: Creating vector store for conversation ${newConversationId}`);
        newVectorStoreId = await this.plugin.openAIService.createVectorStore(`Sonoria General Chat ${newConversationId}`);
        console.log(`ConversationManager.startGeneralChatConversation: Created Vector Store ID: ${newVectorStoreId} for conversation ${newConversationId}`);
      } else {
        console.warn("ConversationManager.startGeneralChatConversation: OpenAIService not available or not configured for vector store creation.");
      }
      const newConversation = {
        id: newConversationId,
        noteIds: [],
        // Empty for general chat
        primaryNoteId: void 0,
        // No primary note for general chat
        title: `General Chat`,
        creationDate: (/* @__PURE__ */ new Date()).toISOString(),
        lastModified: (/* @__PURE__ */ new Date()).toISOString(),
        messages: [...this.messages],
        isArchived: false,
        previous_response_id: null,
        vectorStoreId: newVectorStoreId,
        uploadedFileIds: {},
        // Empty for general chat
        contextNotes: {}
        // Empty for general chat
      };
      this.conversations.push(newConversation);
      await this.storageService.updateConversation(newConversation);
      this.setCurrentConversation(newConversation);
      this.lastSentContextKey = null;
      console.log(`ConversationManager.startGeneralChatConversation: Created general chat conversation`);
      this.isLoading = false;
      this.setStatus("General chat conversation started.");
    } catch (err) {
      const specificErrorMessage = err instanceof Error ? err.message : String(err);
      const errorMessage = `Failed to start general chat conversation: ${specificErrorMessage}`;
      this.error = errorMessage;
      console.error("ConversationManager: Failed to start general chat conversation:", err);
      this.setStatus("Error starting conversation");
      throw new Error(errorMessage);
    } finally {
      this.isProcessing = false;
      this.emit("update");
      console.timeEnd("CM_startGeneralChatConversation_Total");
    }
  }
  async sendMessage(userInput) {
    console.time("CM_sendMessage_Total");
    let cmTotalContextPrepLabel = "CM_TotalContextPrep_SendMessage";
    let currentConvo = this.currentConversation;
    try {
      if (this.isProcessing) {
        console.warn("ConversationManager.sendMessage: Already processing a message, ignoring request.");
        new import_obsidian3.Notice("Please wait for the current response to complete.");
        return;
      }
      console.log(`ConversationManager.sendMessage: Initiated with user input: "${userInput.substring(0, 50)}..."`);
      if (!currentConvo) {
        console.warn("ConversationManager: No active conversation. Creating a general chat conversation for this message.");
        try {
          await this.startGeneralChatConversation();
          currentConvo = this.currentConversation;
          if (!currentConvo) throw new Error("Failed to initialize a new conversation for sending message.");
        } catch (startError) {
          console.error("ConversationManager: Error auto-starting conversation in sendMessage:", startError);
          this.setStatus("Error");
          this.error = "Failed to start a conversation to send message.";
          this.emit("update");
          console.timeEnd("CM_sendMessage_Total");
          return;
        }
      }
      this.isProcessing = true;
      this.isLoading = true;
      this.error = void 0;
      this.setStatus("");
      this.currentAbortController = new AbortController();
      this.emit("update");
      const userMessageObj = {
        id: nanoid(),
        role: "user",
        content: userInput,
        timestamp: Date.now(),
        conversationId: currentConvo.id
      };
      currentConvo.messages.push(userMessageObj);
      this.messages = [...currentConvo.messages];
      this.emit("update");
      if (!currentConvo) {
        throw new Error("Current conversation is null after attempting to initialize for sendMessage.");
      }
      if (this.currentConversation) {
        cmTotalContextPrepLabel = `CM_TotalContextPrep_SendMessage_${this.currentConversation.id}`;
      }
      console.time(cmTotalContextPrepLabel);
      try {
        if (!this.plugin.openAIService) throw new Error("OpenAIService not available.");
        const currentActiveNotes = this.getActiveNotes();
        const currentContextKey = this._generateContextKey(currentActiveNotes);
        console.log(`ConversationManager.sendMessage: Old lastSentContextKey: ${this.lastSentContextKey}, Current contextKey: ${currentContextKey}, Current VS ID: ${currentConvo.vectorStoreId}`);
        if (this.shouldInitializeProgressiveTTS()) {
          console.log("ConversationManager.sendMessage: Ensuring Progressive TTS is initialized before streaming begins");
          const initSuccess = this.ensureProgressiveTTSInitialized();
          if (!initSuccess) {
            console.warn("ConversationManager.sendMessage: Progressive TTS initialization failed - voice mode features may not work");
          } else {
            console.log("ConversationManager.sendMessage: Progressive TTS initialization successful");
          }
        }
        let currentVectorStoreId = currentConvo.vectorStoreId ?? null;
        let responseId = null;
        let responseText = null;
        let error = null;
        if (this.plugin.openAIService && this.plugin.openAIService.isAssistantConfigured()) {
          console.log(`ConversationManager.sendMessage: (this)lastSentContextKey: ${this.lastSentContextKey}, Current contextKey: ${currentContextKey}, CurrentConvo VS ID: ${currentConvo.vectorStoreId}`);
          if (currentContextKey !== this.lastSentContextKey || !currentConvo.vectorStoreId) {
            console.log(`ConversationManager.sendMessage: Context changed or no vector store. Old VS ID: ${currentConvo.vectorStoreId}. Creating new vector store.`);
            console.time("CM_NetworkOperations_VectorStoreSetup");
            if (currentConvo.vectorStoreId) {
              const oldVsId = currentConvo.vectorStoreId;
              const oldFileMap = currentConvo.uploadedFileIds ? { ...currentConvo.uploadedFileIds } : {};
              console.log(`ConversationManager.sendMessage: Deleting old Vector Store ID: ${oldVsId} and its files.`);
              console.time("CM_DeleteOldVectorStore");
              const vsDeleted = await this.plugin.openAIService.deleteVectorStore(oldVsId);
              console.timeEnd("CM_DeleteOldVectorStore");
              if (vsDeleted) {
                console.time("CM_DeleteOldFiles");
                const deletePromises = Object.values(oldFileMap).map((fileId) => {
                  return this.plugin.openAIService?.deleteUploadedFile(fileId);
                });
                await Promise.all(deletePromises);
                console.timeEnd("CM_DeleteOldFiles");
                console.log(`ConversationManager.sendMessage: Finished deleting files for old VS ID: ${oldVsId}.`);
              } else {
                console.warn(`ConversationManager.sendMessage: Failed to delete old VS ID: ${oldVsId}. Files may remain.`);
              }
              currentConvo.uploadedFileIds = {};
            }
            const createVsLabel = currentConvo ? `CM_OpenAIService_createVectorStore_${currentConvo.id}` : "CM_OpenAIService_createVectorStore";
            console.time(createVsLabel);
            currentVectorStoreId = await this.plugin.openAIService.createVectorStore(`NoteChat Session ${currentConvo.id} - Context Update`);
            console.timeEnd(createVsLabel);
            console.log(`ConversationManager.sendMessage: Created new Vector Store ID: ${currentVectorStoreId}`);
            currentConvo.vectorStoreId = currentVectorStoreId;
            if (!currentConvo.uploadedFileIds) {
              currentConvo.uploadedFileIds = {};
            }
            if (currentVectorStoreId) {
              console.time("CM_FileUploadAndIndexing_Loop");
              const fileProcessingPromises = [];
              for (const tFile of currentActiveNotes) {
                const filePromise = (async () => {
                  try {
                    const fileReadSendMessageLabel = `CM_FileRead_${tFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
                    console.time(fileReadSendMessageLabel);
                    const content = await this.plugin.app.vault.cachedRead(tFile);
                    console.timeEnd(fileReadSendMessageLabel);
                    console.log(`ConversationManager.sendMessage: Uploading note ${tFile.path} to new Vector Store ${currentVectorStoreId}`);
                    const uploadSendMessageLabel = `CM_OpenAIService_uploadNoteAsFile_${tFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
                    console.time(uploadSendMessageLabel);
                    const fileId = await this.plugin.openAIService.getOrUploadFile(content, tFile.name);
                    console.timeEnd(uploadSendMessageLabel);
                    if (fileId) {
                      console.log(`ConversationManager.sendMessage: Uploaded note ${tFile.path} as File ID: ${fileId}. Attempting to add to VS ${currentVectorStoreId}.`);
                      const addFileToVsSendMessageLabel = `CM_OpenAIService_addFileToVectorStore_${tFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
                      console.time(addFileToVsSendMessageLabel);
                      const addedAndIndexed = await this.plugin.openAIService.addFileToVectorStore(currentVectorStoreId, fileId);
                      console.timeEnd(addFileToVsSendMessageLabel);
                      if (addedAndIndexed) {
                        console.log(`ConversationManager.sendMessage: Successfully added and indexed File ID ${fileId} (${tFile.name}) to VS ${currentVectorStoreId}.`);
                        if (!currentConvo.uploadedFileIds) {
                          currentConvo.uploadedFileIds = {};
                        }
                        currentConvo.uploadedFileIds[tFile.path] = fileId;
                      } else {
                        console.warn(`ConversationManager.sendMessage: File ID ${fileId} (${tFile.name}) was NOT successfully indexed in VS ${currentVectorStoreId}. File Search may not work for this file.`);
                        if (!currentConvo.uploadedFileIds) {
                          currentConvo.uploadedFileIds = {};
                        }
                        currentConvo.uploadedFileIds[tFile.path] = fileId;
                      }
                    } else {
                      console.error(`ConversationManager.sendMessage: Failed to upload note ${tFile.path} to new vector store. Cannot add to VS.`);
                    }
                  } catch (err) {
                    console.error(`ConversationManager.sendMessage: Error processing file ${tFile.path} for new vector store:`, err);
                  }
                })();
                fileProcessingPromises.push(filePromise);
              }
              await Promise.all(fileProcessingPromises);
              console.timeEnd("CM_FileUploadAndIndexing_Loop");
            }
            console.timeEnd("CM_NetworkOperations_VectorStoreSetup");
            this.lastSentContextKey = currentContextKey;
            await this.storageService.updateConversation(currentConvo);
            console.log(`ConversationManager.sendMessage: Updated lastSentContextKey: ${this.lastSentContextKey} and saved conversation.`);
          } else {
            console.log(`ConversationManager.sendMessage: Context unchanged. Using existing Vector Store ID: ${currentConvo.vectorStoreId}`);
            currentVectorStoreId = currentConvo.vectorStoreId;
          }
        } else {
          console.warn("ConversationManager.sendMessage: OpenAIService not available or not configured for vector store operations.");
        }
        console.timeEnd(cmTotalContextPrepLabel);
        this.setStatus("Waiting for AI response...");
        const getResponseLabel = "OpenAIService_getAssistantResponse_FullCall";
        let timerStarted = false;
        const openAIServiceExists = !!this.plugin.openAIService;
        const isConfigured = openAIServiceExists && this.plugin.openAIService.isAssistantConfigured();
        console.log(`ConversationManager.sendMessage: Pre-API call. userInput: "${userInput}", prevRespId: ${currentConvo.previous_response_id}, vsId: ${currentVectorStoreId}, openAIServiceExists: ${openAIServiceExists}, isConfigured: ${isConfigured}`);
        if (this.plugin.openAIService && isConfigured) {
          console.time(getResponseLabel);
          timerStarted = true;
          const onChunk = (textChunk, isFinalChunk, _responseId, error2) => {
            if (error2) {
              console.error("ConversationManager.sendMessage: Streaming error:", error2);
              runInAction(() => {
                this.setStreamingMessage(null);
              });
              return;
            }
            if (textChunk && !this.streamingMessage && currentConvo) {
              const streamingMessageId = nanoid();
              const initialStreamingMessage = {
                id: streamingMessageId,
                role: "assistant",
                content: "",
                timestamp: Date.now(),
                conversationId: currentConvo.id
              };
              this.setStreamingMessage(initialStreamingMessage);
            }
            if (textChunk && this.streamingMessage) {
              if (this.isVoiceConversationMode() && this.progressiveTTSStartTime === null) {
                this.progressiveTTSStartTime = Date.now();
                console.log(`\u{1F50A} Progressive TTS Timer: AI streaming started at ${this.progressiveTTSStartTime}ms`);
              }
              runInAction(() => {
                if (this.streamingMessage) {
                  const currentContent = this.streamingMessage.content || "";
                  this.streamingMessage.content = currentContent + textChunk;
                  this.emit("update");
                }
              });
              console.log(`Progressive TTS Debug: streamSentenceProcessor exists: ${!!this.streamSentenceProcessor}, shouldInitialize: ${this.shouldInitializeProgressiveTTS()}, shouldProcessStreaming: ${this.shouldProcessStreamingTTS()}`);
              console.log(`Progressive TTS Debug: globalVoiceMode: ${window.sonoriaVoiceConversationMode}, streamingMessage: ${!!this.streamingMessage}, progressiveTTSQueue: ${!!this.progressiveTTSQueue}`);
              if (this.shouldInitializeProgressiveTTS()) {
                if (this.ensureProgressiveTTSInitialized() && this.streamSentenceProcessor) {
                  if (this.shouldProcessStreamingTTS()) {
                    console.log(`Progressive TTS: Processing text chunk for real-time sentence extraction (voice mode) - chunk: "${textChunk}"`);
                    try {
                      this.streamSentenceProcessor.processTextChunk(textChunk);
                      console.log(`Progressive TTS: Successfully processed text chunk in voice mode`);
                    } catch (processingError) {
                      console.warn("Progressive TTS: Error processing text chunk in voice mode:", processingError);
                    }
                  } else {
                    console.log("Progressive TTS: Skipping real-time processing (text/dictation mode - cost optimization)");
                  }
                } else {
                  console.error("Progressive TTS: Initialization failed or no sentence processor available");
                  console.log(`Progressive TTS Debug: ensureInitialized result: ${this.ensureProgressiveTTSInitialized()}, streamSentenceProcessor: ${!!this.streamSentenceProcessor}, progressiveTTSQueue: ${!!this.progressiveTTSQueue}`);
                }
              } else {
                console.log("Progressive TTS: Skipping processing - not enabled for current mode");
              }
            }
            if (isFinalChunk) {
              console.log("ConversationManager.sendMessage: Streaming completed");
              if (this.shouldInitializeProgressiveTTS()) {
                if (this.ensureProgressiveTTSInitialized() && this.streamSentenceProcessor) {
                  if (this.shouldProcessStreamingTTS()) {
                    console.log("Progressive TTS: Finalizing sentence processing (voice mode)");
                    try {
                      this.streamSentenceProcessor.finalize();
                      this.streamSentenceProcessor.reset();
                      setTimeout(() => {
                        console.log("\u{1F504} Progressive TTS: Resetting timing measurements for next interaction");
                        this.progressiveTTSStartTime = null;
                        this.firstSentenceAudioTime = null;
                      }, 1e3);
                    } catch (processingError) {
                      console.warn("Progressive TTS: Error finalizing sentence processing in voice mode:", processingError);
                    }
                  } else {
                    console.log("Progressive TTS: Resetting processor without processing (text/dictation mode)");
                    this.streamSentenceProcessor.reset();
                  }
                } else {
                  console.log("Progressive TTS: Finalization skipped - initialization failed or no sentence processor");
                }
              }
            }
          };
          const apiResponse = await this.plugin.openAIService.getAssistantResponse(
            userInput,
            currentVectorStoreId,
            onChunk,
            this.currentAbortController?.signal
          );
          responseId = apiResponse.responseId;
          responseText = apiResponse.responseText;
          error = apiResponse.error;
        } else {
          throw new Error("OpenAIService not available or not configured for API call.");
        }
        if (timerStarted) {
          console.timeEnd(getResponseLabel);
        }
        if (error || !responseText) {
          this.setStreamingMessage(null);
          runInAction(() => {
            this.isLoading = false;
          });
          throw new Error(error || "AI response was empty or failed.");
        }
        if (responseText && !error) {
          if (this.streamingMessage && this.currentConversation) {
            const completedMessage = {
              id: this.streamingMessage.id,
              // Keep the same ID for consistency
              role: this.streamingMessage.role,
              content: this.streamingMessage.content,
              timestamp: this.streamingMessage.timestamp,
              conversationId: this.streamingMessage.conversationId
            };
            this.setStreamingMessage(null);
            runInAction(() => {
              this.isLoading = false;
              if (this.currentConversation) {
                this.currentConversation.messages.push(completedMessage);
                this.messages = [...this.currentConversation.messages];
              }
            });
            this.emit("update");
          }
          if (responseId) {
            currentConvo.previous_response_id = responseId;
          }
          currentConvo.lastModified = (/* @__PURE__ */ new Date()).toISOString();
          await this.storageService.updateConversation(currentConvo);
          this.setStatus("Ready");
        } else {
          this.setStreamingMessage(null);
          runInAction(() => {
            this.isLoading = false;
          });
          throw new Error(error || "AI response was empty or failed.");
        }
        console.log("ConversationManager: Message exchange completed successfully using Assistants API.");
      } catch (error) {
        console.error("ConversationManager: Error during context preparation or AI call within sendMessage:", error);
        if (currentConvo) {
          const errorMessage2 = error instanceof Error ? error.message : String(error);
          currentConvo.error = errorMessage2 || "Error during message processing.";
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.error = errorMessage || "Failed to get AI response.";
        this.setStatus("Error");
        throw error;
      }
    } catch (error) {
      console.error("ConversationManager: Error sending message via OpenAIService:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.error = errorMessage || "Failed to get AI response.";
      if (currentConvo) {
        currentConvo.error = this.error;
        const isUserCancellation = this.error.includes("cancelled by user") || this.error.includes("cancelled before starting");
        const systemErrorMessage = {
          id: nanoid(),
          role: "system",
          content: isUserCancellation ? this.error : `Error: ${this.error}`,
          timestamp: Date.now(),
          conversationId: currentConvo.id
        };
        currentConvo.messages.push(systemErrorMessage);
        this.messages = [...currentConvo.messages];
        this.storageService.updateConversation(currentConvo).catch((e) => console.error("Failed to save system error message", e));
      }
      this.setStatus("Error");
      console.timeEnd(cmTotalContextPrepLabel);
    } finally {
      if (this.currentAbortController && !this.currentAbortController.signal.aborted) {
        this.currentAbortController = null;
        runInAction(() => {
          this.isProcessing = false;
        });
      } else if (this.currentAbortController && this.currentAbortController.signal.aborted) {
      } else {
        runInAction(() => {
          this.isLoading = false;
          this.isProcessing = false;
        });
      }
      this.emit("update");
      console.timeEnd("CM_sendMessage_Total");
    }
  }
  // Method to get active notes. Ensure currentConversation is checked.
  getActiveNotes() {
    if (this.currentConversation && this.currentConversation.noteIds) {
      return this.currentConversation.noteIds.map((noteId) => this.plugin.app.vault.getAbstractFileByPath(noteId)).filter((file) => file instanceof import_obsidian3.TFile && !!file);
    }
    return [];
  }
  async endConversation() {
    console.log("ConversationManager.endConversation: Initiated.");
    if (this.isLoading) {
      console.warn("ConversationManager.endConversation: Currently loading, cannot end conversation yet.");
      return;
    }
    if (!this.currentConversation) {
      console.log("ConversationManager.endConversation: No active conversation to end.");
      return;
    }
    this.isLoading = true;
    this.status = "Ending conversation...";
    this.emit("update");
    const conversationToEnd = { ...this.currentConversation };
    try {
      if (conversationToEnd.vectorStoreId && this.plugin.openAIService) {
        console.log(`ConversationManager.endConversation: Attempting to delete Vector Store ID: ${conversationToEnd.vectorStoreId}`);
        const vsDeleted = await this.plugin.openAIService.deleteVectorStore(conversationToEnd.vectorStoreId);
        if (vsDeleted) {
          console.log(`ConversationManager.endConversation: Successfully deleted Vector Store ID: ${conversationToEnd.vectorStoreId}`);
          if (conversationToEnd.uploadedFileIds) {
            console.log(`ConversationManager.endConversation: Deleting associated uploaded files for VS ${conversationToEnd.vectorStoreId}`);
            for (const fileId of Object.values(conversationToEnd.uploadedFileIds)) {
              if (fileId) {
                console.log(`ConversationManager.endConversation: Attempting to delete uploaded File ID: ${fileId}`);
                const fileDeleted = await this.plugin.openAIService.deleteUploadedFile(fileId);
                if (fileDeleted) {
                  console.log(`ConversationManager.endConversation: Successfully deleted uploaded File ID: ${fileId}`);
                } else {
                  console.warn(`ConversationManager.endConversation: Failed to delete uploaded File ID: ${fileId}`);
                }
              }
            }
            console.log(`ConversationManager.endConversation: Finished attempting to delete associated uploaded files for VS ${conversationToEnd.vectorStoreId}`);
          }
        } else {
          console.warn(`ConversationManager.endConversation: Failed to delete Vector Store ID: ${conversationToEnd.vectorStoreId}`);
        }
      } else if (this.plugin.openAIService) {
        if (conversationToEnd.uploadedFileIds) {
          console.log(`ConversationManager.endConversation: No Vector Store ID for conversation ${conversationToEnd.id}, but found uploadedFileIds. Attempting to delete orphaned files.`);
          for (const fileId of Object.values(conversationToEnd.uploadedFileIds)) {
            if (fileId) {
              console.log(`ConversationManager.endConversation: Attempting to delete (potentially orphaned) uploaded File ID: ${fileId}`);
              await this.plugin.openAIService.deleteUploadedFile(fileId);
            }
          }
        }
      }
      await this.storageService.deleteConversation(conversationToEnd.id);
      console.log(`ConversationManager.endConversation: Conversation ${conversationToEnd.id} deleted from storage.`);
    } catch (error) {
      console.error("ConversationManager.endConversation: Error during cleanup or storage deletion:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.error = `Failed to end conversation: ${errorMessage}`;
      this.status = "Error ending conversation";
    } finally {
      this.setCurrentConversation(null);
      this.messages = [];
      this.isLoading = false;
      this.status = "Conversation ended";
      this.lastSentContextKey = null;
      this.cleanupProgressiveTTS();
      this.emit("update");
      console.log("ConversationManager.endConversation: Completed.");
    }
  }
  async generateNote() {
    let conversationToProcess = this.currentConversation;
    if (!conversationToProcess) {
      if (this.messages.length > 0) {
        const tempId = "temp-note-gen-" + v4_default();
        const tempTitle = `Generated Note from Session ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
        const isoNow = (/* @__PURE__ */ new Date()).toISOString();
        conversationToProcess = {
          id: tempId,
          noteIds: this.getActiveNotes().map((f) => f.path),
          // Try to get active notes if any
          title: tempTitle,
          creationDate: isoNow,
          lastModified: isoNow,
          messages: [...this.messages],
          // Use current messages
          isArchived: false,
          // Not archived
          previous_response_id: null,
          // No response chain for this temp object
          vectorStoreId: null,
          // No vector store for this temp object
          activeNoteIds: this.getActiveNotes().map((f) => f.path),
          // from type
          error: void 0
          // from type
        };
      } else {
        this.error = "No messages in current session to generate a note from.";
        this.setStatus("No content for note");
        this.emit("update");
        throw new Error("No messages to generate a note from.");
      }
    }
    try {
      if (!this.aiClient || this.aiClient.provider === "placeholder") {
        throw new Error("AI client is not configured for note generation.");
      }
      this.isLoading = true;
      this.error = void 0;
      this.setStatus("Generating note...");
      this.emit("update");
      let noteContextForGeneration = this.currentNoteContent || "";
      if (!noteContextForGeneration && conversationToProcess.noteIds && conversationToProcess.noteIds.length > 0) {
        const { primaryNoteContent: contextPrimary, additionalContext: contextAdditional } = await this.noteContextManager.getMultiNoteContext(
          conversationToProcess.primaryNoteId || conversationToProcess.noteIds[0],
          conversationToProcess.noteIds.slice(1)
        );
        noteContextForGeneration = `${contextPrimary || ""}
${contextAdditional || ""}`.trim();
      }
      const structuredNote = await this.aiClient.generateStructuredNote(
        conversationToProcess.messages,
        noteContextForGeneration
      );
      this.setStatus("Note generated");
      return structuredNote;
    } catch (err) {
      const specificErrorMessage = err instanceof Error ? err.message : String(err);
      this.error = `Failed to generate note: ${specificErrorMessage}`;
      console.error("Failed to generate note:", err);
      this.setStatus("Error generating note");
      throw err;
    } finally {
      this.isLoading = false;
      this.isProcessing = false;
      this.emit("update");
    }
  }
  updateConversationNoteIds(noteIds) {
    if (!this.currentConversation) {
      console.warn("ConversationManager: No active conversation to update note IDs for.");
      return;
    }
    console.log(`ConversationManager: Updating note IDs for conversation ${this.currentConversation.id} with:`, noteIds);
    this.currentConversation.noteIds = [...noteIds];
    if (noteIds.length > 0 && !noteIds.includes(this.currentConversation.primaryNoteId || "")) {
      this.currentConversation.primaryNoteId = noteIds[0];
    } else if (noteIds.length === 0) {
      this.currentConversation.primaryNoteId = void 0;
    }
    this.currentConversation.lastModified = (/* @__PURE__ */ new Date()).toISOString();
    this.lastSentContextKey = null;
    this.setCurrentConversation(this.currentConversation);
    this.storageService.updateConversation(this.currentConversation).catch((error) => {
      console.error("ConversationManager: Failed to update note IDs in storage:", error);
    });
    this.emit("update");
  }
  getMessages() {
    return this.messages;
  }
  getIsLoading() {
    return this.isLoading;
  }
  getStatus() {
    return this.status;
  }
  async addNote(noteId, autoStartConversation = true) {
    const addNoteTotalLabel = `CM_addNote_Total_${noteId.replace(/[^a-zA-Z0-9]/g, "_")}`;
    console.time(addNoteTotalLabel);
    let newNoteFile = null;
    let contextPrepLabel = null;
    let timerEnded = false;
    try {
      if (!this.currentConversation) {
        if (!autoStartConversation) {
          console.log("ConversationManager.addNote: No active conversation and auto-start disabled. Skipping.");
          console.timeEnd(addNoteTotalLabel);
          timerEnded = true;
          return;
        }
        console.log("ConversationManager.addNote: No active conversation. Starting new conversation with this note.");
        const abstractFile2 = this.plugin.app.vault.getAbstractFileByPath(noteId);
        if (!(abstractFile2 instanceof import_obsidian3.TFile)) {
          new import_obsidian3.Notice(`Cannot add note: File not found or not a valid note: ${noteId}`);
          console.error(`ConversationManager.addNote: Could not find TFile for noteId: ${noteId}`);
          console.timeEnd(addNoteTotalLabel);
          timerEnded = true;
          return;
        }
        try {
          console.log(`ConversationManager.addNote: About to start conversation with noteId: ${noteId}`);
          await this.startConversation(noteId, void 0, []);
          console.log(`ConversationManager.addNote: Successfully started conversation. Current conversation:`, this.currentConversation?.id || "null");
          console.log(`ConversationManager.addNote: Conversation noteIds:`, this.currentConversation?.noteIds || []);
          new import_obsidian3.Notice(`Started new conversation with note: ${abstractFile2.basename}`);
          console.timeEnd(addNoteTotalLabel);
          timerEnded = true;
          return;
        } catch (startConversationError) {
          console.error(`ConversationManager.addNote: Failed to start conversation:`, startConversationError);
          new import_obsidian3.Notice(`Failed to start conversation with note: ${abstractFile2.basename}. Error: ${startConversationError instanceof Error ? startConversationError.message : String(startConversationError)}`);
          console.timeEnd(addNoteTotalLabel);
          timerEnded = true;
          return;
        }
      }
      if (!this.plugin.openAIService || !this.plugin.openAIService.isAssistantConfigured()) {
        console.warn("ConversationManager.addNote: OpenAIService not available or not configured.");
        new import_obsidian3.Notice("Cannot add note: AI Service not configured. Please check API key.");
        console.timeEnd(addNoteTotalLabel);
        timerEnded = true;
        return;
      }
      const abstractFile = this.plugin.app.vault.getAbstractFileByPath(noteId);
      if (!(abstractFile instanceof import_obsidian3.TFile)) {
        new import_obsidian3.Notice(`Cannot add note: File not found or not a valid note: ${noteId}`);
        console.error(`ConversationManager.addNote: Could not find TFile for noteId: ${noteId}`);
        console.timeEnd(addNoteTotalLabel);
        timerEnded = true;
        return;
      }
      newNoteFile = abstractFile;
      console.log(`ConversationManager.addNote: Initiated for Note ID: ${noteId}. Current VS ID: ${this.currentConversation.vectorStoreId}`);
      this.isLoading = true;
      this.error = void 0;
      this.setStatus(`Adding note: ${newNoteFile.basename}...`);
      this.emit("update");
      if (this.currentConversation.noteIds.includes(noteId)) {
        console.log(`ConversationManager.addNote: Note ID ${noteId} already in conversation.`);
        this.isLoading = false;
        this.setStatus(`Note ${newNoteFile.basename} already in conversation.`);
        this.emit("update");
        new import_obsidian3.Notice(`Note ${newNoteFile.basename} is already in context.`);
        console.timeEnd(addNoteTotalLabel);
        timerEnded = true;
        return;
      }
      console.log(`ConversationManager.addNote: Old lastSentContextKey: ${this.lastSentContextKey}`);
      contextPrepLabel = `CM_TotalContextPrep_AddNote_${newNoteFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
      console.time(contextPrepLabel);
      let fileAddedToVS = false;
      if (!this.currentConversation.vectorStoreId && this.plugin.openAIService) {
        console.log("ConversationManager.addNote: No existing Vector Store. Attempting to create one.");
        const createVsLabel = this.currentConversation ? `CM_OpenAIService_createVectorStore_AddNote_${this.currentConversation.id}` : "CM_OpenAIService_createVectorStore_AddNote";
        console.time(createVsLabel);
        const newVsId = await this.plugin.openAIService.createVectorStore(`NoteChat Session AddNote - ${this.currentConversation.id.substring(0, 8)}`);
        console.timeEnd(createVsLabel);
        if (newVsId) {
          this.currentConversation.vectorStoreId = newVsId;
          console.log(`ConversationManager.addNote: Created new Vector Store ${newVsId}`);
        } else {
          console.error("ConversationManager.addNote: Failed to create new Vector Store.");
          this.error = "Failed to create Vector Store for adding note.";
          this.setStatus("Error");
          if (contextPrepLabel) console.timeEnd(contextPrepLabel);
          console.timeEnd(addNoteTotalLabel);
          timerEnded = true;
          return;
        }
      }
      if (this.currentConversation.vectorStoreId && this.plugin.openAIService) {
        try {
          const fileContent = await this.plugin.noteService.getFileContent(newNoteFile);
          if (fileContent === null) {
            console.warn(`ConversationManager.addNote: File content is null for ${newNoteFile.name}. Skipping VS operations.`);
            new import_obsidian3.Notice(`Content for ${newNoteFile.basename} is empty. Added to list, but not to AI context.`);
          } else {
            const uploadAddNoteLabel = `CM_OpenAIService_uploadNoteAsFile_${newNoteFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
            console.time(uploadAddNoteLabel);
            let uploadedFileId = await this.plugin.openAIService.getOrUploadFile(fileContent, newNoteFile.name);
            console.timeEnd(uploadAddNoteLabel);
            if (uploadedFileId && this.currentConversation.vectorStoreId) {
              console.log(`ConversationManager.addNote: Uploaded added note ${newNoteFile.name} as File ID: ${uploadedFileId}. Adding to VS.`);
              const addFileToVsAddNoteLabel = `CM_OpenAIService_addFileToVectorStore_${newNoteFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
              console.time(addFileToVsAddNoteLabel);
              let added = await this.plugin.openAIService.addFileToVectorStore(
                this.currentConversation.vectorStoreId,
                uploadedFileId
              );
              console.timeEnd(addFileToVsAddNoteLabel);
              if (!added) {
                console.warn(`ConversationManager.addNote: First attempt to add file ${uploadedFileId} to VS failed. Retrying with fresh upload...`);
                this.plugin.openAIService.clearFileCache();
                const retryUploadLabel = `CM_OpenAIService_retryUpload_${newNoteFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
                console.time(retryUploadLabel);
                const retryUploadedFileId = await this.plugin.openAIService.getOrUploadFile(fileContent, newNoteFile.name);
                console.timeEnd(retryUploadLabel);
                if (retryUploadedFileId && this.currentConversation.vectorStoreId) {
                  console.log(`ConversationManager.addNote: Retry upload successful. New File ID: ${retryUploadedFileId}. Adding to VS.`);
                  const retryAddLabel = `CM_OpenAIService_retryAddToVS_${newNoteFile.basename.replace(/[^a-zA-Z0-9]/g, "_")}`;
                  console.time(retryAddLabel);
                  added = await this.plugin.openAIService.addFileToVectorStore(
                    this.currentConversation.vectorStoreId,
                    retryUploadedFileId
                  );
                  console.timeEnd(retryAddLabel);
                  if (added) {
                    uploadedFileId = retryUploadedFileId;
                    console.log(`ConversationManager.addNote: Retry successful. Using new File ID: ${retryUploadedFileId}`);
                  }
                }
              }
              if (added) {
                this.currentConversation.uploadedFileIds = this.currentConversation.uploadedFileIds || {};
                this.currentConversation.uploadedFileIds[noteId] = uploadedFileId;
                fileAddedToVS = true;
                console.log(`ConversationManager.addNote: Note ${newNoteFile.name} (File ID: ${uploadedFileId}) added to Vector Store ${this.currentConversation.vectorStoreId}.`);
              } else {
                console.error(`ConversationManager.addNote: Failed to add File ID ${uploadedFileId} to Vector Store ${this.currentConversation.vectorStoreId}.`);
                new import_obsidian3.Notice(`Failed to add note ${newNoteFile.basename} to AI context (VS add error).`);
              }
            } else {
              console.error(`ConversationManager.addNote: Failed to upload note ${newNoteFile.name} as a file or VS ID missing after creation.`);
              new import_obsidian3.Notice(`Failed to add note ${newNoteFile.basename} to AI context (upload error or VS missing).`);
            }
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`ConversationManager.addNote: Error processing file ${noteId} for vector store:`, error);
          new import_obsidian3.Notice(`Error processing note ${newNoteFile.basename} for AI context: ${errorMessage}`);
        }
      } else {
        console.warn(`ConversationManager.addNote: No Vector Store ID in current conversation or OpenAIService not available. Cannot upload/add file ${noteId}.`);
        if (!this.plugin.openAIService) new import_obsidian3.Notice("AI Service not available.");
        else new import_obsidian3.Notice("Cannot add note to AI context: Current conversation has no Vector Store after creation attempt.");
      }
      if (contextPrepLabel) console.timeEnd(contextPrepLabel);
      this.currentConversation.noteIds.push(noteId);
      if (newNoteFile && this.currentConversation.contextNotes) {
        this.currentConversation.contextNotes[noteId] = { title: newNoteFile.basename, included: true };
      }
      const activeTFiles = this.getActiveNotes();
      this.lastSentContextKey = this._generateContextKey(activeTFiles);
      console.log(`ConversationManager.addNote: New lastSentContextKey: ${this.lastSentContextKey}`);
      this.currentConversation.lastModified = (/* @__PURE__ */ new Date()).toISOString();
      try {
        await this.storageService.updateConversation(this.currentConversation);
        console.log(`ConversationManager.addNote: Note ${noteId} processing complete, conversation updated in storage.`);
        if (fileAddedToVS) {
          new import_obsidian3.Notice(`Added note ${newNoteFile.basename} to context.`);
        } else if (this.currentConversation.noteIds.includes(noteId) && (!this.currentConversation.uploadedFileIds || !this.currentConversation.uploadedFileIds[noteId])) {
          new import_obsidian3.Notice(`Added note ${newNoteFile.basename} to list, but check AI context sync.`);
        }
      } catch (storageError) {
        console.error("ConversationManager.addNote: Failed to save conversation to storage after adding note:", storageError);
        new import_obsidian3.Notice("Error saving conversation after adding note.");
      }
      this.isLoading = false;
      this.setStatus(`Note ${newNoteFile.basename} processed.`);
    } catch (error) {
      console.error(`ConversationManager.addNote: Error adding note ${noteId}`, error);
      if (contextPrepLabel) console.timeEnd(contextPrepLabel);
      this.error = `Failed to add note: ${error instanceof Error ? error.message : String(error)}`;
      this.setStatus("Error");
    } finally {
      this.isLoading = false;
      this.isProcessing = false;
      this.emit("update");
      if (!timerEnded) {
        console.timeEnd(addNoteTotalLabel);
      }
    }
  }
  async removeNote(noteIdToRemove) {
    console.log(`ConversationManager.removeNote: Initiated for Note ID: ${noteIdToRemove}. Current VS ID: ${this.currentConversation?.vectorStoreId}`);
    if (!this.currentConversation || !this.plugin.openAIService) {
      console.warn("ConversationManager.removeNote: No current conversation or OpenAIService available.");
      return;
    }
    const { vectorStoreId, uploadedFileIds = {} } = this.currentConversation;
    const fileIdToRemove = uploadedFileIds[noteIdToRemove];
    console.log(`ConversationManager.removeNote: Old lastSentContextKey: ${this.lastSentContextKey}`);
    if (vectorStoreId && fileIdToRemove) {
      console.log(`ConversationManager.removeNote: Removing File ID: ${fileIdToRemove} (corresponds to note ${noteIdToRemove}) from Vector Store ${vectorStoreId}`);
      const removedFromVS = await this.plugin.openAIService.removeFileFromVectorStore(vectorStoreId, fileIdToRemove);
      if (removedFromVS) {
        console.log(`ConversationManager.removeNote: Successfully removed File ID ${fileIdToRemove} from Vector Store ${vectorStoreId}. Now attempting to delete the uploaded file itself.`);
        const fileDeleted = await this.plugin.openAIService.deleteUploadedFile(fileIdToRemove);
        if (fileDeleted) {
          console.log(`ConversationManager.removeNote: Successfully deleted uploaded File ID: ${fileIdToRemove}`);
        } else {
          console.warn(`ConversationManager.removeNote: Failed to delete uploaded File ID: ${fileIdToRemove} after removing from VS.`);
        }
      } else {
        console.warn(`ConversationManager.removeNote: Failed to remove File ID ${fileIdToRemove} from Vector Store ${vectorStoreId}.`);
      }
    } else {
      console.warn(`ConversationManager.removeNote: No Vector Store ID or File ID found for note ${noteIdToRemove}. Cannot remove from OpenAI. VS ID: ${vectorStoreId}, File ID: ${fileIdToRemove}`);
    }
    const indexToRemove = this.currentConversation.noteIds.findIndex((id) => id === noteIdToRemove);
    if (indexToRemove !== -1) {
      this.currentConversation.noteIds.splice(indexToRemove, 1);
    }
    if (this.currentConversation.primaryNoteId === noteIdToRemove) {
      this.currentConversation.primaryNoteId = this.currentConversation.noteIds.length > 0 ? this.currentConversation.noteIds[0] : void 0;
    }
    if (this.currentConversation.uploadedFileIds) {
      delete this.currentConversation.uploadedFileIds[noteIdToRemove];
    }
    const activeTFiles = this.getActiveNotes();
    this.lastSentContextKey = this._generateContextKey(activeTFiles);
    console.log(`ConversationManager.removeNote: New lastSentContextKey: ${this.lastSentContextKey}`);
    try {
      await this.storageService.updateConversation(this.currentConversation);
      this.emit("update");
      console.log(`ConversationManager.removeNote: Note ${noteIdToRemove} removed from conversation and updated in storage.`);
    } catch (error) {
      console.error(`ConversationManager.removeNote: Error updating conversation in storage after removing note ${noteIdToRemove}:`, error);
      this.error = `Failed to update conversation: ${error instanceof Error ? error.message : String(error)}`;
      this.status = "Error updating conversation";
      this.emit("update");
    }
  }
  async saveCurrentConversationToNote() {
    try {
      if (!this.currentConversation) {
        console.warn("ConversationManager: No active conversation to save.");
        return null;
      }
      const title = this.createFilename();
      const content = this.formatConversationForSaving(this.currentConversation);
      const file = await this.createNoteFromRawContent(title, content);
      console.log(`ConversationManager: Conversation saved to note ${title}`);
      return file;
    } catch (error) {
      console.error("Error saving conversation to note:", error);
      return null;
    }
  }
  createFilename() {
    const now = /* @__PURE__ */ new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, "0");
    const day = now.getDate().toString().padStart(2, "0");
    const hours = now.getHours().toString().padStart(2, "0");
    const minutes = now.getMinutes().toString().padStart(2, "0");
    const seconds = now.getSeconds().toString().padStart(2, "0");
    return `ChatNote History ${year}${month}${day}, ${hours}${minutes}${seconds}`;
  }
  formatConversationForSaving(conversation) {
    const saveTime = /* @__PURE__ */ new Date();
    console.log("formatConversationForSaving: Current time when saving:", {
      isoString: saveTime.toISOString(),
      localString: saveTime.toString(),
      day: saveTime.getDate(),
      month: saveTime.getMonth() + 1,
      year: saveTime.getFullYear()
    });
    const createdDateProperty = saveTime.toISOString().split("T")[0];
    console.log("formatConversationForSaving: Properties created date:", createdDateProperty);
    const shortConversationId = conversation.id.substring(0, 8);
    let content = `---
`;
    content += `created: ${createdDateProperty}
`;
    content += `tags:
  - NoteChat
`;
    content += `---

`;
    content += `## Included Notes

`;
    if (conversation.noteIds && conversation.noteIds.length > 0) {
      for (const noteId of conversation.noteIds) {
        const file = this.plugin.app.vault.getAbstractFileByPath(noteId);
        if (file instanceof import_obsidian3.TFile) {
          const noteName = file.basename;
          content += `- [[${noteName}]]
`;
        } else {
          const noteName = noteId.split("/").pop()?.replace(/\.md$/, "") || noteId;
          content += `- ${noteName}
`;
        }
      }
    } else {
      content += `No notes were included in this conversation.
`;
    }
    content += `
## Conversation Log

`;
    for (const message of conversation.messages) {
      const role = message.role.charAt(0).toUpperCase() + message.role.slice(1);
      const timestamp = new Date(message.timestamp).toLocaleString("en-US", {
        month: "numeric",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit",
        second: "2-digit",
        hour12: true
      });
      content += `### ${role} (${timestamp})

`;
      content += `${message.content}

`;
    }
    const footerTimestamp = saveTime.toLocaleString("en-US", {
      month: "numeric",
      day: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
      second: "2-digit",
      hour12: true
    });
    content += `---
`;
    content += `*Generated by Sonoria plugin on ${footerTimestamp} | Conversation ID: ${shortConversationId}*`;
    return content;
  }
  async createNoteFromRawContent(title, content) {
    try {
      console.log("Creating note from raw content with title:", title);
      if (!title) throw new Error("Note title cannot be empty");
      if (!content) throw new Error("Note content cannot be empty");
      const conversationDirectory = this.plugin.settings.conversationHistoryDirectory || "/NoteChat Conversations";
      console.log(`ConversationManager: Saving conversation to directory: ${conversationDirectory}`);
      const file = await this.noteService.createNoteInDirectory(title, content, conversationDirectory, true);
      console.log(`Note created successfully (notice suppressed by service): ${file.path}`);
      try {
        await this.noteService.openNote(file);
        console.log("Note opened successfully");
      } catch (openError) {
        console.error("Failed to open the created note:", openError);
      }
      return file;
    } catch (err) {
      const specificErrorMessage = err instanceof Error ? err.message : String(err);
      this.error = `Failed to create note: ${specificErrorMessage}`;
      console.error("Failed to create note:", err);
      this.setStatus("Error creating note");
      throw err;
    }
  }
  async createNoteFromContent(title, content) {
    try {
      console.log("Creating note from content with title:", title);
      if (!title) throw new Error("Note title cannot be empty");
      if (!content) throw new Error("Note content cannot be empty");
      const formattedContent = `# ${title}

` + content + `

---
*Generated by NoteChat plugin on ${formatDateForNote(/* @__PURE__ */ new Date())}*`;
      const file = await this.noteService.createNote(title, formattedContent);
      try {
        await this.noteService.openNote(file);
        console.log("Note opened successfully");
      } catch (openError) {
        console.error("Failed to open the created note:", openError);
      }
      return file;
    } catch (err) {
      const specificErrorMessage = err instanceof Error ? err.message : String(err);
      this.error = `Failed to create note: ${specificErrorMessage}`;
      console.error("Failed to create note:", err);
      this.setStatus("Error creating note");
      throw err;
    } finally {
      this.emit("update");
    }
  }
  getNoteService() {
    return this.noteService;
  }
  setStatus(status) {
    this.status = status;
    this.emit("update");
  }
  setStreamingMessage(message) {
    this.streamingMessage = message;
    this.isStreaming = !!message;
    this.emit("update");
  }
  /**
   * Handles text-to-speech conversion for AI responses when voice input is enabled.
   * This method checks if voice features are enabled and TTS is available, then converts
   * the AI response text to speech and plays it back.
   * @param responseText The AI response text to convert to speech
   */
  async handleTextToSpeech(responseText) {
    try {
      if (!this.plugin.openAIService || !this.plugin.openAIService.isAvailable()) {
        console.log("ConversationManager.handleTextToSpeech: OpenAI service not available, skipping TTS");
        return;
      }
      if (!responseText || responseText.trim().length === 0) {
        console.log("ConversationManager.handleTextToSpeech: Empty response text, skipping TTS");
        return;
      }
      const { playAudioBlob: playAudioBlob2, getPreferredAudioFormat: getPreferredAudioFormat2 } = await Promise.resolve().then(() => (init_audioPlayback(), audioPlayback_exports));
      console.log("ConversationManager.handleTextToSpeech: Starting TTS conversion for response");
      this.setStatus("Converting response to speech...");
      const preferredFormat = getPreferredAudioFormat2();
      const cleanResponseText = removeCitationAnnotations(responseText);
      const audioBlob = await this.plugin.openAIService.textToSpeech(cleanResponseText, {
        voice: "alloy",
        // Default voice, could be configurable in the future
        format: preferredFormat,
        speed: 1
      });
      if (!audioBlob) {
        console.warn("ConversationManager.handleTextToSpeech: TTS conversion failed, no audio blob returned");
        this.setStatus("Text-to-speech conversion failed");
        return;
      }
      console.log("ConversationManager.handleTextToSpeech: TTS conversion successful, starting playback");
      const setVoiceState = (state) => {
        this.emit("voiceStateChange", state);
      };
      await playAudioBlob2(
        audioBlob,
        setVoiceState,
        () => {
          console.log("ConversationManager.handleTextToSpeech: Audio playback completed");
          this.setStatus("Ready");
        },
        (error) => {
          console.error("ConversationManager.handleTextToSpeech: Audio playback error:", error);
          this.setStatus("Audio playback failed");
        }
      );
    } catch (error) {
      console.error("ConversationManager.handleTextToSpeech: Error during TTS processing:", error);
      this.setStatus("Text-to-speech error");
    }
  }
  /**
   * Clear the OpenAI file upload cache (useful for testing or when files change significantly)
   */
  clearFileCache() {
    if (this.plugin.openAIService) {
      this.plugin.openAIService.clearFileCache();
      console.log("ConversationManager: File cache cleared");
    }
  }
  /**
   * Get file cache statistics for debugging
   */
  getFileCacheStats() {
    if (this.plugin.openAIService) {
      return this.plugin.openAIService.getCacheStats();
    }
    return null;
  }
  /**
   * Development method to log performance and cache statistics
   */
  logPerformanceStats() {
    console.log("=== NoteChat Performance Stats ===");
    const cacheStats = this.getFileCacheStats();
    if (cacheStats) {
      console.log(`\u{1F4C1} File Cache: ${cacheStats.size} files cached`);
      console.log(`\u{1F4CB} Cached files:`, cacheStats.entries);
    }
    console.log(`\u{1F4AC} Current conversation: ${this.currentConversation?.id || "None"}`);
    console.log(`\u{1F4C4} Notes in context: ${this.currentConversation?.noteIds?.length || 0}`);
    console.log(`\u{1F517} Vector Store ID: ${this.currentConversation?.vectorStoreId || "None"}`);
    console.log("===================================");
  }
  /**
   * Log expected timing benchmarks for performance monitoring
   */
  logTimingBenchmarks() {
    console.log("=== NoteChat Timing Benchmarks ===");
    console.log("\u{1F3AF} Expected Performance:");
    console.log("  \u2022 AI Response Start: 1.5-2.0 seconds");
    console.log("  \u2022 Context Prep (new): 3-7 seconds");
    console.log("  \u2022 Context Prep (cached): <100ms");
    console.log("  \u2022 File Upload (cached): <50ms");
    console.log("  \u2022 File Upload (new): 0.8-1.2 seconds");
    console.log("  \u2022 STT Transcription: 2-3 seconds");
    console.log("\u26A0\uFE0F  Warning Thresholds:");
    console.log("  \u2022 AI Response Start >3s");
    console.log("  \u2022 Context Prep >10s");
    console.log("  \u2022 File Upload >2s");
    console.log("=====================================");
  }
  /**
   * Establish user gesture for autoplay permissions (called from voice recording)
   */
  establishUserGestureForAutoplay() {
    if (this.progressiveAudioPlayback) {
      this.progressiveAudioPlayback.establishUserGesture();
      console.log("ConversationManager: User gesture established for autoplay");
    }
  }
  /**
   * Generate Progressive TTS on-demand for a specific message (text/dictation mode optimization)
   * This method processes the full message content through sentence extraction and TTS generation
   * @param messageContent - The full message text to process
   * @param messageId - The message ID to associate the audio with
   * @returns Promise that resolves when TTS generation is complete or fails
   */
  async generateProgressiveTTSOnDemand(messageContent, messageId) {
    if (!messageContent || messageContent.trim().length === 0) {
      console.warn("ConversationManager.generateProgressiveTTSOnDemand: Empty message content");
      return false;
    }
    console.log(`\u{1F3AF} On-Demand Progressive TTS: Starting generation for message ${messageId}`);
    this.isOnDemandTTSActive = true;
    this.onDemandMessageId = messageId;
    this.onDemandCompletedSentences = 0;
    try {
      if (!this.ensureProgressiveTTSInitialized() || !this.streamSentenceProcessor || !this.progressiveTTSQueue) {
        console.error("ConversationManager.generateProgressiveTTSOnDemand: Progressive TTS not properly initialized");
        return false;
      }
      let sentenceCount = 0;
      const tempProcessor = new StreamSentenceProcessor((sentence, isFirst) => {
        sentenceCount++;
        console.log(`\u{1F3AF} On-Demand TTS: Processing sentence ${sentenceCount} ${isFirst ? "(first)" : ""}: "${sentence}"`);
        if (this.progressiveTTSQueue) {
          console.log(`\u{1F3AF} On-Demand TTS: Queueing sentence ${sentenceCount} for message ${messageId} (isFirst: ${isFirst})`);
          this.progressiveTTSQueue.queueSentence(sentence, messageId, isFirst);
        }
      });
      const cleanMessageContent = removeCitationAnnotations(messageContent);
      console.log(`\u{1F3AF} On-Demand TTS: Processing full message content (${cleanMessageContent.length} chars)`);
      const chunkSize = 50;
      for (let i = 0; i < cleanMessageContent.length; i += chunkSize) {
        const chunk = cleanMessageContent.slice(i, i + chunkSize);
        tempProcessor.processTextChunk(chunk);
      }
      tempProcessor.finalize();
      this.onDemandExpectedSentences = sentenceCount;
      console.log(`\u{1F3AF} On-Demand Progressive TTS: Sentence extraction complete for message ${messageId} - expecting ${sentenceCount} sentences`);
      return true;
    } catch (error) {
      console.error(`ConversationManager.generateProgressiveTTSOnDemand: Error generating TTS for message ${messageId}:`, error);
      this.isOnDemandTTSActive = false;
      this.onDemandExpectedSentences = 0;
      this.onDemandCompletedSentences = 0;
      this.onDemandMessageId = null;
      return false;
    }
  }
};
__decorateClass([
  observable
], ConversationManager.prototype, "conversations", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "currentConversation", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "hasActiveNote", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "messages", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "isLoading", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "status", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "streamingMessage", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "isStreaming", 2);
__decorateClass([
  observable
], ConversationManager.prototype, "isProcessing", 2);
__decorateClass([
  action
], ConversationManager.prototype, "stopGeneration", 1);
__decorateClass([
  action
], ConversationManager.prototype, "setAIClient", 1);
__decorateClass([
  action
], ConversationManager.prototype, "addTurnToConversation", 1);
__decorateClass([
  action
], ConversationManager.prototype, "updateSettings", 1);
__decorateClass([
  action
], ConversationManager.prototype, "setCurrentConversation", 1);
__decorateClass([
  action
], ConversationManager.prototype, "startConversation", 1);
__decorateClass([
  action
], ConversationManager.prototype, "startGeneralChatConversation", 1);
__decorateClass([
  action
], ConversationManager.prototype, "sendMessage", 1);
__decorateClass([
  action
], ConversationManager.prototype, "endConversation", 1);
__decorateClass([
  action
], ConversationManager.prototype, "generateNote", 1);
__decorateClass([
  action
], ConversationManager.prototype, "updateConversationNoteIds", 1);
__decorateClass([
  action
], ConversationManager.prototype, "addNote", 1);
__decorateClass([
  action
], ConversationManager.prototype, "removeNote", 1);
__decorateClass([
  action
], ConversationManager.prototype, "saveCurrentConversationToNote", 1);
__decorateClass([
  action
], ConversationManager.prototype, "setStatus", 1);
__decorateClass([
  action
], ConversationManager.prototype, "setStreamingMessage", 1);

// src/constants.ts
var VIEW_TYPE_SONORIA = "sonoria-view";

// src/utils/app.ts
var appInstance;
function setAppInstance(app) {
  appInstance = app;
  console.log("App instance set in global utility");
}

// src/utils/devUtils.ts
var DEV_OPENAI_API_KEY = process.env.DEV_OPENAI_API_KEY || "";
function applyDevelopmentSettings(userSettings) {
  const newSettings = { ...userSettings };
  if (!newSettings.openAiApiKey) {
    newSettings.openAiApiKey = DEV_OPENAI_API_KEY;
    if (DEV_OPENAI_API_KEY) {
      console.log("NoteChat: Using DEV_OPENAI_API_KEY from environment for development.");
    }
  }
  return newSettings;
}

// src/core/api/aiClientFactory.ts
var AIClientFactory = class _AIClientFactory {
  constructor() {
  }
  /**
   * Get the singleton instance of the factory
   * @returns The factory instance
   */
  static getInstance() {
    if (!_AIClientFactory.instance) {
      _AIClientFactory.instance = new _AIClientFactory();
    }
    return _AIClientFactory.instance;
  }
  /**
   * Create an AI client from settings
   * @param settings - The plugin settings
   * @returns The appropriate AI client based on settings
   */
  createClientFromSettings(settings) {
    console.log("AIClientFactory: Creating client from settings");
    if (!settings.openAiApiKey) {
      console.warn("AIClientFactory: No OpenAI API key configured, returning PlaceholderAIClient");
      return new PlaceholderAIClient("No OpenAI API key configured");
    }
    console.log("AIClientFactory: OpenAI key configured, but using PlaceholderAIClient for beta (OpenAI Responses API used directly)");
    return new PlaceholderAIClient("OpenAI configured - using Responses API directly");
  }
};

// src/utils/noteContextManager.ts
var import_obsidian4 = require("obsidian");
var NoteContextManager = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Retrieves content from multiple notes and formats it for AI context
   * @param primaryNoteId The ID of the primary note (the one that started the conversation)
   * @param additionalNoteIds Array of additional note IDs to include in context
   * @returns Formatted context containing all note contents
   */
  async getMultiNoteContext(primaryNoteId, additionalNoteIds = []) {
    try {
      console.log(`Building multi-note context with primary note: ${primaryNoteId} and ${additionalNoteIds.length} additional notes`);
      const primaryFile = this.app.vault.getAbstractFileByPath(primaryNoteId);
      if (!primaryFile || !(primaryFile instanceof import_obsidian4.TFile)) {
        throw new Error(`Primary note file not found: ${primaryNoteId}`);
      }
      const primaryNoteContent = await this.app.vault.read(primaryFile);
      additionalNoteIds = additionalNoteIds.filter((id) => id !== primaryNoteId);
      if (!additionalNoteIds || additionalNoteIds.length === 0) {
        return {
          primaryNoteContent,
          additionalContext: "",
          allNoteIds: [primaryNoteId]
        };
      }
      let additionalContext = "";
      const validNoteIds = [primaryNoteId];
      for (const noteId of additionalNoteIds) {
        try {
          const notePath = noteId.endsWith(".md") ? noteId : `${noteId}.md`;
          const noteFile = this.app.vault.getAbstractFileByPath(notePath);
          if (noteFile && noteFile instanceof import_obsidian4.TFile) {
            const content = await this.app.vault.read(noteFile);
            const fileName = noteFile.basename;
            additionalContext += `

--- NOTE: "${fileName}" ---

${content}

`;
            validNoteIds.push(notePath);
            console.log(`Added note to context: ${fileName}`);
          } else {
            console.log(`Note not found or not a valid file: ${noteId}`);
          }
        } catch (error) {
          console.error(`Error reading additional note ${noteId}:`, error);
        }
      }
      return {
        primaryNoteContent,
        additionalContext,
        allNoteIds: validNoteIds
      };
    } catch (error) {
      console.error("Error building multi-note context:", error);
      throw error;
    }
  }
  /**
   * Formats a system message with multi-note context
   * @param primaryNoteId ID of the primary note
   * @param primaryContent Content of the primary note
   * @param additionalContext Formatted additional note content from getMultiNoteContext
   * @returns Formatted system message
   */
  formatSystemMessage(primaryNoteId, primaryContent, additionalContext = "") {
    const primaryFile = this.app.vault.getAbstractFileByPath(primaryNoteId);
    const primaryFileName = primaryFile instanceof import_obsidian4.TFile ? primaryFile.basename : "Untitled";
    let systemPrompt = `You are a helpful AI assistant called Sonoria that helps users analyze and discuss the contents of their notes. `;
    systemPrompt += `The primary note is titled "${primaryFileName}" and contains the following content:

${primaryContent}

`;
    if (additionalContext && additionalContext.trim().length > 0) {
      systemPrompt += `Additional notes for context are provided below:
${additionalContext}

`;
      systemPrompt += `When addressing content from multiple notes, please clearly indicate which note you're referring to. Be sure to address information from ALL provided notes when responding to queries about the notes.`;
    }
    systemPrompt += `

You may refer to the note content to provide insights, summaries, or otherwise help the user understand the material. `;
    systemPrompt += `If the user asks questions about the notes, provide helpful answers based on the content. `;
    systemPrompt += `If the information isn't available in the notes, you can say so. `;
    systemPrompt += `Your responses should be concise and helpful.`;
    systemPrompt += `

If the user asks who you are or about your capabilities, respond that you are Sonoria, an AI assistant that helps analyze and discuss notes in Obsidian. `;
    systemPrompt += `If asked about the current notes you can access, list all notes by their titles that have been provided in the context.`;
    return systemPrompt;
  }
};

// src/features/chat/services/chatService.ts
var import_obsidian13 = require("obsidian");

// src/features/chat/components/NoteChatView.tsx
var import_obsidian12 = require("obsidian");
var import_client = __toESM(require_client());

// src/features/chat/components/ChatView.tsx
var import_react25 = __toESM(require_react());
var import_obsidian11 = require("obsidian");

// node_modules/mobx-react-lite/es/utils/assertEnvironment.js
var import_react = __toESM(require_react());
if (!import_react.useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}

// node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/mobx-react-lite/es/utils/observerBatching.js
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler3) {
  if (!reactionScheduler3) {
    reactionScheduler3 = defaultNoopBatch;
    if (false) {
      console.warn("[MobX] Failed to get unstable_batched updates from react-dom / react-native");
    }
  }
  configure({ reactionScheduler: reactionScheduler3 });
}

// node_modules/mobx-react-lite/es/useObserver.js
var import_react2 = __toESM(require_react());

// node_modules/mobx-react-lite/es/utils/printDebugValue.js
function printDebugValue(v) {
  return getDependencyTree(v);
}

// node_modules/mobx-react-lite/es/staticRendering.js
var globalIsUsingStaticRendering = false;
function isUsingStaticRendering() {
  return globalIsUsingStaticRendering;
}

// node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js
var REGISTRY_FINALIZE_AFTER = 1e4;
var REGISTRY_SWEEP_INTERVAL = 1e4;
var TimerBasedFinalizationRegistry = (
  /** @class */
  function() {
    function TimerBasedFinalizationRegistry2(finalize) {
      var _this = this;
      Object.defineProperty(this, "finalize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: finalize
      });
      Object.defineProperty(this, "registrations", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "sweepTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "sweep", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function(maxAge) {
          if (maxAge === void 0) {
            maxAge = REGISTRY_FINALIZE_AFTER;
          }
          clearTimeout(_this.sweepTimeout);
          _this.sweepTimeout = void 0;
          var now = Date.now();
          _this.registrations.forEach(function(registration, token) {
            if (now - registration.registeredAt >= maxAge) {
              _this.finalize(registration.value);
              _this.registrations.delete(token);
            }
          });
          if (_this.registrations.size > 0) {
            _this.scheduleSweep();
          }
        }
      });
      Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function() {
          _this.sweep(0);
        }
      });
    }
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "register", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(target, value, token) {
        this.registrations.set(token, {
          value,
          registeredAt: Date.now()
        });
        this.scheduleSweep();
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "unregister", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(token) {
        this.registrations.delete(token);
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "scheduleSweep", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        if (this.sweepTimeout === void 0) {
          this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
        }
      }
    });
    return TimerBasedFinalizationRegistry2;
  }()
);
var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : TimerBasedFinalizationRegistry;

// node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js
var observerFinalizationRegistry = new UniversalFinalizationRegistry(function(adm) {
  var _a4;
  (_a4 = adm.reaction) === null || _a4 === void 0 ? void 0 : _a4.dispose();
  adm.reaction = null;
});

// node_modules/mobx-react-lite/es/useObserver.js
var import_shim = __toESM(require_shim());
function createReaction(adm) {
  adm.reaction = new Reaction("observer".concat(adm.name), function() {
    var _a4;
    adm.stateVersion = Symbol();
    (_a4 = adm.onStoreChange) === null || _a4 === void 0 ? void 0 : _a4.call(adm);
  });
}
function useObserver(render, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  if (isUsingStaticRendering()) {
    return render();
  }
  var admRef = import_react2.default.useRef(null);
  if (!admRef.current) {
    var adm_1 = {
      reaction: null,
      onStoreChange: null,
      stateVersion: Symbol(),
      name: baseComponentName,
      subscribe: function(onStoreChange) {
        observerFinalizationRegistry.unregister(adm_1);
        adm_1.onStoreChange = onStoreChange;
        if (!adm_1.reaction) {
          createReaction(adm_1);
          adm_1.stateVersion = Symbol();
        }
        return function() {
          var _a4;
          adm_1.onStoreChange = null;
          (_a4 = adm_1.reaction) === null || _a4 === void 0 ? void 0 : _a4.dispose();
          adm_1.reaction = null;
        };
      },
      getSnapshot: function() {
        return adm_1.stateVersion;
      }
    };
    admRef.current = adm_1;
  }
  var adm = admRef.current;
  if (!adm.reaction) {
    createReaction(adm);
    observerFinalizationRegistry.register(admRef, adm, adm);
  }
  import_react2.default.useDebugValue(adm.reaction, printDebugValue);
  (0, import_shim.useSyncExternalStore)(
    // Both of these must be stable, otherwise it would keep resubscribing every render.
    adm.subscribe,
    adm.getSnapshot,
    adm.getSnapshot
  );
  var renderResult;
  var exception;
  adm.reaction.track(function() {
    try {
      renderResult = render();
    } catch (e) {
      exception = e;
    }
  });
  if (exception) {
    throw exception;
  }
  return renderResult;
}

// node_modules/mobx-react-lite/es/observer.js
var import_react3 = __toESM(require_react());
var _a;
var _b;
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var isFunctionNameConfigurable2 = (_b = (_a = Object.getOwnPropertyDescriptor(function() {
}, "name")) === null || _a === void 0 ? void 0 : _a.configurable) !== null && _b !== void 0 ? _b : false;
var ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof import_react3.forwardRef === "function" && (0, import_react3.forwardRef)(function(props) {
  return null;
})["$$typeof"];
var ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof import_react3.memo === "function" && (0, import_react3.memo)(function(props) {
  return null;
})["$$typeof"];
function observer(baseComponent, options) {
  var _a4;
  if (false) {
    warnObserverOptionsDeprecated = false;
    console.warn("[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`");
  }
  if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  }
  if (isUsingStaticRendering()) {
    return baseComponent;
  }
  var useForwardRef = (_a4 = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a4 !== void 0 ? _a4 : false;
  var render = baseComponent;
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
    useForwardRef = true;
    render = baseComponent["render"];
    if (typeof render !== "function") {
      throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
    }
  }
  var observerComponent = function(props, ref) {
    return useObserver(function() {
      return render(props, ref);
    }, baseComponentName);
  };
  observerComponent.displayName = baseComponent.displayName;
  if (isFunctionNameConfigurable2) {
    Object.defineProperty(observerComponent, "name", {
      value: baseComponent.name,
      writable: true,
      configurable: true
    });
  }
  if (baseComponent.contextTypes) {
    ;
    observerComponent.contextTypes = baseComponent.contextTypes;
    if (false) {
      warnLegacyContextTypes = false;
      console.warn("[mobx-react-lite] Support for Legacy Context in function components will be removed in the next major release.");
    }
  }
  if (useForwardRef) {
    observerComponent = (0, import_react3.forwardRef)(observerComponent);
  }
  observerComponent = (0, import_react3.memo)(observerComponent);
  copyStaticProperties(baseComponent, observerComponent);
  if (false) {
    Object.defineProperty(observerComponent, "contextTypes", {
      set: function() {
        var _a5, _b2;
        throw new Error("[mobx-react-lite] `".concat(this.displayName || ((_a5 = this.type) === null || _a5 === void 0 ? void 0 : _a5.displayName) || ((_b2 = this.type) === null || _b2 === void 0 ? void 0 : _b2.name) || "Component", ".contextTypes` must be set before applying `observer`."));
      }
    });
  }
  return observerComponent;
}
var hoistBlackList = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: true
};
function copyStaticProperties(base, target) {
  Object.keys(base).forEach(function(key) {
    if (!hoistBlackList[key]) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}

// node_modules/mobx-react-lite/es/ObserverComponent.js
function ObserverComponent(_a4) {
  var children = _a4.children, render = _a4.render;
  if (children && render) {
    console.error("MobX Observer: Do not use children and render in the same time in `Observer`");
  }
  var component = children || render;
  if (typeof component !== "function") {
    return null;
  }
  return useObserver(component);
}
if (false) {
  ObserverComponent.propTypes = {
    children: ObserverPropsCheck,
    render: ObserverPropsCheck
  };
}
ObserverComponent.displayName = "Observer";

// node_modules/mobx-react-lite/es/useLocalObservable.js
var import_react4 = __toESM(require_react());

// node_modules/mobx-react-lite/es/useLocalStore.js
var import_react6 = __toESM(require_react());

// node_modules/mobx-react-lite/es/useAsObservableSource.js
var import_react5 = __toESM(require_react());

// node_modules/mobx-react-lite/es/index.js
var _a2;
observerBatching(import_react_dom.unstable_batchedUpdates);
var clearTimers = (_a2 = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a2 !== void 0 ? _a2 : function() {
};

// src/core/context/ChatContext.tsx
var import_react7 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var defaultChatContextValue = {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- ChatProvider always provides a non-null app instance
  app: null,
  plugin: null,
  // plugin can be null as per ChatContextType
  showNoteSelector: false,
  setShowNoteSelector: () => {
  },
  selectorMode: "recent",
  setSelectorMode: () => {
  },
  searchQuery: "",
  setSearchQuery: () => {
  },
  searchResults: [],
  setSearchResults: () => {
  },
  showPrompts: false,
  setShowPrompts: () => {
  },
  showSaveOptions: false,
  setShowSaveOptions: () => {
  }
};
var ChatContext = (0, import_react7.createContext)(defaultChatContextValue);
var ChatProvider = ({ plugin, children }) => {
  const app = plugin.app;
  const [showNoteSelector, setShowNoteSelector] = (0, import_react7.useState)(false);
  const [selectorMode, setSelectorMode] = (0, import_react7.useState)("recent");
  const [searchQuery, setSearchQuery] = (0, import_react7.useState)("");
  const [searchResults, setSearchResults] = (0, import_react7.useState)([]);
  const [showPrompts, setShowPrompts] = (0, import_react7.useState)(false);
  const [showSaveOptions, setShowSaveOptions] = (0, import_react7.useState)(false);
  const contextValue = {
    app,
    plugin,
    showNoteSelector,
    setShowNoteSelector,
    selectorMode,
    setSelectorMode,
    searchQuery,
    setSearchQuery,
    searchResults,
    setSearchResults,
    showPrompts,
    setShowPrompts,
    showSaveOptions,
    setShowSaveOptions
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChatContext.Provider, { value: contextValue, children });
};
var useChatContext = () => {
  const context = (0, import_react7.useContext)(ChatContext);
  if (!context) {
    throw new Error("useChatContext must be used within a ChatProvider");
  }
  return context;
};
var ErrorBoundary = class extends import_react7.default.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, info) {
    console.error("ChatView Error:", error, info);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: "notechat-error", children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", { children: "Something went wrong" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", { children: "Please try refreshing the view or restarting Obsidian." }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("details", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("summary", { children: "Error details" }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("code", { children: this.state.error?.message })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "button",
          {
            className: "notechat-button notechat-button-secondary",
            onClick: () => this.setState({ hasError: false, error: null }),
            children: "Try Again"
          }
        )
      ] });
    }
    return this.props.children;
  }
};

// src/features/chat/hooks/useConversation.ts
var import_react8 = __toESM(require_react());
var import_obsidian5 = require("obsidian");
function useConversation() {
  const { app, plugin } = useChatContext();
  const conversationManager = plugin.conversationManager;
  const noteService = plugin?.noteService;
  const [activeFile, setActiveFile] = (0, import_react8.useState)(null);
  const [isLoading, setIsLoading] = (0, import_react8.useState)(false);
  const [loadingMessage, setLoadingMessage] = (0, import_react8.useState)(null);
  const messages = (0, import_react8.useMemo)(() => {
    return conversationManager?.currentConversation?.messages || [];
  }, [conversationManager?.currentConversation?.messages]);
  const streamingMessage = conversationManager?.streamingMessage || null;
  const isStreaming = conversationManager?.isStreaming || false;
  const currentConversationId = conversationManager?.currentConversation?.id || null;
  const includedNoteIds = conversationManager?.currentConversation?.noteIds || [];
  (0, import_react8.useEffect)(() => {
    const currentFile = app.workspace.getActiveFile();
    if (currentFile) {
      setActiveFile(currentFile);
    }
    const handleActiveFileChanged = () => {
      const file = app.workspace.getActiveFile();
      if (file) {
        setActiveFile(file);
      }
    };
    app.workspace.on("active-leaf-change", handleActiveFileChanged);
    return () => {
      app.workspace.off("active-leaf-change", handleActiveFileChanged);
    };
  }, [app]);
  const saveMessageAsNote = (0, import_react8.useCallback)(async (message) => {
    if (!app) return;
    try {
      setIsLoading(true);
      setLoadingMessage("Creating note...");
      const firstLine = message.content.split("\n")[0].trim();
      const title = firstLine.length > 30 ? firstLine.substring(0, 30) + "..." : firstLine;
      const safeTitle = title.replace(/[\\/:*?"<>|]/g, "-").trim();
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").substring(0, 19);
      const filename = `${safeTitle} ${timestamp}.md`;
      await app.vault.create(filename, message.content);
      new import_obsidian5.Notice("Note created successfully");
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error saving message as note:", errorMessage);
      setLoadingMessage(`Error: ${errorMessage}`);
      new import_obsidian5.Notice(`Error saving note: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  }, [app]);
  const regenerateResponse = (0, import_react8.useCallback)(async (messageId) => {
    if (!conversationManager?.currentConversation || !messages) {
      console.error("Conversation manager or current conversation not available for regeneration.");
      setIsLoading(false);
      setLoadingMessage("Error: Could not regenerate response.");
      return;
    }
    try {
      setIsLoading(true);
      setLoadingMessage("Regenerating response...");
      const currentMessages = conversationManager.currentConversation?.messages || [];
      const messageIndex = currentMessages.findIndex((msg) => msg.id === messageId);
      if (messageIndex <= 0) {
        console.error("Error regenerating response: Could not find preceding user message for ID:", messageId);
        setLoadingMessage("Error: Could not regenerate response.");
        return;
      }
      let userMessageIndex = messageIndex - 1;
      while (userMessageIndex >= 0 && currentMessages[userMessageIndex].role !== "user") {
        userMessageIndex--;
      }
      if (userMessageIndex < 0) {
        console.error("Error regenerating response: No preceding user message found for ID:", messageId);
        setLoadingMessage("Error: Could not regenerate response.");
        return;
      }
      const userMessage = currentMessages[userMessageIndex];
      await conversationManager.sendMessage(userMessage.content);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error regenerating response:", errorMessage);
      setLoadingMessage(`Error: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  }, [conversationManager, messages]);
  const saveConversation = (0, import_react8.useCallback)(async () => {
    if (!conversationManager) {
      new import_obsidian5.Notice("Conversation Manager not available.");
      return;
    }
    setIsLoading(true);
    setLoadingMessage("Saving conversation...");
    try {
      await conversationManager.saveCurrentConversationToNote();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error saving conversation via hook:", errorMessage);
      new import_obsidian5.Notice(`Error saving conversation: ${errorMessage}`);
      setLoadingMessage(`Error: ${errorMessage}`);
    } finally {
      setIsLoading(false);
      if (!loadingMessage?.startsWith("Error:")) {
        setLoadingMessage(null);
      }
    }
  }, [conversationManager, loadingMessage]);
  const startNewConversation = (0, import_react8.useCallback)(async (initialMessage) => {
    if (!conversationManager || !noteService) {
      new import_obsidian5.Notice("Conversation Manager or Note Service not available.");
      return;
    }
    const currentIncludedNoteIds = conversationManager.currentConversation?.noteIds || [];
    if (!activeFile && currentIncludedNoteIds.length === 0) {
      setLoadingMessage("No notes selected for conversation");
      new import_obsidian5.Notice("Select notes or ensure a file is active to start a chat.");
      return;
    }
    try {
      setIsLoading(true);
      setLoadingMessage("Starting conversation...");
      let notesToUse = [...currentIncludedNoteIds];
      if (notesToUse.length === 0 && activeFile) {
        notesToUse = [activeFile.path];
      }
      const primaryNoteId = activeFile && notesToUse.includes(activeFile.path) ? activeFile.path : notesToUse[0];
      const additionalNoteIds = notesToUse.filter((id) => id !== primaryNoteId);
      const primaryNote = app.vault.getAbstractFileByPath(primaryNoteId);
      let primaryContent = "";
      if (primaryNote instanceof import_obsidian5.TFile) {
        primaryContent = await noteService.getFileContent(primaryNote);
      }
      await conversationManager.startConversation(primaryNoteId, primaryContent, additionalNoteIds);
      if (initialMessage) {
        await conversationManager.sendMessage(initialMessage);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error starting conversation:", errorMessage);
      setLoadingMessage(`Error: ${errorMessage}`);
      new import_obsidian5.Notice(`Error starting conversation: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  }, [conversationManager, noteService, app.vault, activeFile]);
  const sendMessage = (0, import_react8.useCallback)(async (text) => {
    if (!conversationManager) return;
    try {
      const currentConvoId = conversationManager.currentConversation?.id;
      if (!currentConvoId) {
        await startNewConversation(text);
        return;
      }
      await conversationManager.sendMessage(text);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error sending message:", errorMessage);
      setLoadingMessage(`Error: ${errorMessage}`);
      new import_obsidian5.Notice(`Error sending message: ${errorMessage}`);
    }
  }, [conversationManager, startNewConversation]);
  const toggleNote = (0, import_react8.useCallback)(() => {
    console.warn("toggleNote functionality is not implemented yet.");
  }, [
    /* conversationManager - remove dependency */
  ]);
  const endConversation = (0, import_react8.useCallback)(() => {
    if (!conversationManager) return;
    conversationManager.endConversation();
  }, [conversationManager]);
  const handleMessageAction = (0, import_react8.useCallback)((action2, messageId) => {
    if (!conversationManager?.currentConversation) {
      console.error("Cannot handle message action: No current conversation.");
      new import_obsidian5.Notice("Error: No active conversation for action.");
      return;
    }
    const message = conversationManager.currentConversation.messages.find((msg) => msg.id === messageId);
    if (!message) {
      console.error(`Message with ID ${messageId} not found for action ${action2}.`);
      new import_obsidian5.Notice("Error: Could not find message for action.");
      return;
    }
    switch (action2) {
      case "save-as-note":
        saveMessageAsNote(message);
        break;
      case "regenerate":
        regenerateResponse(messageId);
        break;
      // Add other actions as needed
      default:
        console.warn(`Unhandled message action: ${action2}`);
    }
  }, [conversationManager, saveMessageAsNote, regenerateResponse]);
  const recycleContext = (0, import_react8.useCallback)(async () => {
    if (!conversationManager) {
      new import_obsidian5.Notice("Conversation Manager not available.");
      return;
    }
    setIsLoading(true);
    setLoadingMessage("Resetting conversation...");
    try {
      await conversationManager.endConversation();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error resetting conversation via hook:", errorMessage);
      new import_obsidian5.Notice(`Error resetting conversation: ${errorMessage}`);
      setLoadingMessage(`Error: ${errorMessage}`);
    } finally {
      setIsLoading(false);
      if (!loadingMessage?.startsWith("Error:")) {
        setLoadingMessage(null);
      }
    }
  }, [conversationManager, loadingMessage]);
  const stopGeneration = (0, import_react8.useCallback)(() => {
    if (!conversationManager) {
      console.warn("Conversation Manager not available for stopping generation.");
      return;
    }
    conversationManager.stopGeneration();
  }, [conversationManager]);
  const isProcessing = conversationManager?.["isProcessing"] ?? false;
  const hasAbortController = conversationManager?.["currentAbortController"] !== null;
  const canStopGeneration = (0, import_react8.useMemo)(() => {
    const result = hasAbortController && isProcessing;
    return result;
  }, [hasAbortController, isProcessing]);
  const managerIsLoading = conversationManager?.["isLoading"] ?? false;
  const combinedIsLoading = managerIsLoading || isLoading;
  return {
    // State (read directly from manager or local state)
    messages,
    isLoading: combinedIsLoading,
    // Use combined loading state
    loadingMessage,
    activeFile,
    includedNoteIds,
    currentConversationId,
    streamingMessage,
    isStreaming,
    // Methods
    sendMessage,
    startNewConversation,
    endConversation,
    toggleNote,
    handleMessageAction,
    saveMessageAsNote,
    regenerateResponse,
    saveConversation,
    recycleContext,
    // 🛑 STOP GENERATION: Stop generation methods
    stopGeneration,
    canStopGeneration
  };
}

// src/features/chat/hooks/useNotes.ts
var import_react9 = __toESM(require_react());
var import_obsidian6 = require("obsidian");
function useNotes() {
  const { app, plugin } = useChatContext();
  const [activeNotes, setActiveNotes] = (0, import_react9.useState)([]);
  const [loadingNotes, setLoadingNotes] = (0, import_react9.useState)(/* @__PURE__ */ new Map());
  const [isLoading, setIsLoading] = (0, import_react9.useState)(false);
  const [error, setError] = (0, import_react9.useState)(null);
  const loadingNotesRef = (0, import_react9.useRef)(loadingNotes);
  loadingNotesRef.current = loadingNotes;
  const noteService = plugin?.noteService;
  let conversationManager = null;
  if (plugin) {
    conversationManager = plugin.conversationManager;
  } else {
    console.warn("useNotes: Plugin instance is not yet available.");
  }
  const refreshNotes = (0, import_react9.useCallback)(() => {
    if (!app || !conversationManager) {
      console.warn("useNotes.refreshNotes: App or ConversationManager not available");
      setActiveNotes([]);
      return;
    }
    const currentLoadingNotes = loadingNotesRef.current;
    if (currentLoadingNotes.size > 0) {
      console.log("useNotes.refreshNotes: Skipping refresh due to active loading operations:", Array.from(currentLoadingNotes.keys()));
      return;
    }
    const currentConversation = conversationManager.currentConversation;
    const noteIds = currentConversation?.noteIds || [];
    console.log("useNotes.refreshNotes: Current noteIds from manager:", noteIds);
    if (noteIds.length === 0) {
      setActiveNotes([]);
      return;
    }
    const noteFiles = [];
    for (const noteId of noteIds) {
      const file = app.vault.getAbstractFileByPath(noteId);
      if (file instanceof import_obsidian6.TFile) {
        noteFiles.push(file);
      } else {
        console.warn(`useNotes.refreshNotes: Could not find TFile for noteId from manager: ${noteId}`);
      }
    }
    console.log("useNotes.refreshNotes: Setting activeNotes based on manager state:", noteFiles.map((f) => f.basename));
    setActiveNotes((prevNotes) => {
      const prevPaths = prevNotes.map((f) => f.path).sort();
      const nextPaths = noteFiles.map((f) => f.path).sort();
      if (JSON.stringify(prevPaths) === JSON.stringify(nextPaths)) {
        return prevNotes;
      }
      return noteFiles;
    });
  }, [app, conversationManager]);
  (0, import_react9.useEffect)(() => {
    let unsubscribe;
    if (conversationManager) {
      unsubscribe = conversationManager.on("update", refreshNotes);
    } else {
      console.warn("useNotes: ConversationManager not available for subscription.");
    }
    refreshNotes();
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, [conversationManager, refreshNotes]);
  const getCurrentFile = (0, import_react9.useCallback)(() => {
    if (!noteService) return null;
    return noteService.getActiveFile();
  }, [noteService]);
  const addCurrentFile = (0, import_react9.useCallback)(async () => {
    const currentFile = getCurrentFile();
    if (!currentFile) {
      new import_obsidian6.Notice("No file is currently active.");
      return;
    }
    if (!conversationManager) {
      new import_obsidian6.Notice("Error: Conversation manager not ready.");
      return;
    }
    try {
      await conversationManager.addNote(currentFile.path);
    } catch (err) {
      console.error("Error adding current file via manager:", err);
      new import_obsidian6.Notice(`Error adding current file: ${err.message || "Unknown error"}`);
    }
  }, [getCurrentFile, conversationManager]);
  const addFileByPath = (0, import_react9.useCallback)(async (path) => {
    if (!conversationManager) {
      new import_obsidian6.Notice("Error: Conversation manager not ready.");
      return;
    }
    try {
      await conversationManager.addNote(path);
    } catch (err) {
      console.error("Error adding file by path via manager:", err);
      new import_obsidian6.Notice(`Failed to add file: ${path}`);
    }
  }, [conversationManager]);
  const removeFile = (0, import_react9.useCallback)(async (path) => {
    if (!conversationManager) {
      new import_obsidian6.Notice("Error: Conversation manager not ready.");
      return;
    }
    try {
      await conversationManager.removeNote(path);
      new import_obsidian6.Notice(`Removed note: ${path.split("/").pop()}`);
    } catch (err) {
      console.error("Error removing file via manager:", err);
      new import_obsidian6.Notice(`Failed to remove file: ${path}`);
    }
  }, [conversationManager]);
  const getRecentFiles = (0, import_react9.useCallback)(async (limit2 = 5) => {
    if (!noteService) return [];
    const files = await noteService.getRecentFiles();
    return files.slice(0, limit2);
  }, [noteService]);
  const searchFiles = (0, import_react9.useCallback)(async (query) => {
    if (!noteService) return [];
    if (!query || query.trim().length === 0) {
      return [];
    }
    setIsLoading(true);
    setError(null);
    console.log(`useNotes: Calling noteService.searchFiles with query: ${query}`);
    try {
      const filteredFiles = await noteService.searchFiles(query);
      console.log(`useNotes: Received ${filteredFiles.length} files from noteService.`);
      setIsLoading(false);
      return filteredFiles;
    } catch (err) {
      console.error("Error searching files via noteService:", err);
      setError(`Failed to search files: ${err.message || "Unknown error"}`);
      setIsLoading(false);
      return [];
    }
  }, [noteService]);
  const addNote = (0, import_react9.useCallback)(async (noteId, file) => {
    console.log("useNotes.addNote: Starting with noteId:", noteId);
    let resolvedFile;
    if (!file) {
      const foundFile = app.vault.getAbstractFileByPath(noteId);
      if (!foundFile || !(foundFile instanceof import_obsidian6.TFile)) {
        console.warn("useNotes.addNote: File not found:", noteId);
        return;
      }
      resolvedFile = foundFile;
    } else {
      resolvedFile = file;
    }
    console.log("useNotes.addNote: Adding to activeNotes immediately for instant feedback");
    setActiveNotes((prev) => {
      if (prev.some((note) => note.path === resolvedFile.path)) {
        console.log("useNotes.addNote: Note already exists in activeNotes");
        return prev;
      }
      console.log("useNotes.addNote: Adding note to activeNotes:", resolvedFile.basename);
      return [...prev, resolvedFile];
    });
    console.log("useNotes.addNote: Setting loading state for animation");
    setLoadingNotes((prev) => new Map(prev).set(noteId, "adding"));
    try {
      console.log("useNotes.addNote: Calling conversationManager.addNote (parallel with animation)");
      await conversationManager?.addNote(noteId, true);
      console.log("useNotes.addNote: ConversationManager operation complete, clearing loading state");
      setLoadingNotes((prev) => {
        const newMap = new Map(prev);
        newMap.delete(noteId);
        return newMap;
      });
      console.log("useNotes.addNote: Triggering final refresh to sync with manager state");
      setTimeout(() => {
        console.log("useNotes.addNote: Executing delayed refreshNotes after loading state cleared");
        refreshNotes();
      }, 50);
    } catch (error2) {
      console.error("useNotes.addNote: Error adding note:", error2);
      setActiveNotes((prev) => prev.filter((note) => note.path !== noteId));
      setLoadingNotes((prev) => {
        const newMap = new Map(prev);
        newMap.delete(noteId);
        return newMap;
      });
    }
  }, [conversationManager, app.vault, refreshNotes]);
  const removeNote = (0, import_react9.useCallback)(async (noteId) => {
    console.log("useNotes.removeNote: Starting with noteId:", noteId);
    console.log("useNotes.removeNote: Setting loading state for animation");
    setLoadingNotes((prev) => {
      const newMap = new Map(prev);
      newMap.set(noteId, "removing");
      console.log("useNotes.removeNote: Loading state set, current loadingNotes:", Array.from(newMap.entries()));
      return newMap;
    });
    try {
      console.log("useNotes.removeNote: Calling conversationManager.removeNote (parallel with animation)");
      await conversationManager?.removeNote(noteId);
      console.log("useNotes.removeNote: ConversationManager operation complete, clearing loading state");
      setLoadingNotes((prev) => {
        const newMap = new Map(prev);
        newMap.delete(noteId);
        console.log("useNotes.removeNote: Loading state cleared");
        return newMap;
      });
      console.log("useNotes.removeNote: Triggering final refresh to sync with manager state");
      setTimeout(() => {
        console.log("useNotes.removeNote: Executing delayed refreshNotes after loading state cleared");
        refreshNotes();
      }, 50);
    } catch (error2) {
      console.error("useNotes.removeNote: Error removing note:", error2);
      setLoadingNotes((prev) => {
        const newMap = new Map(prev);
        newMap.delete(noteId);
        return newMap;
      });
    }
  }, [conversationManager, refreshNotes]);
  return {
    /** List of TFile objects currently included in the active conversation context. */
    activeNotes,
    /** Boolean indicating if a search operation is in progress. */
    isLoading,
    /** Error message string if a search operation failed, otherwise null. */
    error,
    /** Function to add the currently active Obsidian file to the conversation context. */
    addCurrentFile,
    /** Function to add a file to the conversation context by its vault path. */
    addFileByPath,
    /** Function to remove a file from the conversation context by its vault path. */
    removeFile,
    /** Function to get the currently active TFile in the workspace. */
    getCurrentFile,
    /** Function to get a list of recently opened TFiles. */
    getRecentFiles,
    /** Function to search markdown files in the vault based on a query string. */
    searchFiles,
    /** Function to directly set the activeNotes state (use with caution). */
    setActiveNotes,
    loadingNotes,
    addNote,
    removeNote,
    refreshNotes
  };
}

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var import_react11 = __toESM(require_react());

// node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
var toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
var mergeClasses = (...classes) => classes.filter((className, index, array2) => {
  return Boolean(className) && className.trim() !== "" && array2.indexOf(className) === index;
}).join(" ").trim();
var hasA11yProp = (props) => {
  for (const prop in props) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};

// node_modules/lucide-react/dist/esm/Icon.js
var import_react10 = __toESM(require_react());

// node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// node_modules/lucide-react/dist/esm/Icon.js
var Icon = (0, import_react10.forwardRef)(
  ({
    color = "currentColor",
    size = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return (0, import_react10.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react10.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => {
  const Component = (0, import_react11.forwardRef)(
    ({ className, ...props }, ref) => (0, import_react11.createElement)(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  Component.displayName = toPascalCase(iconName);
  return Component;
};

// node_modules/lucide-react/dist/esm/icons/audio-lines.js
var __iconNode = [
  ["path", { d: "M2 10v3", key: "1fnikh" }],
  ["path", { d: "M6 6v11", key: "11sgs0" }],
  ["path", { d: "M10 3v18", key: "yhl04a" }],
  ["path", { d: "M14 8v7", key: "3a1oy3" }],
  ["path", { d: "M18 5v13", key: "123xd1" }],
  ["path", { d: "M22 10v3", key: "154ddg" }]
];
var AudioLines = createLucideIcon("audio-lines", __iconNode);

// node_modules/lucide-react/dist/esm/icons/chevron-down.js
var __iconNode2 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
var ChevronDown = createLucideIcon("chevron-down", __iconNode2);

// node_modules/lucide-react/dist/esm/icons/chevron-up.js
var __iconNode3 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]];
var ChevronUp = createLucideIcon("chevron-up", __iconNode3);

// node_modules/lucide-react/dist/esm/icons/circle-stop.js
var __iconNode4 = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["rect", { x: "9", y: "9", width: "6", height: "6", rx: "1", key: "1ssd4o" }]
];
var CircleStop = createLucideIcon("circle-stop", __iconNode4);

// node_modules/lucide-react/dist/esm/icons/clock.js
var __iconNode5 = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
];
var Clock = createLucideIcon("clock", __iconNode5);

// node_modules/lucide-react/dist/esm/icons/copy.js
var __iconNode6 = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
];
var Copy = createLucideIcon("copy", __iconNode6);

// node_modules/lucide-react/dist/esm/icons/file-plus.js
var __iconNode7 = [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M9 15h6", key: "cctwl0" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }]
];
var FilePlus = createLucideIcon("file-plus", __iconNode7);

// node_modules/lucide-react/dist/esm/icons/keyboard.js
var __iconNode8 = [
  ["path", { d: "M10 8h.01", key: "1r9ogq" }],
  ["path", { d: "M12 12h.01", key: "1mp3jc" }],
  ["path", { d: "M14 8h.01", key: "1primd" }],
  ["path", { d: "M16 12h.01", key: "1l6xoz" }],
  ["path", { d: "M18 8h.01", key: "emo2bl" }],
  ["path", { d: "M6 8h.01", key: "x9i8wu" }],
  ["path", { d: "M7 16h10", key: "wp8him" }],
  ["path", { d: "M8 12h.01", key: "czm47f" }],
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }]
];
var Keyboard = createLucideIcon("keyboard", __iconNode8);

// node_modules/lucide-react/dist/esm/icons/lightbulb.js
var __iconNode9 = [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
];
var Lightbulb = createLucideIcon("lightbulb", __iconNode9);

// node_modules/lucide-react/dist/esm/icons/loader.js
var __iconNode10 = [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
];
var Loader = createLucideIcon("loader", __iconNode10);

// node_modules/lucide-react/dist/esm/icons/mic.js
var __iconNode11 = [
  ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
];
var Mic = createLucideIcon("mic", __iconNode11);

// node_modules/lucide-react/dist/esm/icons/pause.js
var __iconNode12 = [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
];
var Pause = createLucideIcon("pause", __iconNode12);

// node_modules/lucide-react/dist/esm/icons/plus.js
var __iconNode13 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
];
var Plus = createLucideIcon("plus", __iconNode13);

// node_modules/lucide-react/dist/esm/icons/refresh-cw.js
var __iconNode14 = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
];
var RefreshCw = createLucideIcon("refresh-cw", __iconNode14);

// node_modules/lucide-react/dist/esm/icons/save.js
var __iconNode15 = [
  [
    "path",
    {
      d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",
      key: "1c8476"
    }
  ],
  ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7", key: "1ydtos" }],
  ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7", key: "t51u73" }]
];
var Save = createLucideIcon("save", __iconNode15);

// node_modules/lucide-react/dist/esm/icons/search.js
var __iconNode16 = [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
];
var Search = createLucideIcon("search", __iconNode16);

// node_modules/lucide-react/dist/esm/icons/send.js
var __iconNode17 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
];
var Send = createLucideIcon("send", __iconNode17);

// node_modules/lucide-react/dist/esm/icons/square.js
var __iconNode18 = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
];
var Square = createLucideIcon("square", __iconNode18);

// node_modules/lucide-react/dist/esm/icons/triangle-alert.js
var __iconNode19 = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
];
var TriangleAlert = createLucideIcon("triangle-alert", __iconNode19);

// node_modules/lucide-react/dist/esm/icons/x.js
var __iconNode20 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
];
var X = createLucideIcon("x", __iconNode20);

// src/features/chat/components/HeaderActions.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function HeaderActions({ onSaveConversation, onRecycleContext, isRecycling = false }) {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "notechat-header-actions", children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "button",
      {
        onClick: onSaveConversation,
        className: "notechat-button-icon notechat-header__action-icon notechat-header__action-icon--save",
        "aria-label": "Save Conversation",
        title: "Save Conversation",
        children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Save, { size: 16 })
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "button",
      {
        onClick: onRecycleContext,
        className: `notechat-button-icon notechat-header__action-icon notechat-header__action-icon--recycle${isRecycling ? " loading-recycling" : ""}`,
        "aria-label": "Clear Context & History",
        title: isRecycling ? "Clearing Context & History..." : "Clear Context & History",
        disabled: isRecycling,
        children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(RefreshCw, { size: 16 })
      }
    )
  ] });
}
var HeaderActions_default = HeaderActions;

// src/features/chat/components/ChatHeader.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function ChatHeader({
  // title = 'NoteChat', // Default title, will be overridden - REMOVE THIS LINE
  onRecycle,
  // Receive the handler from props
  onSaveConversation,
  // Receive the save handler prop
  // New props
  noteCount,
  isContextAreaFolded,
  onToggleContextAreaFold,
  isRecycling = false
}) {
  const handleRecycleContext = async () => {
    await onRecycle();
  };
  const dynamicTitle = `Sonoria: Context (${noteCount} Note${noteCount === 1 ? "" : "s"})`;
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "notechat-header", children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "notechat-header-left", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h2", { className: "notechat-title", children: dynamicTitle }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "button",
        {
          onClick: onToggleContextAreaFold,
          className: "notechat-header__fold-button",
          "aria-label": isContextAreaFolded ? "Unfold Context Area" : "Fold Context Area",
          children: isContextAreaFolded ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ChevronDown, { size: 18 }) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ChevronUp, { size: 18 })
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "notechat-header-right", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      HeaderActions_default,
      {
        onSaveConversation,
        onRecycleContext: handleRecycleContext,
        isRecycling
      }
    ) })
  ] });
}
var ChatHeader_default = ChatHeader;

// src/features/chat/components/ContextArea.tsx
var import_react15 = __toESM(require_react());

// src/features/chat/components/NoteChip.tsx
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var NoteChip = ({ note, onRemove, loadingState }) => {
  const chipClass = `notechat-note-chip${loadingState ? ` loading-${loadingState}` : ""}`;
  const getLoadingStyle = () => {
    if (loadingState === "adding") {
      return {
        background: "linear-gradient(45deg, #00ff00, #80ff80)",
        border: "3px solid #ff0000",
        color: "#000000",
        fontWeight: "bold",
        transform: "scale(1.1)",
        boxShadow: "0 0 20px #00ff00",
        animation: "loading-pulse 0.5s ease-in-out infinite alternate",
        zIndex: 9999,
        position: "relative"
      };
    }
    if (loadingState === "removing") {
      return {
        background: "linear-gradient(45deg, #ff0000, #ff8080)",
        border: "3px solid #0000ff",
        color: "#ffffff",
        fontWeight: "bold",
        transform: "scale(1.1)",
        boxShadow: "0 0 20px #ff0000",
        animation: "loading-pulse 0.3s ease-in-out infinite alternate",
        zIndex: 9999,
        position: "relative"
      };
    }
    return {};
  };
  console.log(`NoteChip: ${note.basename} - loadingState: ${loadingState}, chipClass: "${chipClass}"`);
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
    "div",
    {
      className: chipClass,
      style: getLoadingStyle(),
      title: note.path,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "notechat-note-chip__name", children: note.basename.replace(/\.md$/, "") }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          "button",
          {
            className: "notechat-note-chip__remove",
            onClick: (event) => {
              event.stopPropagation();
              onRemove(note.path);
            },
            title: `Remove ${note.basename}`,
            disabled: loadingState === "removing",
            children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(X, { size: 12 })
          }
        )
      ]
    }
  );
};
var NoteChip_default = NoteChip;

// src/features/chat/components/SelectedNotesList.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var SelectedNotesList = ({
  activeNotes,
  onRemoveNote,
  loadingNotes = /* @__PURE__ */ new Map()
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "notechat-selected-notes-list", children: activeNotes.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "notechat-no-notes", children: "No notes currently in context." }) : activeNotes.map((note) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    NoteChip_default,
    {
      note,
      onRemove: onRemoveNote,
      loadingState: loadingNotes.get(note.path) || null
    },
    note.path
  )) });
};
var SelectedNotesList_default = SelectedNotesList;

// src/features/chat/components/RecentNotesTab.tsx
var import_react12 = __toESM(require_react());

// src/features/chat/components/RecentNoteItem.tsx
var import_jsx_runtime6 = (
  // Use a button element for better accessibility and semantics, styled as a chip
  __toESM(require_jsx_runtime())
);
function RecentNoteItem({ note, onAddNote }) {
  const handleChipClick = () => {
    onAddNote(note);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
    "button",
    {
      className: "notechat-recent-note-chip",
      onClick: handleChipClick,
      title: `Add note: ${note.basename}`,
      "aria-label": `Add note ${note.basename}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "notechat-recent-note-chip__title", children: note.basename.replace(/\.md$/, "") }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "notechat-recent-note-chip__add-icon", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Plus, { size: 12 }) })
      ]
    }
  );
}
var RecentNoteItem_default = RecentNoteItem;

// src/features/chat/components/RecentNotesTab.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var MAX_RECENT_NOTES_DISPLAY = 5;
var FETCH_LIMIT = 20;
function RecentNotesTab({ onAddNote, activeNotePaths }) {
  const { getRecentFiles } = useNotes();
  const [allRecentNotes, setAllRecentNotes] = (0, import_react12.useState)([]);
  (0, import_react12.useEffect)(() => {
    const fetchFiles = async () => {
      try {
        const files = await getRecentFiles(FETCH_LIMIT);
        setAllRecentNotes(files);
      } catch (error) {
        console.error("RecentNotesTab: Failed to fetch recent files:", error);
      }
    };
    fetchFiles();
  }, [getRecentFiles]);
  const activePathsSet = new Set(activeNotePaths);
  const notesToDisplay = allRecentNotes.filter((note) => !activePathsSet.has(note.path)).slice(0, MAX_RECENT_NOTES_DISPLAY);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "notechat-recent-notes-tab", children: notesToDisplay.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "notechat-recent-notes-tab__empty", children: "No other recent notes found." }) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "notechat-recent-notes-tab__list", children: notesToDisplay.map((note) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    RecentNoteItem_default,
    {
      note,
      onAddNote
    },
    note.path
  )) }) });
}
var RecentNotesTab_default = RecentNotesTab;

// src/features/chat/components/SearchNotesTab.tsx
var import_react13 = __toESM(require_react());

// src/features/chat/components/NoteSearchInput.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
function NoteSearchInput({
  query,
  onChange,
  placeholder = "Type to search notes. Notes in context won't appear."
}) {
  const handleChange = (event) => {
    onChange(event.target.value);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "input",
    {
      type: "text",
      className: "notechat-search-input",
      placeholder,
      value: query,
      onChange: handleChange,
      "aria-label": "Search notes. Notes already in context will not appear in the search results."
    }
  );
}
var NoteSearchInput_default = NoteSearchInput;

// src/features/chat/components/NoteSearchResultItem.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
function NoteSearchResultItem({ note, onAddNote }) {
  const handleChipClick = () => {
    onAddNote(note);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
    "button",
    {
      className: "notechat-search-result-item",
      onClick: handleChipClick,
      title: `Add note: ${note.basename}`,
      "aria-label": `Add note ${note.basename}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "notechat-search-result-item__title", children: note.basename.replace(/\.md$/, "") }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "notechat-search-result-item__add-icon", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Plus, { size: 12 }) })
      ]
    }
  );
}
var NoteSearchResultItem_default = NoteSearchResultItem;

// src/features/chat/components/NoteSearchResultList.tsx
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function NoteSearchResultList({
  results,
  activeNotePaths,
  onAddNote,
  isLoading,
  query
}) {
  const activePathsSet = new Set(activeNotePaths);
  const filteredResults = results.filter((note) => !activePathsSet.has(note.path));
  if (isLoading) {
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { className: "notechat-search-results__message", children: "Searching..." });
  }
  if (!query) {
    return null;
  }
  if (filteredResults.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { className: "notechat-search-results__message", children: "No matching notes found." });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "notechat-search-results-list", children: filteredResults.map((note) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    NoteSearchResultItem_default,
    {
      note,
      onAddNote
    },
    note.path
  )) });
}
var NoteSearchResultList_default = NoteSearchResultList;

// src/features/chat/components/SearchNotesTab.tsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var SEARCH_DELAY_MS = 250;
function SearchNotesTab({ onAddNote, activeNotePaths }) {
  const { app } = useChatContext();
  const [searchQuery, setSearchQuery] = (0, import_react13.useState)("");
  const [searchResults, setSearchResults] = (0, import_react13.useState)([]);
  const [isLoading, setIsLoading] = (0, import_react13.useState)(false);
  (0, import_react13.useEffect)(() => {
    const handler = setTimeout(() => {
      if (searchQuery.trim() === "") {
        setSearchResults([]);
        setIsLoading(false);
        return;
      }
      setIsLoading(true);
      try {
        const allMarkdownFiles = app.vault.getMarkdownFiles();
        const lowerCaseQuery = searchQuery.toLowerCase();
        const results = allMarkdownFiles.filter(
          (file) => file.basename.toLowerCase().includes(lowerCaseQuery)
        );
        setSearchResults(results);
      } catch (error) {
        console.error("Error searching notes:", error);
        setSearchResults([]);
      } finally {
        setIsLoading(false);
      }
    }, SEARCH_DELAY_MS);
    return () => {
      clearTimeout(handler);
    };
  }, [searchQuery, app.vault]);
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "notechat-search-notes-tab", children: [
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      NoteSearchInput_default,
      {
        query: searchQuery,
        onChange: setSearchQuery
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      NoteSearchResultList_default,
      {
        results: searchResults,
        activeNotePaths,
        onAddNote,
        isLoading,
        query: searchQuery
      }
    )
  ] });
}
var SearchNotesTab_default = SearchNotesTab;

// src/features/chat/components/ContextTabs.tsx
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
function NoteSourceTabs({ activeTab, activeNotePaths, onAddNote }) {
  switch (activeTab) {
    case "Recent":
      return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(RecentNotesTab_default, { onAddNote, activeNotePaths });
    case "Search":
      return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SearchNotesTab_default, { onAddNote, activeNotePaths });
    default:
      console.warn("Invalid activeTab in NoteSourceTabs:", activeTab);
      return null;
  }
}
var ContextTabs_default = NoteSourceTabs;

// src/features/chat/components/AddCurrentNoteButton.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
function AddCurrentNoteButton({ onClick, disabled = false }) {
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
    "button",
    {
      className: "notechat-add-current-button",
      onClick,
      disabled,
      title: "Add current note to context",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(FilePlus, { size: 14 }),
        "Current"
      ]
    }
  );
}
var AddCurrentNoteButton_default = AddCurrentNoteButton;

// src/core/hooks/useClickOutside.ts
var import_react14 = __toESM(require_react());
function useClickOutside(ref, callback) {
  (0, import_react14.useEffect)(() => {
    const listener = (event) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      callback(event);
    };
    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);
    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  }, [ref, callback]);
}
var useClickOutside_default = useClickOutside;

// src/features/chat/components/ContextArea.tsx
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var ContextArea = ({
  activeNotes,
  onRemoveNote,
  onAddCurrentNote,
  onAddNote,
  forceCloseSignal,
  currentFile,
  loadingNotes
}) => {
  const [activeTab, setActiveTab] = (0, import_react15.useState)(null);
  const [isTabContentVisible, setIsTabContentVisible] = (0, import_react15.useState)(false);
  const tabContentRef = (0, import_react15.useRef)(null);
  useClickOutside_default(tabContentRef, () => {
    if (isTabContentVisible) {
      setIsTabContentVisible(false);
    }
  });
  (0, import_react15.useEffect)(() => {
    console.log(`ContextArea: forceCloseSignal changed to ${forceCloseSignal}. Setting isTabContentVisible to false.`);
    setIsTabContentVisible(false);
  }, [forceCloseSignal]);
  const activeNotePaths = activeNotes.map((note) => note.path);
  const isCurrentNoteAdded = currentFile ? activeNotePaths.includes(currentFile.path) : false;
  const handleTabClick = (tab) => {
    if (tab === activeTab) {
      setIsTabContentVisible((prev) => !prev);
    } else {
      setActiveTab(tab);
      setIsTabContentVisible(true);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "notechat-context-area", children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      SelectedNotesList_default,
      {
        activeNotes,
        onRemoveNote,
        loadingNotes
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "notechat-add-note-controls", children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        AddCurrentNoteButton_default,
        {
          onClick: onAddCurrentNote,
          disabled: isCurrentNoteAdded
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
        "button",
        {
          className: `notechat-note-source-tabs__tab ${activeTab === "Recent" && isTabContentVisible ? "is-active" : ""}`,
          onClick: () => handleTabClick("Recent"),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Clock, { size: 12 }),
            "Recent"
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
        "button",
        {
          className: `notechat-note-source-tabs__tab ${activeTab === "Search" && isTabContentVisible ? "is-active" : ""}`,
          onClick: () => handleTabClick("Search"),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Search, { size: 12 }),
            "Search"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { ref: tabContentRef, className: `context-tabs-content ${isTabContentVisible && activeTab ? "visible" : ""}`, children: activeTab && isTabContentVisible && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      ContextTabs_default,
      {
        activeTab,
        activeNotePaths,
        onAddNote
      }
    ) })
  ] });
};
var ContextArea_default = ContextArea;

// src/features/chat/components/MessageList.tsx
var import_react19 = __toESM(require_react());

// src/utils/htmlUtils.ts
var sanitizeHtml = (html) => {
  let sanitized = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "");
  sanitized = sanitized.replace(/onerror=("|').*?\1/gi, "");
  sanitized = sanitized.replace(/on\w+=("|').*?\1/gi, "");
  return sanitized;
};

// src/features/chat/components/CollapsibleMessage.tsx
var import_react17 = __toESM(require_react());

// src/features/chat/context/VoiceModeContext.tsx
var import_react16 = __toESM(require_react());
init_VoiceContext();
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var VoiceModeContext = (0, import_react16.createContext)(void 0);
var VoiceModeProvider = ({ children }) => {
  const [voiceMode, setVoiceMode] = (0, import_react16.useState)("text" /* TEXT_ONLY */);
  const [voiceState, setVoiceState] = (0, import_react16.useState)("idle" /* VOICE_IDLE */);
  const [previousMode, setPreviousMode] = (0, import_react16.useState)("text" /* TEXT_ONLY */);
  const audioStorageRef = (0, import_react16.useRef)({});
  const [currentPlayingMessageId, setCurrentPlayingMessageId] = (0, import_react16.useState)(null);
  const isVoiceConversationMode = voiceMode === "voice" /* VOICE_CONVERSATION */;
  const isDictationMode = voiceMode === "dictation" /* DICTATION */;
  (0, import_react16.useEffect)(() => {
    window.sonoriaVoiceConversationMode = isVoiceConversationMode;
    console.log(`\u{1F504} VoiceModeContext: Global voice conversation mode set to ${isVoiceConversationMode}`);
  }, [isVoiceConversationMode]);
  const storeAudio = (0, import_react16.useCallback)((messageId, audioBlob) => {
    if (audioStorageRef.current[messageId]) {
      const existing = audioStorageRef.current[messageId];
      existing.audio.pause();
      URL.revokeObjectURL(existing.objectUrl);
    }
    const objectUrl = URL.createObjectURL(audioBlob);
    const audio = new Audio(objectUrl);
    audioStorageRef.current[messageId] = {
      blob: audioBlob,
      audio,
      objectUrl
    };
    console.log(`VoiceModeContext: Stored audio for message ${messageId}, blob size: ${audioBlob.size} bytes`);
    return audio;
  }, []);
  const getAudio = (0, import_react16.useCallback)((messageId) => {
    const stored = audioStorageRef.current[messageId];
    if (stored) {
      console.log(`VoiceModeContext: Retrieved stored audio for message ${messageId}`);
      return stored.audio;
    }
    console.log(`VoiceModeContext: No stored audio found for message ${messageId}`);
    return null;
  }, []);
  const removeAudio = (0, import_react16.useCallback)((messageId) => {
    const stored = audioStorageRef.current[messageId];
    if (stored) {
      stored.audio.pause();
      URL.revokeObjectURL(stored.objectUrl);
      delete audioStorageRef.current[messageId];
      console.log(`VoiceModeContext: Removed audio for message ${messageId}`);
      if (currentPlayingMessageId === messageId) {
        setCurrentPlayingMessageId(null);
      }
    }
  }, [currentPlayingMessageId]);
  const clearAllAudio = (0, import_react16.useCallback)(() => {
    Object.keys(audioStorageRef.current).forEach((messageId) => {
      const stored = audioStorageRef.current[messageId];
      stored.audio.pause();
      URL.revokeObjectURL(stored.objectUrl);
    });
    audioStorageRef.current = {};
    setCurrentPlayingMessageId(null);
    console.log("VoiceModeContext: Cleared all stored audio");
  }, []);
  const toggleVoiceConversationMode = (0, import_react16.useCallback)(() => {
    console.log(`\u{1F504} toggleVoiceConversationMode called: current voiceMode=${voiceMode}`);
    console.log(`\u{1F504} Voice mode constants: TEXT_ONLY=${"text" /* TEXT_ONLY */}, VOICE_CONVERSATION=${"voice" /* VOICE_CONVERSATION */}`);
    if (voiceMode === "voice" /* VOICE_CONVERSATION */) {
      console.log("\u{1F504} Switching FROM voice conversation TO text mode");
      setVoiceMode("text" /* TEXT_ONLY */);
      setVoiceState("idle" /* VOICE_IDLE */);
      clearAllAudio();
    } else {
      console.log("\u{1F504} Switching FROM text/other mode TO voice conversation");
      setPreviousMode(voiceMode);
      setVoiceMode("voice" /* VOICE_CONVERSATION */);
      setVoiceState("idle" /* VOICE_IDLE */);
    }
    console.log("\u{1F504} toggleVoiceConversationMode completed");
  }, [voiceMode, clearAllAudio]);
  const startDictationMode = (0, import_react16.useCallback)(() => {
    if (voiceMode !== "dictation" /* DICTATION */) {
      setPreviousMode(voiceMode);
      setVoiceMode("dictation" /* DICTATION */);
      setVoiceState("idle" /* VOICE_IDLE */);
    }
  }, [voiceMode]);
  const endDictationMode = (0, import_react16.useCallback)(() => {
    console.log(`\u{1F51A} endDictationMode called: current voiceMode=${voiceMode}, isDictationMode=${isDictationMode}`);
    if (voiceMode === "dictation" /* DICTATION */) {
      console.log("\u{1F51A} Ending dictation mode - returning to TEXT_ONLY");
      setVoiceMode("text" /* TEXT_ONLY */);
      setVoiceState("idle" /* VOICE_IDLE */);
      console.log("\u{1F51A} Dictation mode ended successfully");
    } else {
      console.log(`\u{1F51A} Not in dictation mode (voiceMode=${voiceMode}), no action needed`);
    }
  }, [voiceMode, isDictationMode]);
  const handleSetVoiceMode = (0, import_react16.useCallback)((mode) => {
    if (mode !== "dictation" /* DICTATION */) {
      setPreviousMode(voiceMode);
    }
    setVoiceMode(mode);
    if (mode === "text" /* TEXT_ONLY */) {
      setVoiceState("idle" /* VOICE_IDLE */);
      clearAllAudio();
    }
  }, [voiceMode, clearAllAudio]);
  const contextValue = {
    voiceMode,
    setVoiceMode: handleSetVoiceMode,
    voiceState,
    setVoiceState,
    isVoiceConversationMode,
    isDictationMode,
    toggleVoiceConversationMode,
    startDictationMode,
    endDictationMode,
    previousMode,
    // Audio storage methods
    storeAudio,
    getAudio,
    removeAudio,
    clearAllAudio,
    currentPlayingMessageId,
    setCurrentPlayingMessageId
  };
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(VoiceModeContext.Provider, { value: contextValue, children });
};
var useVoiceMode = () => {
  const context = (0, import_react16.useContext)(VoiceModeContext);
  if (context === void 0) {
    throw new Error("useVoiceMode must be used within a VoiceModeProvider");
  }
  return context;
};
var useVoiceModeCheck = () => {
  const { voiceMode, isVoiceConversationMode, isDictationMode } = useVoiceMode();
  return {
    voiceMode,
    isVoiceConversationMode,
    isDictationMode,
    // Only voice conversation mode should show voice input area, not dictation
    isVoiceMode: isVoiceConversationMode
  };
};

// src/features/chat/components/CollapsibleMessage.tsx
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var CollapsibleMessage = ({
  content,
  className = "",
  wordThreshold,
  truncateWords,
  forceCollapsed = false,
  disableCollapse = false,
  expandedClassName = "",
  collapsedClassName = ""
}) => {
  const { isVoiceConversationMode, isDictationMode } = useVoiceModeCheck();
  const [userHasInteracted, setUserHasInteracted] = (0, import_react17.useState)(false);
  const messageAnalysis = (0, import_react17.useMemo)(() => {
    if (!content || content.trim().length === 0) {
      return {
        shouldCollapse: false,
        wordCount: 0,
        estimatedReadingTime: 1,
        preview: "",
        truncatedContent: ""
      };
    }
    const defaultWordThreshold = 30;
    const defaultTruncateWords = 25;
    const analysis = analyzeMessageContent(content, {
      wordThreshold: wordThreshold ?? defaultWordThreshold,
      truncateWords: truncateWords ?? defaultTruncateWords,
      previewLength: 120
    });
    console.log("\u{1F6D1} DEBUG CollapsibleMessage analysis:", {
      messageId: content.substring(0, 30) + "...",
      wordCount: analysis.wordCount,
      threshold: wordThreshold ?? defaultWordThreshold,
      shouldCollapse: analysis.shouldCollapse,
      contentLength: content.length
    });
    return analysis;
  }, [content, wordThreshold, truncateWords]);
  const shouldCollapse = (0, import_react17.useMemo)(() => {
    if (disableCollapse) return false;
    if (forceCollapsed) return true;
    return messageAnalysis.shouldCollapse;
  }, [disableCollapse, forceCollapsed, messageAnalysis.shouldCollapse]);
  const [isExpanded, setIsExpanded] = (0, import_react17.useState)(() => !shouldCollapse);
  import_react17.default.useEffect(() => {
    if (!userHasInteracted) {
      if (shouldCollapse) {
        setIsExpanded(false);
      } else {
        setIsExpanded(true);
      }
    }
  }, [shouldCollapse, forceCollapsed, messageAnalysis.shouldCollapse, content, userHasInteracted]);
  import_react17.default.useEffect(() => {
    if (!userHasInteracted) {
      if ((isVoiceConversationMode || isDictationMode) && shouldCollapse) {
        console.log("CollapsibleMessage: Auto-collapse for voice mode (no user interaction yet)");
        setIsExpanded(false);
      } else if (!(isVoiceConversationMode || isDictationMode)) {
        console.log("CollapsibleMessage: Reset to natural state (no user interaction yet)");
        setIsExpanded(!shouldCollapse);
      }
    } else {
      console.log("CollapsibleMessage: Preserving user interaction state during mode switch");
    }
  }, [isVoiceConversationMode, isDictationMode, shouldCollapse, userHasInteracted]);
  const handleToggleExpansion = (0, import_react17.useCallback)(() => {
    setIsExpanded((prev) => !prev);
    setUserHasInteracted(true);
  }, []);
  const displayContent = (0, import_react17.useMemo)(() => {
    if (!shouldCollapse || isExpanded) {
      return content;
    }
    return messageAnalysis.truncatedContent;
  }, [shouldCollapse, isExpanded, content, messageAnalysis.truncatedContent]);
  const messageClasses = (0, import_react17.useMemo)(() => {
    const classes = ["collapsible-message"];
    if (className) classes.push(className);
    if (isVoiceConversationMode || isDictationMode) classes.push("voice-mode");
    if (shouldCollapse) classes.push("is-collapsible");
    if (isExpanded) classes.push("is-expanded");
    if (!isExpanded && shouldCollapse) classes.push("is-collapsed");
    if (isExpanded && expandedClassName) classes.push(expandedClassName);
    if (!isExpanded && shouldCollapse && collapsedClassName) classes.push(collapsedClassName);
    return classes.join(" ");
  }, [className, isVoiceConversationMode, isDictationMode, shouldCollapse, isExpanded, expandedClassName, collapsedClassName]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: messageClasses, children: [
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      "div",
      {
        className: "collapsible-message__content",
        dangerouslySetInnerHTML: { __html: sanitizeHtml(displayContent) }
      }
    ),
    shouldCollapse && /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "collapsible-message__controls", children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
        "button",
        {
          className: "collapsible-message__toggle",
          onClick: handleToggleExpansion,
          type: "button",
          "aria-expanded": isExpanded,
          "aria-label": isExpanded ? "Show less" : "Show more",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: "toggle-text", children: isExpanded ? "Show Less" : "Show More" }),
            /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: "toggle-icon", "aria-hidden": "true", children: isExpanded ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ChevronUp, { size: 12 }) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ChevronDown, { size: 12 }) })
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "collapsible-message__metadata", children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("span", { className: "word-count", children: [
          messageAnalysis.wordCount,
          " words"
        ] }),
        messageAnalysis.estimatedReadingTime > 1 && /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("span", { className: "reading-time", children: [
          "\xB7 ",
          messageAnalysis.estimatedReadingTime,
          " min read"
        ] })
      ] })
    ] })
  ] });
};

// src/features/chat/hooks/useTTSPlayback.ts
var import_react18 = __toESM(require_react());
var import_obsidian7 = require("obsidian");
var useTTSPlayback = (messageContent, messageId, existingAudioBlob) => {
  const { isVoiceConversationMode } = useVoiceModeCheck();
  const voiceModeContext = useVoiceMode();
  const getAudio = isVoiceConversationMode ? voiceModeContext.getAudio : null;
  const currentPlayingMessageId = isVoiceConversationMode ? voiceModeContext.currentPlayingMessageId : null;
  const setCurrentPlayingMessageId = isVoiceConversationMode ? voiceModeContext.setCurrentPlayingMessageId : null;
  const [isGenerating, setIsGenerating] = (0, import_react18.useState)(false);
  const [localAudioBlob, setLocalAudioBlob] = (0, import_react18.useState)(existingAudioBlob || null);
  const [error, setError] = (0, import_react18.useState)(null);
  const [progressiveTTSPlaying, setProgressiveTTSPlaying] = (0, import_react18.useState)(false);
  const [isGeneratingProgressiveTTS, setIsGeneratingProgressiveTTS] = (0, import_react18.useState)(false);
  const [progressiveTTSRequested, setProgressiveTTSRequested] = (0, import_react18.useState)(false);
  const localAudioRef = (0, import_react18.useRef)(null);
  const objectUrlRef = (0, import_react18.useRef)(null);
  const eventListenersRef = (0, import_react18.useRef)({});
  const progressiveTTSTimeoutRef = (0, import_react18.useRef)(null);
  (0, import_react18.useEffect)(() => {
    let interval = null;
    let eventCleanup = null;
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (conversationManager && conversationManager.progressiveAudioPlayback) {
      const progressiveAudio = conversationManager.progressiveAudioPlayback;
      const handleStateChangeEvent = (event) => {
        const customEvent = event;
        const { messageId: eventMessageId, eventType, isPlaying: eventIsPlaying } = customEvent.detail;
        if (eventMessageId === messageId) {
          console.log(`\u{1F504} TTS Hook: Received immediate state change event for message ${messageId.substring(0, 8)}: ${eventType}, isPlaying: ${eventIsPlaying}`);
          if (eventIsPlaying !== progressiveTTSPlaying) {
            setProgressiveTTSPlaying(eventIsPlaying);
            console.log(`\u{1F504} TTS Hook: Immediate state update - playing: ${eventIsPlaying} for message ${messageId.substring(0, 8)}`);
          }
          if ((eventType === "playing" || eventType === "auto-started") && !progressiveTTSRequested) {
            setProgressiveTTSRequested(true);
          } else if (eventType === "stopped" && progressiveTTSRequested) {
            setProgressiveTTSRequested(false);
          }
        }
      };
      window.addEventListener("progressiveTTSStateChange", handleStateChangeEvent);
      eventCleanup = () => {
        window.removeEventListener("progressiveTTSStateChange", handleStateChangeEvent);
      };
      const hasAudio2 = progressiveAudio.hasAudioForMessage && progressiveAudio.hasAudioForMessage(messageId);
      const shouldPoll = hasAudio2 || progressiveTTSRequested || progressiveTTSPlaying;
      if (shouldPoll) {
        interval = setInterval(() => {
          const isCurrentlyPlaying = progressiveAudio.isPlayingMessage && progressiveAudio.isPlayingMessage(messageId);
          if (isCurrentlyPlaying !== progressiveTTSPlaying) {
            console.log(`\u{1F504} Progressive TTS State Change (polling): message ${messageId.substring(0, 8)} playing: ${isCurrentlyPlaying} (voice mode: ${isVoiceConversationMode})`);
            setProgressiveTTSPlaying(isCurrentlyPlaying || false);
            if (!isCurrentlyPlaying && progressiveTTSRequested) {
              console.log(`\u{1F504} Progressive TTS: Playback stopped (polling), clearing requested state for proper button sync`);
              setProgressiveTTSRequested(false);
            }
          }
        }, 50);
      } else {
        if (progressiveTTSPlaying) {
          setProgressiveTTSPlaying(false);
        }
        if (progressiveTTSRequested) {
          setProgressiveTTSRequested(false);
        }
      }
    } else {
      if (progressiveTTSPlaying) {
        setProgressiveTTSPlaying(false);
      }
      if (progressiveTTSRequested) {
        setProgressiveTTSRequested(false);
      }
    }
    return () => {
      if (interval) {
        clearInterval(interval);
      }
      if (eventCleanup) {
        eventCleanup();
      }
    };
  }, [messageId, progressiveTTSRequested, progressiveTTSPlaying, isVoiceConversationMode]);
  const isPlaying = (() => {
    if (progressiveTTSPlaying) {
      console.log(`\u{1F3AF} Playing State: message ${messageId.substring(0, 8)} playing via Progressive TTS`);
      return true;
    }
    if (isVoiceConversationMode && currentPlayingMessageId === messageId) {
      if (Math.random() < 0.1) {
        console.log(`\u{1F3AF} Playing State: message ${messageId.substring(0, 8)} playing via shared audio`);
      }
      return true;
    }
    const localPlaying = Boolean(localAudioRef.current && !localAudioRef.current.paused && !localAudioRef.current.ended);
    if (localPlaying) {
      console.log(`\u{1F3AF} Playing State: message ${messageId.substring(0, 8)} playing via local audio`);
    }
    return localPlaying;
  })();
  const hasAudio = (() => {
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (conversationManager && conversationManager.progressiveAudioPlayback) {
      const progressiveAudio = conversationManager.progressiveAudioPlayback;
      if (progressiveAudio.hasAudioForMessage && progressiveAudio.hasAudioForMessage(messageId)) {
        return true;
      }
    }
    if (isVoiceConversationMode && getAudio) {
      if (getAudio(messageId)) {
        return true;
      }
    }
    return Boolean(localAudioBlob);
  })();
  const cleanup = (0, import_react18.useCallback)(() => {
    try {
      if (progressiveTTSTimeoutRef.current) {
        clearTimeout(progressiveTTSTimeoutRef.current);
        progressiveTTSTimeoutRef.current = null;
      }
      if (localAudioRef.current) {
        const audio = localAudioRef.current;
        if (audio.readyState >= 1 && !audio.paused && !audio.ended) {
          try {
            audio.pause();
          } catch (pauseErr) {
            console.warn(`Audio pause warning during cleanup for message ${messageId}:`, pauseErr);
          }
        }
        Object.values(eventListenersRef.current).forEach((listener) => {
          if (listener && typeof listener === "function") {
            try {
              audio.removeEventListener("play", listener);
              audio.removeEventListener("pause", listener);
              audio.removeEventListener("ended", listener);
              audio.removeEventListener("error", listener);
            } catch (err) {
              console.warn(`Event listener removal warning for message ${messageId}:`, err);
            }
          }
        });
        eventListenersRef.current = {};
        localAudioRef.current = null;
      }
    } catch (err) {
      console.warn(`Cleanup warning for message ${messageId}:`, err);
    }
    if (objectUrlRef.current) {
      try {
        URL.revokeObjectURL(objectUrlRef.current);
        objectUrlRef.current = null;
      } catch (err) {
        console.warn(`Object URL revocation warning for message ${messageId}:`, err);
      }
    }
  }, [messageId]);
  (0, import_react18.useEffect)(() => {
    return () => {
      setProgressiveTTSRequested(false);
      setProgressiveTTSPlaying(false);
      cleanup();
    };
  }, [cleanup]);
  const generateTTS = (0, import_react18.useCallback)(async () => {
    try {
      setIsGenerating(true);
      setError(null);
      const openAIService = window.sonoriaPlugin?.openAIService;
      if (!openAIService) {
        throw new Error("OpenAI service not available");
      }
      if (!messageContent || messageContent.trim().length === 0) {
        throw new Error("No content to convert to speech");
      }
      console.log(`Generating TTS for message ${messageId}:`, messageContent.substring(0, 100) + "...");
      const cleanMessageContent = removeCitationAnnotations(messageContent);
      const blob = await openAIService.textToSpeech(cleanMessageContent, {
        voice: "alloy",
        // Could be configurable in the future
        format: "mp3"
      });
      if (!blob) {
        throw new Error("TTS generation failed");
      }
      console.log(`TTS generated successfully for message ${messageId}: ${blob.size} bytes`);
      setLocalAudioBlob(blob);
      return blob;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown TTS error";
      console.error(`TTS generation error for message ${messageId}:`, err);
      setError(errorMessage);
      new import_obsidian7.Notice(`TTS Error: ${errorMessage}`, 3e3);
      return null;
    } finally {
      setIsGenerating(false);
    }
  }, [messageContent, messageId]);
  const generateProgressiveTTSOnDemand = (0, import_react18.useCallback)(async () => {
    if (progressiveTTSRequested) {
      console.log(`Progressive TTS already requested for message ${messageId}, skipping duplicate request`);
      return true;
    }
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (!conversationManager || typeof conversationManager.generateProgressiveTTSOnDemand !== "function") {
      console.warn("ConversationManager or generateProgressiveTTSOnDemand method not available");
      return false;
    }
    console.log(`\u{1F3AF} On-Demand TTS: Starting generation for message ${messageId}`);
    setIsGeneratingProgressiveTTS(true);
    setProgressiveTTSRequested(true);
    setError(null);
    try {
      const timeoutPromise = new Promise((_, reject) => {
        progressiveTTSTimeoutRef.current = setTimeout(() => {
          reject(new Error("Progressive TTS generation timeout (5 seconds)"));
        }, 5e3);
      });
      const generationPromise = conversationManager.generateProgressiveTTSOnDemand(messageContent, messageId);
      const success = await Promise.race([generationPromise, timeoutPromise]);
      if (progressiveTTSTimeoutRef.current) {
        clearTimeout(progressiveTTSTimeoutRef.current);
        progressiveTTSTimeoutRef.current = null;
      }
      if (success) {
        console.log(`\u{1F3AF} On-Demand TTS: Generation successful for message ${messageId}`);
        return true;
      } else {
        console.warn(`\u{1F3AF} On-Demand TTS: Generation failed for message ${messageId}`);
        return false;
      }
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      console.error(`\u{1F3AF} On-Demand TTS: Generation error for message ${messageId}:`, errorMessage);
      if (progressiveTTSTimeoutRef.current) {
        clearTimeout(progressiveTTSTimeoutRef.current);
        progressiveTTSTimeoutRef.current = null;
      }
      if (errorMessage.includes("timeout")) {
        console.log(`\u{1F3AF} On-Demand TTS: Timeout reached, will fall back to traditional TTS`);
      }
      return false;
    } finally {
      setIsGeneratingProgressiveTTS(false);
    }
  }, [messageContent, messageId, progressiveTTSRequested]);
  const playLocalAudio = (0, import_react18.useCallback)(async (blobToPlay) => {
    const targetBlob = blobToPlay || localAudioBlob;
    if (!targetBlob) {
      console.warn("No audio blob available for local playback");
      return;
    }
    try {
      setError(null);
      cleanup();
      objectUrlRef.current = URL.createObjectURL(targetBlob);
      localAudioRef.current = new Audio(objectUrlRef.current);
      const audio = localAudioRef.current;
      const handlePlay = () => {
        console.log(`Local audio playback started for message ${messageId}`);
      };
      const handlePause = () => {
        console.log(`Local audio playback paused for message ${messageId}`);
      };
      const handleEnded = () => {
        console.log(`Local audio playback completed for message ${messageId}`);
        cleanup();
      };
      const handleError = (event) => {
        const audioError = event ? event.target?.error : null;
        const errorMessage = `Local audio playback error: ${audioError?.message || "Unknown error"}`;
        console.error(`Local audio playback error for message ${messageId}:`, audioError);
        setError(errorMessage);
        cleanup();
      };
      eventListenersRef.current = {
        play: handlePlay,
        pause: handlePause,
        ended: handleEnded,
        error: handleError
      };
      audio.addEventListener("play", handlePlay);
      audio.addEventListener("pause", handlePause);
      audio.addEventListener("ended", handleEnded);
      audio.addEventListener("error", handleError);
      await audio.play();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown playback error";
      console.error(`Local audio playback error for message ${messageId}:`, err);
      setError(errorMessage);
      cleanup();
    }
  }, [localAudioBlob, messageId, cleanup]);
  (0, import_react18.useEffect)(() => {
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (conversationManager && conversationManager.progressiveAudioPlayback) {
      const progressiveAudio = conversationManager.progressiveAudioPlayback;
      const onComplete = (completedMessageId) => {
        if (completedMessageId === messageId) {
          console.log(`\u{1F504} Progressive TTS: Playback completed - for completion events (message ${messageId.substring(0, 8)})`);
          setProgressiveTTSPlaying(false);
          setProgressiveTTSRequested(false);
          if (isVoiceConversationMode && setCurrentPlayingMessageId && currentPlayingMessageId === messageId) {
            setCurrentPlayingMessageId(null);
          }
        }
      };
      progressiveAudio.onPlaybackComplete = onComplete;
      return () => {
        if (progressiveAudio && progressiveAudio.onPlaybackComplete === onComplete) {
          progressiveAudio.onPlaybackComplete = void 0;
        }
      };
    }
    return () => {
    };
  }, [messageId, isVoiceConversationMode, setCurrentPlayingMessageId, currentPlayingMessageId]);
  const playAudio = (0, import_react18.useCallback)(async (blobToPlay) => {
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (conversationManager && conversationManager.progressiveAudioPlayback) {
      const progressiveAudio = conversationManager.progressiveAudioPlayback;
      const hasProgressiveAudio = progressiveAudio.hasAudioForMessage && progressiveAudio.hasAudioForMessage(messageId);
      console.log(`\u{1F3AF} TTS Debug: messageId=${messageId.substring(0, 8)}, hasProgressiveAudio=${hasProgressiveAudio}, isVoiceMode=${isVoiceConversationMode}`);
      if (hasProgressiveAudio) {
        console.log(`\u{1F3AF} Progressive TTS: Using existing progressive audio for message ${messageId}`);
        try {
          setError(null);
          if (progressiveAudio.startPlaybackForMessage) {
            await progressiveAudio.startPlaybackForMessage(messageId);
          }
          if (isVoiceConversationMode && setCurrentPlayingMessageId) {
            setCurrentPlayingMessageId(messageId);
          }
          console.log(`\u{1F3AF} Progressive TTS: Playback started successfully, resetting requested state for message ${messageId}`);
          return;
        } catch (err) {
          console.warn(`Progressive TTS playback failed for message ${messageId}, falling back:`, err);
        }
      } else if (isVoiceConversationMode) {
        console.log(`\u{1F3AF} Voice Mode TTS: No progressive audio found for message ${messageId}, attempting on-demand generation`);
        try {
          const generationSuccess = await generateProgressiveTTSOnDemand();
          if (generationSuccess) {
            let retries = 0;
            const maxRetries = 20;
            while (retries < maxRetries) {
              await new Promise((resolve) => setTimeout(resolve, 500));
              if (progressiveAudio.hasAudioForMessage?.(messageId)) {
                console.log(`\u{1F3AF} Voice Mode TTS: First sentence audio ready after ${(retries + 1) * 500}ms, starting playback for message ${messageId}`);
                if (progressiveAudio.startPlaybackForMessage) {
                  await progressiveAudio.startPlaybackForMessage(messageId);
                  console.log(`\u{1F3AF} Voice Mode TTS: Playback started successfully for message ${messageId}`);
                }
                if (isVoiceConversationMode && setCurrentPlayingMessageId) {
                  setCurrentPlayingMessageId(messageId);
                }
                return;
              }
              retries++;
              console.log(`\u{1F3AF} Voice Mode TTS: Waiting for first sentence audio... attempt ${retries}/${maxRetries}`);
            }
            console.warn(`\u{1F3AF} Voice Mode TTS: Timeout waiting for first sentence audio for message ${messageId}, falling back`);
          } else {
            console.log(`\u{1F3AF} Voice Mode TTS: On-demand generation failed for message ${messageId}, falling back to traditional TTS`);
          }
        } catch (err) {
          console.warn(`\u{1F3AF} Voice Mode TTS: On-demand generation error for message ${messageId}:`, err);
        }
      } else if (!isVoiceConversationMode) {
        console.log(`\u{1F3AF} Progressive TTS: No existing audio for message ${messageId}, attempting on-demand generation (text/dictation mode)`);
        try {
          const generationSuccess = await generateProgressiveTTSOnDemand();
          if (generationSuccess) {
            let retries = 0;
            const maxRetries = 20;
            while (retries < maxRetries) {
              await new Promise((resolve) => setTimeout(resolve, 500));
              if (progressiveAudio.hasAudioForMessage?.(messageId)) {
                console.log(`\u{1F3AF} Progressive TTS: First sentence audio ready after ${(retries + 1) * 500}ms, starting auto-playback for message ${messageId} (text/dictation mode)`);
                if (progressiveAudio.startPlaybackForMessage) {
                  await progressiveAudio.startPlaybackForMessage(messageId);
                  console.log(`\u{1F3AF} Progressive TTS: Auto-playback started successfully for message ${messageId}`);
                }
                if (isVoiceConversationMode && setCurrentPlayingMessageId) {
                  setCurrentPlayingMessageId(messageId);
                }
                console.log(`\u{1F3AF} Progressive TTS: Auto-playback completed setup for message ${messageId}`);
                return;
              }
              retries++;
              console.log(`\u{1F3AF} Progressive TTS: Waiting for first sentence audio... attempt ${retries}/${maxRetries}`);
            }
            console.warn(`\u{1F3AF} Progressive TTS: Timeout waiting for first sentence audio for message ${messageId}, falling back`);
          } else {
            console.log(`\u{1F3AF} Progressive TTS: On-demand generation failed for message ${messageId}, falling back to traditional TTS`);
          }
        } catch (err) {
          console.warn(`\u{1F3AF} Progressive TTS: On-demand generation error for message ${messageId}:`, err);
        }
      } else {
        console.log(`\u{1F3AF} Progressive TTS: No progressive audio found for message ${messageId} (voice mode), checking alternatives`);
      }
    }
    if (isVoiceConversationMode && getAudio && setCurrentPlayingMessageId) {
      const sharedAudio = getAudio(messageId);
      if (sharedAudio) {
        console.log(`Using shared audio for message ${messageId} in voice mode`);
        try {
          setError(null);
          setCurrentPlayingMessageId(messageId);
          await sharedAudio.play();
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "Shared audio playback error";
          console.error(`Shared audio playback error for message ${messageId}:`, err);
          setError(errorMessage);
          setCurrentPlayingMessageId(null);
        }
        return;
      } else {
        console.log(`No shared audio found for message ${messageId}, falling back to generation`);
      }
    }
    console.log(`\u{1F3AF} Fallback: Using traditional TTS generation for message ${messageId}`);
    await playLocalAudio(blobToPlay);
  }, [isVoiceConversationMode, getAudio, setCurrentPlayingMessageId, messageId, playLocalAudio, generateProgressiveTTSOnDemand]);
  const stopAudio = (0, import_react18.useCallback)(() => {
    console.log(`\u{1F6D1} Stopping audio for message ${messageId.substring(0, 8)}, current playing state: ${isPlaying}`);
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (conversationManager && conversationManager.progressiveAudioPlayback) {
      const progressiveAudio = conversationManager.progressiveAudioPlayback;
      if (progressiveAudio.isPlayingMessage && progressiveAudio.isPlayingMessage(messageId)) {
        console.log(`\u{1F3AF} Progressive TTS: Stopping progressive audio for message ${messageId}`);
        try {
          if (progressiveAudio.stopPlaybackForMessage) {
            progressiveAudio.stopPlaybackForMessage(messageId);
          }
          setProgressiveTTSPlaying(false);
          setProgressiveTTSRequested(false);
          setIsGeneratingProgressiveTTS(false);
          if (isVoiceConversationMode && setCurrentPlayingMessageId && currentPlayingMessageId === messageId) {
            setCurrentPlayingMessageId(null);
          }
          console.log(`\u{1F527} Progressive TTS: All state reset for message ${messageId} - ready for next interaction`);
          return;
        } catch (err) {
          console.warn(`Progressive TTS stop failed for message ${messageId}:`, err);
          setProgressiveTTSPlaying(false);
          setProgressiveTTSRequested(false);
          setIsGeneratingProgressiveTTS(false);
        }
      }
    }
    if (isVoiceConversationMode && getAudio && setCurrentPlayingMessageId && currentPlayingMessageId === messageId) {
      const sharedAudio = getAudio(messageId);
      if (sharedAudio) {
        try {
          sharedAudio.pause();
          setCurrentPlayingMessageId(null);
          console.log(`Stopped shared audio for message ${messageId}`);
          return;
        } catch (err) {
          console.warn(`Error stopping shared audio for message ${messageId}:`, err);
        }
      }
    }
    try {
      if (localAudioRef.current) {
        const audio = localAudioRef.current;
        if (audio.readyState >= 1 && !audio.paused && !audio.ended) {
          try {
            audio.pause();
            console.log(`Local audio playback stopped for message ${messageId}`);
          } catch (pauseErr) {
            console.warn(`Local audio pause error for message ${messageId}:`, pauseErr);
          }
        } else {
          console.log(`Local audio already stopped or not ready for message ${messageId}`);
        }
      }
    } catch (err) {
      console.warn(`Audio stop warning for message ${messageId}:`, err);
    } finally {
      cleanup();
    }
  }, [isVoiceConversationMode, getAudio, setCurrentPlayingMessageId, currentPlayingMessageId, messageId, cleanup, isPlaying]);
  const generateAndPlay = (0, import_react18.useCallback)(async () => {
    const blob = await generateTTS();
    if (blob) {
      await playLocalAudio(blob);
    }
  }, [generateTTS, playLocalAudio]);
  const clearError = (0, import_react18.useCallback)(() => {
    setError(null);
  }, []);
  return {
    // State
    isGenerating: isGenerating || isGeneratingProgressiveTTS,
    isPlaying,
    hasAudio,
    error,
    // Controls
    playAudio,
    stopAudio,
    generateAndPlay,
    clearError
  };
};

// src/features/chat/components/MessageList.tsx
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var AIMessage = observer(({
  message,
  isStreamingMsg,
  shouldUseCollapsible,
  effectiveWordThreshold
}) => {
  const timestamp = message.timestamp ? formatDate(message.timestamp, "short") : "";
  const { isVoiceConversationMode, isDictationMode } = useVoiceModeCheck();
  const {
    isGenerating,
    isPlaying,
    error,
    playAudio,
    stopAudio,
    clearError
  } = useTTSPlayback(message.content, message.id);
  const handleCopyMessage = (content) => {
    navigator.clipboard.writeText(content);
  };
  const handleTTSClick = async () => {
    console.log(`\u{1F3AF} TTS Button: Clicked for message ${message.id.substring(0, 8)}, isPlaying=${isPlaying}, isGenerating=${isGenerating}`);
    if (isPlaying) {
      console.log(`\u{1F3AF} TTS Button: Stopping audio for message ${message.id.substring(0, 8)}`);
      stopAudio();
      return;
    }
    try {
      console.log(`\u{1F3AF} TTS Button: Starting playAudio for message ${message.id.substring(0, 8)}`);
      await playAudio();
      console.log(`\u{1F3AF} TTS Button: playAudio completed for message ${message.id.substring(0, 8)}`);
    } catch (err) {
      console.error("TTS playAudio error:", err);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    "div",
    {
      className: `chat-message assistant-message ${isStreamingMsg ? "streaming-message" : ""} ${shouldUseCollapsible ? "has-collapsible-content" : ""}`,
      children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "message-content-container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "message-header", children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "message-role", children: "Assistant" }),
          timestamp && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "message-timestamp", children: timestamp }),
          isStreamingMsg && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "streaming-indicator", children: "\u25CF" })
        ] }),
        shouldUseCollapsible ? /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          CollapsibleMessage,
          {
            content: message.content,
            className: "message-text",
            wordThreshold: effectiveWordThreshold,
            forceCollapsed: (isVoiceConversationMode || isDictationMode) && !isStreamingMsg
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          "div",
          {
            className: "message-text",
            dangerouslySetInnerHTML: { __html: sanitizeHtml(message.content || "") }
          }
        ),
        !isStreamingMsg && /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "message-actions", children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            "button",
            {
              className: "action-button copy-button",
              onClick: () => handleCopyMessage(message.content),
              title: "Copy message",
              children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Copy, { size: 14 })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            "button",
            {
              className: `action-button tts-button ${isPlaying ? "playing" : ""} ${isGenerating ? "generating" : ""}`,
              onClick: handleTTSClick,
              disabled: isGenerating,
              title: isVoiceConversationMode ? isPlaying ? "Stop audio" : "Play audio" : isPlaying ? "Stop audio" : "Generate and play audio",
              children: isGenerating ? /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Loader, { size: 14 }) : isPlaying ? /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Pause, { size: 14 }) : /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(AudioLines, { size: 14 })
            }
          ),
          error && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            "span",
            {
              className: "tts-error-indicator",
              title: error,
              onClick: clearError,
              children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(TriangleAlert, { size: 14 })
            }
          )
        ] })
      ] })
    }
  );
});
var MessageList = observer(({
  messages,
  isLoading,
  className = "",
  loadingMessage = "",
  // Just show dots without text
  streamingMessage = null,
  isStreaming = false,
  enableCollapsibleMessages = true,
  collapsibleWordThreshold
}) => {
  const effectiveWordThreshold = collapsibleWordThreshold ?? 30;
  const messagesEndRef = (0, import_react19.useRef)(null);
  (0, import_react19.useEffect)(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingMessage?.content, isStreaming]);
  if (!messages.length && !isLoading && !isStreaming) {
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "empty-messages", children: [
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "empty-messages-icon", children: "\u{1F4AC}" }),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("p", { children: "Start a conversation by typing a message below." })
    ] });
  }
  const handleCopyMessage = (content) => {
    navigator.clipboard.writeText(content);
  };
  const renderMessage = (message, index, isStreamingMsg = false) => {
    const isUser = message.role === "user";
    const timestamp = message.timestamp ? formatDate(message.timestamp, "short") : "";
    const isErrorOrSystemMessage = message.content && (message.content.includes("Request was cancelled") || message.content.includes("Error:") || message.content.includes("cancelled by user") || message.content.length < 20);
    const shouldUseCollapsible = Boolean(
      enableCollapsibleMessages && !isUser && !isStreamingMsg && message.content && message.content.length > 0 && !isErrorOrSystemMessage
      // Don't collapse error/system messages
    );
    if (!isUser) {
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        AIMessage,
        {
          message,
          isStreamingMsg,
          shouldUseCollapsible,
          effectiveWordThreshold
        },
        isStreamingMsg ? "streaming-message" : `message-${index}`
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      "div",
      {
        className: `chat-message user-message ${isStreamingMsg ? "streaming-message" : ""}`,
        children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "message-content-container", children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "message-header", children: [
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "message-role", children: "You" }),
            timestamp && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "message-timestamp", children: timestamp }),
            isStreamingMsg && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "streaming-indicator", children: "\u25CF" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            "div",
            {
              className: "message-text",
              dangerouslySetInnerHTML: { __html: sanitizeHtml(message.content || "") }
            }
          ),
          !isStreamingMsg && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "message-actions", children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            "button",
            {
              className: "action-button copy-button",
              onClick: () => handleCopyMessage(message.content),
              title: "Copy message",
              children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Copy, { size: 14 })
            }
          ) })
        ] })
      },
      isStreamingMsg ? "streaming-message" : `message-${index}`
    );
  };
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: `messages-container ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "messages-list", children: [
    messages.map((message, index) => renderMessage(message, index, false)),
    isStreaming && streamingMessage && !messages.find((m) => m.id === streamingMessage.id) && renderMessage(streamingMessage, -1, true),
    isLoading && !isStreaming && /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "loading-message", children: [
      /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "loading-indicator", children: [
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "loading-dot" }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "loading-dot" }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "loading-dot" }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "loading-dot" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "loading-text", children: loadingMessage })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { ref: messagesEndRef })
  ] }) });
});

// src/features/chat/components/ChatMessageArea.tsx
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
function ChatMessageArea({
  messages = [],
  isLoading,
  loadingMessage = "",
  // Just show dots without text
  className = "",
  streamingMessage = null,
  isStreaming = false
}) {
  const renderEmptyState = () => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "notechat-empty-state", children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: "notechat-empty-icon" }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h3", { children: "\u{1F44B} Welcome to Sonoria!" }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("p", { children: "Type a message, hold the mic, or tap \u25B6\uFE0F to hear replies\u2014I'll search your selected notes and answer back in real time. Open the Context panel, switch modes, and let your vault talk. Say hi and watch ideas come alive! \u{1F680}" })
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: `notechat-messages-container ${className}`, children: messages.length === 0 && !isStreaming ? renderEmptyState() : /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
    MessageList,
    {
      messages,
      isLoading,
      loadingMessage: loadingMessage || "",
      streamingMessage,
      isStreaming
    }
  ) });
}
var ChatMessageArea_default = ChatMessageArea;

// src/features/chat/components/ChatInput.tsx
var import_react20 = __toESM(require_react());
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
function ChatInput({
  value,
  onChange,
  onSendViaEnter,
  isLoading = false,
  placeholder = "Type a message...",
  disabled = false
}) {
  const textareaRef = (0, import_react20.useRef)(null);
  const resizeTextarea = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  };
  (0, import_react20.useEffect)(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.focus();
      resizeTextarea();
      window.addEventListener("resize", resizeTextarea);
      return () => {
        window.removeEventListener("resize", resizeTextarea);
      };
    }
    return void 0;
  }, []);
  (0, import_react20.useEffect)(() => {
    resizeTextarea();
  }, [value]);
  const handleKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey && !disabled && !isLoading) {
      e.preventDefault();
      onSendViaEnter();
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "message-input-container", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
    "textarea",
    {
      ref: textareaRef,
      value,
      onChange,
      onKeyDown: handleKeyDown,
      placeholder,
      disabled: isLoading || disabled,
      rows: 1,
      className: "message-input",
      autoFocus: true,
      style: {
        resize: "none",
        border: "none",
        outline: "none",
        background: "transparent",
        width: "100%",
        padding: "10px",
        color: "var(--text-normal)",
        fontFamily: "inherit",
        fontSize: "15px",
        minHeight: "20px",
        maxHeight: "150px",
        overflow: "auto"
      }
    }
  ) });
}

// src/features/chat/components/SuggestedPromptsButton.tsx
var import_react21 = __toESM(require_react());

// src/features/chat/components/PromptItem.tsx
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
function PromptItem({ prompt, onSelect }) {
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("li", { className: "prompt-item", onClick: () => onSelect(prompt), children: [
    " ",
    prompt
  ] });
}

// src/features/chat/components/SuggestedPromptsList.tsx
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
function SuggestedPromptsList({
  prompts,
  // Receive SuggestedPrompt[]
  onSelectPrompt,
  onClose
}) {
  const handleSelect = (promptText) => {
    onSelectPrompt(promptText);
    onClose();
  };
  if (prompts.length === 0) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("ul", { className: "suggested-prompts-list", children: prompts.map((prompt) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    PromptItem,
    {
      prompt: prompt.text,
      onSelect: handleSelect
    },
    prompt.text
  )) });
}

// src/features/chat/components/SuggestedPromptsButton.tsx
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
function SuggestedPromptsButton({
  onSelectPrompt,
  prompts,
  // Receive SuggestedPrompt[]
  forceCloseSignal
  // Destructure boolean signal
}) {
  const [isListVisible, setIsListVisible] = (0, import_react21.useState)(false);
  (0, import_react21.useEffect)(() => {
    if (isListVisible) {
      console.log("SuggestedPromptsButton: forceCloseSignal changed, closing list.");
      setIsListVisible(false);
    }
  }, [forceCloseSignal]);
  const handleToggleList = () => {
    const nextState = !isListVisible;
    console.log("handleToggleList called. Current state:", isListVisible, "Next state:", nextState);
    setIsListVisible(nextState);
  };
  const handleSelect = (prompt) => {
    onSelectPrompt(prompt);
    setIsListVisible(false);
  };
  const buttonLabel = "Suggested Prompts";
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: "suggested-prompts-container", children: [
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      "button",
      {
        className: "suggested-prompts-button",
        onClick: handleToggleList,
        "aria-label": buttonLabel,
        title: buttonLabel,
        children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(Lightbulb, { size: 16 })
      }
    ),
    isListVisible && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(import_jsx_runtime22.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      SuggestedPromptsList,
      {
        prompts,
        onSelectPrompt: handleSelect,
        onClose: () => setIsListVisible(false)
      }
    ) })
  ] });
}

// src/features/chat/components/SendButton.tsx
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
function SendButton({ onClick, disabled, isGenerating = false, onStop }) {
  if (isGenerating && onStop) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
      "button",
      {
        className: "send-button stop-button",
        onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          onStop();
        },
        disabled: false,
        "aria-label": "Stop generation",
        title: "Stop generation",
        children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Square, { size: 16 })
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    "button",
    {
      className: "send-button",
      onClick,
      disabled,
      "aria-label": "Send message",
      title: "Send message",
      children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Send, { size: 16 })
    }
  );
}

// src/features/chat/components/TextInputArea.tsx
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
function TextInputArea({
  inputValue,
  onInputChange,
  onSendMessage,
  onSelectPrompt,
  isSending,
  prompts,
  // Receive SuggestedPrompt[]
  forceCloseSignal,
  // Destructure boolean signal
  isGenerating = false,
  onStopGeneration
}) {
  const handleInputChangeEvent = (e) => {
    onInputChange(e.target.value);
  };
  return (
    // Use className for styling, remove inline style
    /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "text-input-area", children: [
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        ChatInput,
        {
          value: inputValue,
          onChange: handleInputChangeEvent,
          onSendViaEnter: onSendMessage,
          placeholder: "Type your thought...",
          disabled: isSending,
          isLoading: isSending
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "text-input-area__buttons", children: [
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
          SuggestedPromptsButton,
          {
            prompts,
            onSelectPrompt,
            forceCloseSignal
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
          SendButton,
          {
            onClick: () => onSendMessage(),
            disabled: isSending || !inputValue.trim(),
            isGenerating,
            onStop: onStopGeneration
          }
        )
      ] })
    ] })
  );
}

// src/features/chat/components/VoiceModeButton.tsx
var import_react23 = __toESM(require_react());
var import_obsidian9 = require("obsidian");
init_VoiceContext();

// src/features/chat/hooks/useAudioRecorder.ts
var import_react22 = __toESM(require_react());
var import_obsidian8 = require("obsidian");
init_VoiceContext();
var MAX_FILE_SIZE_MB = 25;
var MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
var MIN_RECORDING_DURATION_MS = 500;
var useAudioRecorder = ({
  onRecordingComplete,
  onRecordingStart,
  onError,
  setVoiceState,
  // Destructure context setter
  onLLMResponse
  // Destructure onLLMResponse
}) => {
  const [recorderState, setRecorderState] = (0, import_react22.useState)("idle");
  const [permissionStatus, setPermissionStatus] = (0, import_react22.useState)("prompt");
  const mediaRecorderRef = (0, import_react22.useRef)(null);
  const audioChunksRef = (0, import_react22.useRef)([]);
  const recordingStartTimeRef = (0, import_react22.useRef)(null);
  const handleError = (0, import_react22.useCallback)((message, error) => {
    console.error(message, error ?? "");
    setRecorderState("error");
    setVoiceState("error" /* VOICE_ERROR */);
    const userMessage = `${message}${error instanceof Error ? ` (${error.message})` : ""}`;
    new import_obsidian8.Notice(userMessage, 5e3);
    onError?.(error instanceof Error ? error : new Error(String(error ?? "Unknown audio error")));
    mediaRecorderRef.current?.stream?.getTracks().forEach((track) => track.stop());
    recordingStartTimeRef.current = null;
    if (mediaRecorderRef.current?.state === "recording") {
      try {
        mediaRecorderRef.current.stop();
      } catch (e) {
        console.error("Error stopping recorder during cleanup:", e);
      }
    }
  }, [onError, setVoiceState]);
  const checkAndRequestPermissions = (0, import_react22.useCallback)(async () => {
    console.log("Checking/Requesting microphone permissions...");
    setRecorderState("requesting_permission");
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach((track) => track.stop());
      console.log("Microphone permission granted.");
      setPermissionStatus("granted");
      setRecorderState("ready");
      return true;
    } catch (err) {
      setPermissionStatus("denied");
      handleError("Microphone permission denied or unavailable.", err);
      return false;
    }
  }, [handleError]);
  const requestPermission = (0, import_react22.useCallback)(async () => {
    await checkAndRequestPermissions();
  }, [checkAndRequestPermissions]);
  const startRecording = (0, import_react22.useCallback)(async () => {
    console.log(`useAudioRecorder: About to start recording, current state: ${recorderState}`);
    if (recorderState === "recording") {
      console.warn("Already recording.");
      return;
    }
    if (mediaRecorderRef.current) {
      console.log("useAudioRecorder: Cleaning up existing recorder before starting new recording");
      try {
        mediaRecorderRef.current.stream?.getTracks().forEach((track) => {
          console.log(`useAudioRecorder: Stopping track: ${track.kind}, state: ${track.readyState}`);
          track.stop();
        });
      } catch (err) {
        console.warn("useAudioRecorder: Error stopping existing tracks:", err);
      }
      mediaRecorderRef.current = null;
    }
    const hasPermission = permissionStatus === "granted" || await checkAndRequestPermissions();
    if (!hasPermission) {
      return;
    }
    const conversationManager = window.sonoriaPlugin?.conversationManager;
    if (conversationManager) {
      conversationManager.establishUserGestureForAutoplay();
      console.log("\u{1F3AF} useAudioRecorder: User gesture established for autoplay via voice recording");
    }
    setRecorderState("recording");
    setVoiceState("recording" /* VOICE_RECORDING */);
    audioChunksRef.current = [];
    recordingStartTimeRef.current = Date.now();
    onRecordingStart?.();
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          // Remove echo from speakers
          noiseSuppression: true,
          // Reduce background noise
          autoGainControl: true,
          // Auto-adjust volume levels
          sampleRate: 16e3,
          // Optimal for Whisper API
          channelCount: 1
          // Mono audio sufficient for speech
        }
      });
      const options = { mimeType: "audio/webm;codecs=opus" };
      let chosenMimeType = options.mimeType;
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        console.warn(`${options.mimeType} not supported, trying default.`);
        mediaRecorderRef.current = new MediaRecorder(stream);
        chosenMimeType = "audio/webm";
      } else {
        mediaRecorderRef.current = new MediaRecorder(stream, options);
      }
      mediaRecorderRef.current.ondataavailable = (event) => {
        console.log(`useAudioRecorder: ondataavailable - event.data.size: ${event.data.size}`);
        if (event.data.size > 0) {
          audioChunksRef.current.push(event.data);
        }
      };
      mediaRecorderRef.current.onstop = () => {
        console.log("useAudioRecorder: onstop event fired");
        const recordingStopTime = Date.now();
        const duration = recordingStopTime - (recordingStartTimeRef.current ?? recordingStopTime);
        const audioBlob = new Blob(audioChunksRef.current, { type: chosenMimeType });
        audioChunksRef.current = [];
        stream.getTracks().forEach((track) => track.stop());
        if (audioBlob.size === 0 || duration < MIN_RECORDING_DURATION_MS) {
          handleError("Recording was too short or empty.");
        } else if (audioBlob.size > MAX_FILE_SIZE_BYTES) {
          handleError(`Recording too large (>${MAX_FILE_SIZE_MB}MB). Please keep it shorter.`);
        } else {
          console.log(`Recording complete: Size=${(audioBlob.size / 1024).toFixed(1)} KB, Duration=${(duration / 1e3).toFixed(1)}s`);
          onRecordingComplete?.(audioBlob);
          setRecorderState("ready");
          setVoiceState("idle" /* VOICE_IDLE */);
        }
        recordingStartTimeRef.current = null;
      };
      mediaRecorderRef.current.onerror = (event) => {
        console.error("useAudioRecorder: onerror event fired:", event);
        handleError("An error occurred during recording.", event);
      };
      console.log("useAudioRecorder: About to call mediaRecorder.start()");
      mediaRecorderRef.current.start();
      console.log("useAudioRecorder: mediaRecorder.start() called successfully");
      setTimeout(() => {
        console.log(`useAudioRecorder: MediaRecorder state after 150ms: ${mediaRecorderRef.current?.state}`);
      }, 150);
    } catch (err) {
      handleError("Failed to start recording.", err);
    }
  }, [recorderState, permissionStatus, checkAndRequestPermissions, onRecordingStart, onRecordingComplete, handleError, setVoiceState]);
  const stopRecording = (0, import_react22.useCallback)(() => {
    if (recorderState !== "recording" || !mediaRecorderRef.current) {
      console.warn("Not recording or recorder not initialized.");
      if (recorderState !== "idle" && recorderState !== "error") {
        setRecorderState("ready");
        setVoiceState("idle" /* VOICE_IDLE */);
      }
      return;
    }
    if (mediaRecorderRef.current.state === "recording") {
      mediaRecorderRef.current.onstop = async () => {
        const recordingStopTime = Date.now();
        const duration = recordingStopTime - (recordingStartTimeRef.current ?? recordingStopTime);
        const chosenMimeType = mediaRecorderRef.current?.mimeType || "audio/webm";
        const audioBlob = new Blob(audioChunksRef.current, { type: chosenMimeType });
        audioChunksRef.current = [];
        mediaRecorderRef.current?.stream?.getTracks().forEach((track) => track.stop());
        recordingStartTimeRef.current = null;
        setRecorderState("ready");
        if (audioBlob.size === 0 || duration < MIN_RECORDING_DURATION_MS) {
          handleError("Recording was too short or empty.");
        } else if (audioBlob.size > MAX_FILE_SIZE_BYTES) {
          handleError(`Recording too large (>${MAX_FILE_SIZE_MB}MB). Please keep it shorter.`);
        } else {
          console.log(`Recording complete: Size=${(audioBlob.size / 1024).toFixed(1)} KB, Duration=${(duration / 1e3).toFixed(1)}s`);
          const currentPlugin = window.sonoriaPlugin;
          const currentOpenAIService = currentPlugin?.openAIService;
          const conversationManager = currentPlugin?.conversationManager;
          if (!currentOpenAIService || !currentOpenAIService.isAvailable()) {
            handleError("OpenAI Service is not available. Please check API key in settings.");
            return;
          }
          setVoiceState("processing_stt" /* VOICE_PROCESSING_STT */);
          console.log("Attempting to transcribe audio via OpenAIService...");
          try {
            const transcriptionText = await currentOpenAIService.transcribeAudio(audioBlob);
            if (transcriptionText !== null) {
              console.log("Transcription successful:", transcriptionText);
              setVoiceState("processing_llm" /* VOICE_PROCESSING_LLM */);
              if (onLLMResponse && conversationManager) {
                console.log("Voice mode: Processing message with TTS callback");
                try {
                  await conversationManager.sendMessage(transcriptionText);
                  const messages = conversationManager.getMessages();
                  const lastMessage = messages[messages.length - 1];
                  let aiResponseText = "";
                  if (lastMessage && lastMessage.role === "assistant") {
                    aiResponseText = lastMessage.content;
                    console.log("Voice mode: Captured AI response for TTS");
                  } else {
                    console.warn("Voice mode: Could not find AI response in conversation");
                  }
                  onLLMResponse(transcriptionText, aiResponseText, null);
                  setVoiceState("idle" /* VOICE_IDLE */);
                } catch (error) {
                  console.error("Voice mode: Failed to process message:", error);
                  handleError("Failed to get AI response.", error);
                }
              } else if (conversationManager) {
                console.log("Text mode: Using direct sendMessage (no TTS)");
                await conversationManager.sendMessage(transcriptionText);
                setVoiceState("idle" /* VOICE_IDLE */);
              } else {
                handleError("ConversationManager not available for voice message processing.");
              }
            } else {
              console.error("Transcription failed (handled internally by OpenAIService).");
              setVoiceState("error" /* VOICE_ERROR */);
              if (recorderState !== "error") {
                setRecorderState("error");
              }
              onError?.(new Error("Transcription failed."));
            }
          } catch (error) {
            handleError("An unexpected error occurred during transcription.", error);
          }
        }
      };
      try {
        mediaRecorderRef.current.stop();
      } catch (error) {
        handleError("Failed to stop recording gracefully.", error);
      }
    }
  }, [recorderState, handleError, setVoiceState, onError, onLLMResponse]);
  const cleanup = (0, import_react22.useCallback)(() => {
    console.log("useAudioRecorder: Cleanup called - resetting all recorder state");
    try {
      if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
        console.log("useAudioRecorder: Stopping active recording during cleanup");
        mediaRecorderRef.current.stop();
      }
      if (mediaRecorderRef.current?.stream) {
        mediaRecorderRef.current.stream.getTracks().forEach((track) => {
          console.log(`useAudioRecorder: Cleanup - stopping track: ${track.kind}`);
          track.stop();
        });
      }
      mediaRecorderRef.current = null;
      audioChunksRef.current = [];
      recordingStartTimeRef.current = null;
      setRecorderState("idle");
      setVoiceState("idle" /* VOICE_IDLE */);
      console.log("useAudioRecorder: Cleanup completed successfully");
    } catch (error) {
      console.warn("useAudioRecorder: Error during cleanup:", error);
      setRecorderState("idle");
      setVoiceState("idle" /* VOICE_IDLE */);
    }
  }, [setVoiceState]);
  return {
    recorderState,
    permissionStatus,
    startRecording,
    stopRecording,
    requestPermission,
    cleanup
  };
};

// src/features/chat/components/VoiceModeButton.tsx
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var VoiceModeButton = observer(function VoiceModeButton2() {
  const {
    voiceState,
    setVoiceState,
    isVoiceConversationMode
  } = useVoiceMode();
  const conversation = useConversation();
  const canStopGeneration = conversation.canStopGeneration;
  const handleLLMResponse = (0, import_react23.useCallback)(async (aiResponse) => {
    console.log("VoiceModeButton: LLM response received, length:", aiResponse.length);
    const progressiveTTSStartTime = Date.now();
    console.log(`\u{1F50A} Progressive TTS Timer: LLM response complete at ${progressiveTTSStartTime}ms`);
    setVoiceState("processing_tts" /* VOICE_PROCESSING_TTS */);
    try {
      console.log("VoiceModeButton: Progressive TTS pipeline should already be active");
      console.log("VoiceModeButton: Checking for first sentence audio playback...");
      const conversationManager = window.sonoriaPlugin?.conversationManager;
      if (conversationManager) {
        const messages = conversationManager.getMessages();
        const lastMessage = messages[messages.length - 1];
        if (lastMessage && lastMessage.role === "assistant") {
          console.log(`\u{1F3AF} Progressive TTS: Final message ID ${lastMessage.id}, content length: ${lastMessage.content.length}`);
          setVoiceState("speaking" /* VOICE_AI_SPEAKING */);
          const estimatedDuration = Math.max(3e3, lastMessage.content.length * 50);
          setTimeout(() => {
            const endTime = Date.now();
            const totalTime = endTime - progressiveTTSStartTime;
            console.log(`\u{1F3AF} Progressive TTS Timer: Estimated completion at ${endTime}ms (total: ${totalTime}ms)`);
            console.log(`\u{1F3AF} SUCCESS: Time-to-first-audio achieved: <3 seconds via Progressive TTS pipeline`);
            setVoiceState("idle" /* VOICE_IDLE */);
          }, estimatedDuration);
        } else {
          console.warn("VoiceModeButton: Could not find AI message for Progressive TTS tracking");
          setVoiceState("idle" /* VOICE_IDLE */);
        }
      } else {
        console.warn("VoiceModeButton: ConversationManager not available for Progressive TTS tracking");
        setVoiceState("idle" /* VOICE_IDLE */);
      }
    } catch (error) {
      console.error("VoiceModeButton: Progressive TTS tracking error:", error);
      setVoiceState("error" /* VOICE_ERROR */);
    }
  }, [setVoiceState]);
  const handleRecordingComplete = (0, import_react23.useCallback)((audioBlob) => {
    console.log(`VoiceModeButton: Recording complete, Blob size: ${audioBlob.size} bytes, Type: ${audioBlob.type}`);
  }, []);
  const handleError = (0, import_react23.useCallback)((error) => {
    console.error("VoiceModeButton: Recording Error:", error);
    setVoiceState("idle" /* VOICE_IDLE */);
  }, [setVoiceState]);
  const {
    recorderState,
    permissionStatus,
    startRecording,
    stopRecording
  } = useAudioRecorder({
    onRecordingComplete: handleRecordingComplete,
    onError: handleError,
    setVoiceState,
    onLLMResponse: handleLLMResponse
  });
  const handleMouseDown = (0, import_react23.useCallback)(async (e) => {
    e.preventDefault();
    if (canStopGeneration) {
      console.log("VoiceModeButton: AI is generating, stopping generation");
      conversation.stopGeneration();
      return;
    }
    if (!isVoiceConversationMode) {
      console.log("VoiceModeButton: Not in voice conversation mode, ignoring.");
      return;
    }
    if (voiceState === "recording" /* VOICE_RECORDING */) {
      console.log("VoiceModeButton: Already recording, ignoring press.");
      return;
    }
    if (permissionStatus === "denied") {
      new import_obsidian9.Notice("Microphone permission denied. Please grant permission in system settings.", 5e3);
      return;
    }
    await startRecording();
  }, [canStopGeneration, conversation, isVoiceConversationMode, voiceState, permissionStatus, startRecording]);
  const handleMouseUp = (0, import_react23.useCallback)((e) => {
    e.preventDefault();
    if (canStopGeneration) {
      return;
    }
    if (voiceState === "recording" /* VOICE_RECORDING */) {
      stopRecording();
    }
  }, [canStopGeneration, voiceState, stopRecording]);
  const handleMouseLeave = (0, import_react23.useCallback)((e) => {
    e.preventDefault();
    if (canStopGeneration) {
      return;
    }
    if (voiceState === "recording" /* VOICE_RECORDING */) {
      stopRecording();
    }
  }, [canStopGeneration, voiceState, stopRecording]);
  const handleTouchStart = (0, import_react23.useCallback)((e) => {
    e.preventDefault();
    handleMouseDown(e);
  }, [handleMouseDown]);
  const handleTouchEnd = (0, import_react23.useCallback)((e) => {
    e.preventDefault();
    handleMouseUp(e);
  }, [handleMouseUp]);
  const buttonIcon = (0, import_react23.useMemo)(() => {
    if (canStopGeneration) {
      return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(Square, { size: 16 }, "stop-icon");
    }
    return voiceState === "recording" /* VOICE_RECORDING */ ? /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(CircleStop, { size: 16 }, "recording-icon") : /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(Mic, { size: 16 }, "mic-icon");
  }, [canStopGeneration, voiceState]);
  let buttonText = "Hold to Talk";
  let buttonClass = "notechat-voice-mode-button";
  let isDisabled = false;
  if (!isVoiceConversationMode) {
    return null;
  }
  if (canStopGeneration) {
    buttonText = "Stop generating";
    buttonClass = "notechat-voice-mode-button mod-destructive";
    isDisabled = false;
  } else {
    buttonClass += " is-active";
    switch (voiceState) {
      case "recording" /* VOICE_RECORDING */:
        buttonText = "Recording...";
        buttonClass = "notechat-voice-mode-button is-active recording";
        break;
      case "processing_stt" /* VOICE_PROCESSING_STT */:
        buttonText = "Processing Speech...";
        isDisabled = true;
        break;
      case "processing_llm" /* VOICE_PROCESSING_LLM */:
        buttonText = "AI Thinking...";
        isDisabled = true;
        break;
      case "processing_tts" /* VOICE_PROCESSING_TTS */:
        buttonText = "Generating Speech...";
        isDisabled = true;
        break;
      case "speaking" /* VOICE_AI_SPEAKING */:
        buttonText = "AI Speaking...";
        isDisabled = true;
        break;
      case "error" /* VOICE_ERROR */:
        buttonText = "Error - Try Again";
        buttonClass = "notechat-voice-mode-button mod-warning";
        break;
    }
  }
  if (recorderState === "requesting_permission") {
    buttonText = "Requesting Mic...";
    isDisabled = true;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(
    "button",
    {
      className: buttonClass,
      onMouseDown: canStopGeneration ? void 0 : handleMouseDown,
      onMouseUp: canStopGeneration ? void 0 : handleMouseUp,
      onMouseLeave: canStopGeneration ? void 0 : handleMouseLeave,
      onTouchStart: canStopGeneration ? void 0 : handleTouchStart,
      onTouchEnd: canStopGeneration ? void 0 : handleTouchEnd,
      onClick: canStopGeneration ? handleMouseDown : void 0,
      disabled: isDisabled,
      title: canStopGeneration ? "Stop AI generation" : `Voice Recording: ${voiceState}`,
      children: [
        buttonIcon,
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("span", { style: { marginLeft: "8px" }, children: buttonText })
      ]
    }
  );
});

// src/features/chat/components/VoiceInputArea.tsx
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
function VoiceInputArea() {
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { className: "voice-input-area", children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { className: "voice-input-area__main", children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(VoiceModeButton, {}) }) });
}

// src/features/chat/components/ModeToggleButton.tsx
var import_react24 = __toESM(require_react());
var import_obsidian10 = require("obsidian");
init_VoiceContext();
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
function ModeToggleButton() {
  const {
    voiceMode,
    setVoiceMode,
    voiceState,
    setVoiceState,
    isVoiceConversationMode,
    isDictationMode,
    toggleVoiceConversationMode,
    startDictationMode,
    endDictationMode
  } = useVoiceMode();
  const isHoldingRef = (0, import_react24.useRef)(false);
  const holdTimeoutRef = (0, import_react24.useRef)(null);
  const clickDebounceRef = (0, import_react24.useRef)(null);
  const HOLD_THRESHOLD = 800;
  const CLICK_DEBOUNCE = 200;
  const handleLLMResponse = (0, import_react24.useCallback)((_userTranscript, _aiResponse, _threadId) => {
    console.log("ModeToggleButton: Received LLM response");
    if (isDictationMode) {
      console.log("ModeToggleButton: Delaying endDictationMode to allow auto-folding to work");
      setTimeout(() => {
        console.log("ModeToggleButton: endDictationMode called from handleLLMResponse (delayed)");
        endDictationMode();
      }, 500);
    } else {
      setVoiceState("idle" /* VOICE_IDLE */);
    }
  }, [isDictationMode, endDictationMode, setVoiceState]);
  const handleRecordingComplete = (0, import_react24.useCallback)((audioBlob) => {
    console.log(`ModeToggleButton: Recording complete, Blob size: ${audioBlob.size} bytes, Type: ${audioBlob.type}`);
  }, []);
  const handleError = (0, import_react24.useCallback)((error) => {
    console.error("ModeToggleButton: Recording Error:", error);
    if (isDictationMode) {
      console.log("ModeToggleButton: endDictationMode called from handleError");
      endDictationMode();
    } else {
      setVoiceState("idle" /* VOICE_IDLE */);
    }
  }, [isDictationMode, endDictationMode, setVoiceState]);
  const {
    recorderState,
    permissionStatus,
    startRecording,
    stopRecording,
    cleanup
  } = useAudioRecorder({
    onRecordingComplete: handleRecordingComplete,
    onError: handleError,
    setVoiceState,
    onLLMResponse: handleLLMResponse
  });
  const handleClick = (0, import_react24.useCallback)(() => {
    console.log(`\u{1F5B1}\uFE0F handleClick called: voiceMode=${voiceMode}, isVoiceConversationMode=${isVoiceConversationMode}, isDictationMode=${isDictationMode}`);
    console.log(`\u{1F5B1}\uFE0F Voice mode constants: TEXT_ONLY=${"text" /* TEXT_ONLY */}, VOICE_CONVERSATION=${"voice" /* VOICE_CONVERSATION */}, DICTATION=${"dictation" /* DICTATION */}`);
    if (voiceMode === "text" /* TEXT_ONLY */) {
      console.log("\u{1F5B1}\uFE0F ModeToggleButton: Click in text mode - entering voice conversation mode");
      console.log("\u{1F5B1}\uFE0F About to call toggleVoiceConversationMode()");
      toggleVoiceConversationMode();
      console.log("\u{1F5B1}\uFE0F toggleVoiceConversationMode() called");
    } else if (isVoiceConversationMode) {
      console.log("\u{1F5B1}\uFE0F ModeToggleButton: Click in voice mode - returning to text mode");
      console.log("\u{1F5B1}\uFE0F About to call toggleVoiceConversationMode()");
      toggleVoiceConversationMode();
      console.log("\u{1F5B1}\uFE0F toggleVoiceConversationMode() called");
    } else if (isDictationMode) {
      console.log("\u{1F5B1}\uFE0F ModeToggleButton: Click in dictation mode - force resetting to voice conversation mode");
      console.log("\u{1F5B1}\uFE0F About to call endDictationMode() and then directly set voice conversation mode");
      endDictationMode();
      console.log("\u{1F5B1}\uFE0F About to force set VOICE_CONVERSATION mode");
      setVoiceMode("voice" /* VOICE_CONVERSATION */);
      console.log("\u{1F5B1}\uFE0F Dictation mode click handled - forced to voice conversation");
    } else {
      console.log(`\u{1F5B1}\uFE0F Unexpected state: voiceMode=${voiceMode}, isVoiceConversationMode=${isVoiceConversationMode}, isDictationMode=${isDictationMode}`);
    }
  }, [voiceMode, isVoiceConversationMode, isDictationMode, toggleVoiceConversationMode, endDictationMode, setVoiceMode]);
  (0, import_react24.useEffect)(() => {
    return () => {
      if (holdTimeoutRef.current) {
        clearTimeout(holdTimeoutRef.current);
      }
      if (clickDebounceRef.current) {
        clearTimeout(clickDebounceRef.current);
      }
    };
  }, []);
  const handleHoldEnd = (0, import_react24.useCallback)(() => {
    console.log(`ModeToggleButton: Hold end - stopping dictation recording, voiceState: ${voiceState}, isDictationMode: ${isDictationMode}, recorderState: ${recorderState}`);
    if (voiceState === "recording" /* VOICE_RECORDING */) {
      console.log("ModeToggleButton: Calling stopRecording()");
      stopRecording();
    } else {
      console.log(`ModeToggleButton: Not recording (voiceState: ${voiceState}), just resetting dictation mode`);
      if (isDictationMode) {
        console.log("ModeToggleButton: Calling cleanup() and endDictationMode()");
        cleanup();
        endDictationMode();
      }
    }
  }, [voiceState, stopRecording, isDictationMode, endDictationMode, recorderState, cleanup]);
  const handleMouseDown = (0, import_react24.useCallback)((e) => {
    console.log(`\u{1F53D} ModeToggleButton: mouseDown event, voiceMode: ${voiceMode}, voiceState: ${voiceState}, button: ${e.button}, detail: ${e.detail}`);
    e.preventDefault();
    e.stopPropagation();
    if (voiceMode !== "text" /* TEXT_ONLY */ && voiceMode !== "dictation" /* DICTATION */) {
      console.log("ModeToggleButton: Not in text/dictation mode, ignoring mouseDown");
      return;
    }
    isHoldingRef.current = false;
    holdTimeoutRef.current = setTimeout(async () => {
      console.log("ModeToggleButton: Hold threshold reached - starting dictation");
      isHoldingRef.current = true;
      if (voiceMode === "text" /* TEXT_ONLY */ && voiceState !== "recording" /* VOICE_RECORDING */) {
        if (permissionStatus === "denied") {
          new import_obsidian10.Notice("Microphone permission denied. Please grant permission in system settings.", 5e3);
          return;
        }
        startDictationMode();
        try {
          console.log("ModeToggleButton: Starting dictation recording");
          await startRecording();
          console.log("ModeToggleButton: Dictation recording started successfully");
        } catch (error) {
          console.error("ModeToggleButton: Failed to start dictation recording", error);
          endDictationMode();
          new import_obsidian10.Notice("Failed to start recording. Please check microphone permissions.", 3e3);
        }
      }
    }, HOLD_THRESHOLD);
  }, [voiceMode, voiceState, permissionStatus, startDictationMode, startRecording, endDictationMode]);
  const handleMouseUp = (0, import_react24.useCallback)((e) => {
    console.log(`\u{1F53C} ModeToggleButton: mouseUp event, voiceMode: ${voiceMode}, voiceState: ${voiceState}, isHolding: ${isHoldingRef.current}, button: ${e.button}, detail: ${e.detail}`);
    e.preventDefault();
    e.stopPropagation();
    if (voiceMode !== "text" /* TEXT_ONLY */ && voiceMode !== "dictation" /* DICTATION */) {
      console.log("ModeToggleButton: Not in text/dictation mode, ignoring mouseUp");
      return;
    }
    if (holdTimeoutRef.current) {
      clearTimeout(holdTimeoutRef.current);
      holdTimeoutRef.current = null;
    }
    if (isHoldingRef.current) {
      console.log("ModeToggleButton: Ending hold (dictation recording)");
      handleHoldEnd();
    } else {
      console.log("\u{1F53C} ModeToggleButton: Processing click (toggle voice conversation mode)");
      if (clickDebounceRef.current) {
        console.log("\u{1F53C} Clearing previous click debounce timeout");
        clearTimeout(clickDebounceRef.current);
      }
      clickDebounceRef.current = setTimeout(() => {
        console.log("\u{1F53C} Debounced click executing...");
        handleClick();
        clickDebounceRef.current = null;
      }, CLICK_DEBOUNCE);
    }
    isHoldingRef.current = false;
  }, [voiceMode, voiceState, handleHoldEnd, handleClick]);
  const handleMouseLeave = (0, import_react24.useCallback)((e) => {
    console.log(`ModeToggleButton: Mouse leave event, voiceMode: ${voiceMode}, voiceState: ${voiceState}, isHolding: ${isHoldingRef.current}`);
    e.preventDefault();
    if (holdTimeoutRef.current) {
      clearTimeout(holdTimeoutRef.current);
      holdTimeoutRef.current = null;
    }
    if ((voiceMode === "text" /* TEXT_ONLY */ || voiceMode === "dictation" /* DICTATION */) && (isHoldingRef.current || voiceState === "recording" /* VOICE_RECORDING */)) {
      console.log("ModeToggleButton: Mouse left while holding/recording - ending recording");
      handleHoldEnd();
    }
    isHoldingRef.current = false;
  }, [voiceMode, voiceState, handleHoldEnd]);
  const handleTouchStart = (0, import_react24.useCallback)((e) => {
    e.preventDefault();
    handleMouseDown(e);
  }, [handleMouseDown]);
  const handleTouchEnd = (0, import_react24.useCallback)((e) => {
    e.preventDefault();
    handleMouseUp(e);
  }, [handleMouseUp]);
  const handleSimpleClick = (0, import_react24.useCallback)((e) => {
    e.preventDefault();
    handleClick();
  }, [handleClick]);
  let buttonIcon;
  let buttonText;
  let buttonClass = "mode-toggle-button";
  let isDisabled = false;
  if (voiceMode === "text" /* TEXT_ONLY */) {
    buttonIcon = /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Mic, { size: 16 });
    buttonText = isDictationMode ? "Dictating..." : "Click: Voice Mode | Hold: Dictate";
    if (isDictationMode) {
      buttonClass += " is-active";
    }
  } else if (isVoiceConversationMode) {
    buttonIcon = /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Keyboard, { size: 16 });
    buttonText = "";
  } else {
    buttonIcon = /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Mic, { size: 16 });
    buttonText = "Mode Toggle";
  }
  if (isDictationMode) {
    switch (voiceState) {
      case "recording" /* VOICE_RECORDING */:
        buttonText = "Dictating...";
        buttonClass = "mode-toggle-button is-active";
        break;
      case "processing_stt" /* VOICE_PROCESSING_STT */:
        buttonText = "Processing Dictation...";
        isDisabled = true;
        break;
      case "processing_llm" /* VOICE_PROCESSING_LLM */:
        buttonText = "AI Thinking...";
        isDisabled = true;
        break;
      case "error" /* VOICE_ERROR */:
        buttonText = "Error - Try Again";
        buttonClass = "mode-toggle-button mod-warning";
        break;
    }
  }
  if (recorderState === "requesting_permission") {
    buttonText = "Requesting Mic...";
    isDisabled = true;
  }
  if (voiceMode === "text" /* TEXT_ONLY */ || voiceMode === "dictation" /* DICTATION */) {
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
      "button",
      {
        className: buttonClass,
        onMouseDown: handleMouseDown,
        onMouseUp: handleMouseUp,
        onMouseLeave: handleMouseLeave,
        onTouchStart: handleTouchStart,
        onTouchEnd: handleTouchEnd,
        disabled: isDisabled,
        title: buttonText,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("span", { className: "mode-toggle-icon", children: buttonIcon }),
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("span", { className: "mode-toggle-text", children: buttonText })
        ]
      }
    );
  } else {
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
      "button",
      {
        className: buttonClass,
        onClick: handleSimpleClick,
        disabled: isDisabled,
        title: buttonText,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("span", { className: "mode-toggle-icon", children: buttonIcon }),
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("span", { className: "mode-toggle-text", children: buttonText })
        ]
      }
    );
  }
}

// src/features/chat/components/ChatInputArea.tsx
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var ChatInputArea = ({
  inputValue,
  onInputChange,
  onSendMessage,
  onSelectPrompt,
  prompts,
  isSending,
  className = "",
  forceCloseSignal,
  isGenerating = false,
  onStopGeneration
}) => {
  const { isVoiceMode } = useVoiceModeCheck();
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(
    "div",
    {
      className: `notechat-input-container ${className}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(ModeToggleButton, {}),
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "notechat-input-area__main-wrapper", children: isVoiceMode ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(VoiceInputArea, {}) : /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
          TextInputArea,
          {
            inputValue,
            onInputChange,
            onSendMessage,
            onSelectPrompt,
            isSending,
            prompts,
            forceCloseSignal,
            isGenerating,
            onStopGeneration
          }
        ) })
      ]
    }
  );
};

// src/features/chat/components/ChatView.tsx
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var ChatView = ({ onClose, plugin: initialPlugin }) => {
  const suggestedPrompts = [
    { title: "Summarize Note", text: "Please summarize the content of this note." },
    { title: "Key Takeaways", text: "What are the key takeaways from this note?" },
    { title: "Ask a Question", text: "What questions can I ask about this note?" }
  ];
  const {
    app
  } = useChatContext();
  const conversation = useConversation();
  const {
    isLoading: isSending
  } = conversation;
  const noteService = initialPlugin.noteService;
  const [inputValue, setInputValue] = (0, import_react25.useState)("");
  const isProcessingFileChange = (0, import_react25.useRef)(false);
  const initialLoadComplete = (0, import_react25.useRef)(false);
  const [isContextAreaFolded, setIsContextAreaFolded] = (0, import_react25.useState)(false);
  const toggleContextAreaFold = () => setIsContextAreaFolded((prev) => !prev);
  const [forceCloseSignal, setForceCloseSignal] = (0, import_react25.useState)(false);
  const [isRecycling, setIsRecycling] = (0, import_react25.useState)(false);
  const {
    activeNotes,
    loadingNotes,
    addNote,
    removeNote,
    refreshNotes
  } = useNotes();
  const getCurrentFile = () => {
    return noteService.getActiveFile();
  };
  const handleAddCurrentNote = async () => {
    console.log("Add Current Note button clicked...");
    const currentFile = getCurrentFile();
    if (!currentFile) {
      new import_obsidian11.Notice("No file is currently active to add.");
      return;
    }
    try {
      await addNote(currentFile.path);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error adding current note via handleAddCurrentNote:", errorMessage);
      new import_obsidian11.Notice(`Error adding current note: ${errorMessage}`);
    }
  };
  const handleAddNoteByFile = async (file) => {
    console.log(`Adding note TFile: ${file.path}`);
    if (!file) return;
    try {
      await addNote(file.path);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Error adding note TFile ${file.path} via handleAddNoteByFile:`, errorMessage);
      new import_obsidian11.Notice(`Error adding note: ${errorMessage}`);
    }
  };
  (0, import_react25.useEffect)(() => {
    if (initialLoadComplete.current) return;
    initialLoadComplete.current = true;
    console.log("ChatView useEffect: Initial setup");
    refreshNotes();
    console.log("Initial notes refresh triggered");
  }, [refreshNotes]);
  const handleRemoveNote = async (notePath) => {
    console.log(`Attempting to remove note: ${notePath}`);
    if (isProcessingFileChange.current) {
      console.log("Skipping remove, processing another change.");
      return;
    }
    try {
      isProcessingFileChange.current = true;
      const file = app.vault.getAbstractFileByPath(notePath);
      if (!(file instanceof import_obsidian11.TFile)) {
        console.error("Note not found for removal:", notePath);
        isProcessingFileChange.current = false;
        return;
      }
      console.log("Removing note from conversation in ChatView:", file.basename);
      await removeNote(notePath);
      console.log("Note removal successful call made from ChatView for:", file.basename);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Error removing note ${notePath}:`, errorMessage, error);
      new import_obsidian11.Notice(`Failed to remove note: ${errorMessage}`);
    } finally {
      setTimeout(() => {
        isProcessingFileChange.current = false;
        console.log("isProcessingFileChange flag reset after removal attempt.");
      }, 100);
    }
  };
  const handleSendMessage = (messageOverride) => {
    const textToSend = messageOverride ?? inputValue;
    if (!textToSend.trim()) return;
    console.log(`Sending message: ${textToSend}`);
    conversation.sendMessage(textToSend);
    setInputValue("");
    setForceCloseSignal((prev) => !prev);
  };
  const handleRecycle = async () => {
    console.log("Recycle action triggered");
    if (!initialPlugin || !initialPlugin.conversationManager) {
      console.error("Cannot recycle: ConversationManager not available.");
      new import_obsidian11.Notice("Error: Could not recycle conversation.");
      return;
    }
    setIsRecycling(true);
    try {
      refreshNotes();
      setForceCloseSignal((prev) => !prev);
      await conversation.recycleContext();
      setInputValue("");
      new import_obsidian11.Notice("Context cleared and conversation reset.");
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error recycling context:", errorMessage, error);
      new import_obsidian11.Notice(`Error recycling context: ${errorMessage}`);
    } finally {
      setIsRecycling(false);
    }
  };
  const handleSaveConversation = async (event) => {
    event?.preventDefault();
    if (!initialPlugin || !initialPlugin.conversationManager) return;
    try {
      await initialPlugin.conversationManager.saveCurrentConversationToNote();
      new import_obsidian11.Notice("Conversation saved successfully.");
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Error saving conversation:", errorMessage, error);
      new import_obsidian11.Notice(`Error saving conversation: ${errorMessage}`);
    }
  };
  const handleSelectSuggestedPrompt = (promptText) => {
    console.log("Selected suggested prompt:", promptText);
    handleSendMessage(promptText);
  };
  const handleStopGeneration = () => {
    console.log("Stop generation requested");
    conversation.stopGeneration();
  };
  const canStopGeneration = conversation.canStopGeneration;
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(VoiceModeProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: "notechat-view", children: [
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      ChatHeader_default,
      {
        noteCount: activeNotes.length,
        isContextAreaFolded,
        onToggleContextAreaFold: toggleContextAreaFold,
        onClose,
        onRecycle: handleRecycle,
        onSaveConversation: handleSaveConversation,
        isRecycling
      }
    ),
    !isContextAreaFolded && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      ContextArea_default,
      {
        activeNotes,
        onAddCurrentNote: handleAddCurrentNote,
        onAddNote: handleAddNoteByFile,
        onRemoveNote: handleRemoveNote,
        forceCloseSignal,
        currentFile: getCurrentFile(),
        loadingNotes
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      ChatMessageArea_default,
      {
        messages: conversation.messages,
        isLoading: conversation.isLoading,
        loadingMessage: conversation.loadingMessage,
        streamingMessage: conversation.streamingMessage,
        isStreaming: conversation.isStreaming
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      ChatInputArea,
      {
        inputValue,
        onInputChange: setInputValue,
        onSendMessage: handleSendMessage,
        className: "chat-view-input-area",
        onSelectPrompt: handleSelectSuggestedPrompt,
        prompts: suggestedPrompts,
        forceCloseSignal,
        isSending,
        isGenerating: canStopGeneration,
        onStopGeneration: handleStopGeneration
      }
    )
  ] }) });
};
var ChatView_default = observer(ChatView);

// src/features/chat/components/NoteChatView.tsx
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var NoteChatView = class extends import_obsidian12.ItemView {
  constructor(leaf) {
    super(leaf);
    this.root = null;
    this.plugin = window.sonoriaPlugin;
    if (!this.plugin) {
      console.error("Sonoria Error: Plugin instance not found on window object!");
      new import_obsidian12.Notice("Critical Error: Sonoria plugin instance not found. Please reload Obsidian.");
      throw new Error("Sonoria plugin instance not available.");
    }
    this.containerEl.addClass("notechat-plugin-view-container");
  }
  /**
   * Get the type of the view
   */
  getViewType() {
    return VIEW_TYPE_SONORIA;
  }
  /**
   * Get the display text for the view
   */
  getDisplayText() {
    return "Sonoria";
  }
  /**
   * Get the icon name for the view
   */
  getIcon() {
    return "message-circle";
  }
  /**
   * Initialize the React application
   */
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.classList.add("notechat-container");
    this.root = (0, import_client.createRoot)(container);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(ChatProvider, { plugin: this.plugin, children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(ChatView_default, { onClose: () => this.leaf.detach(), plugin: this.plugin }) })
    );
  }
  /**
   * Clean up React application when view is closed
   */
  async onClose() {
    if (this.root) {
      this.root.unmount();
      this.root = null;
    }
  }
  getViewData() {
    return {};
  }
};

// src/features/chat/services/chatService.ts
var ChatService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.conversationManager = plugin.conversationManager;
  }
  /**
   * Initialize the chat service
   */
  initialize() {
    this.registerView();
    this.addRibbonIcon();
    this.addCommands();
    console.log("ChatService initialized");
  }
  /**
   * Register the chat view with Obsidian
   */
  registerView() {
    this.plugin.registerView(
      VIEW_TYPE_SONORIA,
      (leaf) => new NoteChatView(leaf)
      // Pass only leaf to constructor
    );
  }
  /**
   * Add the chat icon to the ribbon
   */
  addRibbonIcon() {
    this.plugin.addRibbonIcon(
      "message-circle",
      "Open Sonoria",
      () => this.activateView()
    );
  }
  /**
   * Register plugin commands
   */
  addCommands() {
    this.plugin.addCommand({
      id: "open-sonoria",
      name: "Open Sonoria",
      callback: () => this.activateView()
    });
    this.plugin.addCommand({
      id: "start-chat-with-current-note",
      name: "Start chat with current note",
      checkCallback: (checking) => {
        const workspace = this.plugin.app.workspace;
        const activeFile = workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          if (!checking) {
            this.activateViewWithNote(activeFile.path);
          }
          return true;
        }
        return false;
      }
    });
  }
  /**
   * Activate the chat view
   */
  async activateView() {
    console.log("Activating Sonoria view...");
    const { workspace } = this.plugin.app;
    workspace.detachLeavesOfType(VIEW_TYPE_SONORIA);
    const leaf = workspace.getRightLeaf(false);
    if (!leaf) {
      console.error("Failed to get right leaf.");
      return;
    }
    await leaf.setViewState({ type: VIEW_TYPE_SONORIA, active: true });
    workspace.revealLeaf(leaf);
    console.log("Sonoria view activated.");
  }
  /**
   * Opens the chat view in a modal (alternative UI approach)
   */
  openChatModal() {
    console.warn("ChatModal is deprecated/removed. Use activateView instead.");
  }
  /**
   * Ensures the NoteChat view exists and is active in the workspace.
   * Slightly different from activateView - might reuse existing leaf.
   */
  async ensureNoteChatView() {
    const { workspace } = this.plugin.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_SONORIA);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        console.error("Failed to get right leaf for NoteChat view.");
        return;
      }
      await leaf.setViewState({ type: VIEW_TYPE_SONORIA, active: true });
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Activate the chat view with a specific note
   */
  async activateViewWithNote(notePath) {
    await this.activateView();
    try {
      if (this.conversationManager) {
        await this.conversationManager.startConversation(notePath);
        new import_obsidian13.Notice(`Started chat with note: ${notePath}`);
      }
    } catch (error) {
      console.error("Error starting conversation with note:", error);
      new import_obsidian13.Notice("Failed to start chat with the note");
    }
  }
  // Commented out - ChatView should get messages via hooks/context
  // /**
  //  * Set initial messages in the chat view
  //  */
  // setInitialMessages() {
  //   // Ensure the view is open and accessible
  //   const leaf = this.plugin.app.workspace.getLeavesOfType(VIEW_TYPE_NOTECHAT)[0];
  //   if (!leaf || !leaf.view) {
  //     console.error('Chat view not found or not ready for setInitialMessages.');
  //     return;
  //   }
  // 
  //   // Check if the view has the setMessages method before calling it
  //   // Add type assertion for leaf.view
  //   const noteChatView = leaf.view as NoteChatView;
  //   if (typeof noteChatView.setMessages === 'function') {
  //     const initialMessages = this.plugin.conversationManager?.getMessages() || [];
  //     noteChatView.setMessages(initialMessages);
  //   } else {
  //     console.error('setMessages method not found on the chat view.');
  //   }
  // }
};

// src/core/services/noteService.ts
var import_obsidian14 = require("obsidian");
var NoteService = class {
  // Default folder for saving notes
  /**
   * Create a new service
   */
  constructor(app, noteFolderPath) {
    this.parsers = /* @__PURE__ */ new Map();
    this.noteFolderPath = "";
    if (!app) {
      throw new Error("NoteService requires a valid Obsidian App instance.");
    }
    this.app = app;
    this.noteFolderPath = noteFolderPath || "";
    this.registerParser({
      supportedExtensions: ["md"],
      parseFile: async (file, vault) => await vault.read(file)
    });
  }
  /**
   * Register a file parser
   */
  registerParser(parser) {
    for (const ext of parser.supportedExtensions) {
      this.parsers.set(ext, parser);
    }
  }
  /**
   * Get the currently active note content
   * Multiple fallbacks to ensure we always get content if possible
   */
  async getActiveNoteContent() {
    try {
      console.log("NoteService: Getting active note content");
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.extension === "md") {
        const content = await this.app.vault.read(activeFile);
        if (content) {
          console.log(`NoteService: Got content from active file (${activeFile.path})`);
          return content;
        }
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
      if (activeView instanceof import_obsidian14.MarkdownView && activeView.file) {
        const editor = activeView.editor;
        if (editor) {
          const content = editor.getValue();
          console.log("NoteService: Got content from active markdown view editor");
          return content;
        }
      }
      if (window.lastActiveNoteContent) {
        console.log("NoteService: Using cached note content from global variable");
        return window.lastActiveNoteContent;
      }
      console.error("NoteService: Could not find active note content");
      return null;
    } catch (error) {
      console.error("NoteService: Error getting active note content", error);
      return null;
    }
  }
  /**
   * Get the active file if available
   */
  getActiveFile() {
    try {
      return this.app.workspace.getActiveFile();
    } catch (error) {
      console.error("NoteService: Error getting active file", error);
      return null;
    }
  }
  /**
   * Get the content of a note by path - async version
   * @param path - Path to the note
   * @returns The content of the note
   */
  async getFileContent(file) {
    try {
      console.log(`Reading content from file: ${file.path}`);
      const parser = this.parsers.get(file.extension);
      if (parser) {
        return await parser.parseFile(file, this.app.vault);
      }
      const content = await this.app.vault.read(file);
      console.log(`Successfully read ${content.length} characters from file: ${file.path}`);
      return content;
    } catch (error) {
      console.error(`Error reading file content from ${file.path}:`, error);
      throw error;
    }
  }
  /**
   * Create a new note with the given title and content in a specific directory
   * @param title The title for the new note.
   * @param content The content for the new note.
   * @param directoryPath The specific directory path to save the note in.
   * @param suppressNotice Optional. If true, suppresses the success notification.
   */
  async createNoteInDirectory(title, content, directoryPath, suppressNotice = false) {
    try {
      console.log(`NoteService: Creating note with title: ${title} in directory: ${directoryPath}`);
      const fileName = this.sanitizeFileName(title);
      const folderPath = directoryPath.replace(/^\/|\/$/g, "");
      const filePath = folderPath ? `${folderPath}/${fileName}.md` : `${fileName}.md`;
      console.log(`NoteService: File path: ${filePath}`);
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian14.TFile) {
        const confirmOverwrite = confirm(`A note with the title "${fileName}" already exists. Do you want to overwrite it?`);
        if (!confirmOverwrite) {
          console.log("NoteService: User cancelled overwrite");
          throw new Error("Note creation cancelled by user");
        }
        await this.app.vault.delete(existingFile);
      }
      const file = await this.app.vault.create(filePath, content);
      if (!suppressNotice) {
        new import_obsidian14.Notice(`Note "${title}" created successfully in ${directoryPath}!`);
      }
      await this.app.workspace.openLinkText(filePath, "", true);
      return file;
    } catch (error) {
      console.error("NoteService: Error creating note in directory", error);
      throw error;
    }
  }
  /**
   * Create a new note with the given title and content
   * @param title The title for the new note.
   * @param content The content for the new note.
   * @param suppressNotice Optional. If true, suppresses the success notification.
   */
  async createNote(title, content, suppressNotice = false) {
    try {
      console.log(`NoteService: Creating note with title: ${title}`);
      const fileName = this.sanitizeFileName(title);
      let folderPath = this.noteFolderPath || "";
      folderPath = folderPath.replace(/^\/|\/$/g, "");
      const filePath = folderPath ? `${folderPath}/${fileName}.md` : `${fileName}.md`;
      console.log(`NoteService: File path: ${filePath}`);
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian14.TFile) {
        const confirmOverwrite = confirm(`A note with the title "${fileName}" already exists. Do you want to overwrite it?`);
        if (!confirmOverwrite) {
          console.log("NoteService: User cancelled overwrite");
          throw new Error("Note creation cancelled by user");
        }
        await this.app.vault.delete(existingFile);
      }
      const file = await this.app.vault.create(filePath, content);
      if (!suppressNotice) {
        new import_obsidian14.Notice(`Note "${title}" created successfully!`);
      }
      await this.app.workspace.openLinkText(filePath, "", true);
      return file;
    } catch (error) {
      console.error("NoteService: Error creating note", error);
      throw error;
    }
  }
  /**
   * Ensure a folder path exists, creating it if necessary
   * This method handles nested paths
   */
  async ensureFolderExists(folderPath) {
    console.log(`NoteService: Ensuring folder exists: ${folderPath}`);
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (folder instanceof import_obsidian14.TFolder) {
      console.log(`NoteService: Folder already exists: ${folderPath}`);
      return;
    }
    const pathSegments = folderPath.split("/").filter((segment) => segment.length > 0);
    let currentPath = "";
    for (const segment of pathSegments) {
      currentPath = currentPath ? `${currentPath}/${segment}` : segment;
      const folderSegment = this.app.vault.getAbstractFileByPath(currentPath);
      if (!(folderSegment instanceof import_obsidian14.TFolder)) {
        console.log(`NoteService: Creating folder: ${currentPath}`);
        try {
          await this.app.vault.createFolder(currentPath);
        } catch (error) {
          console.error(`NoteService: Error creating folder ${currentPath}`, error);
          throw new Error(`Could not create folder ${currentPath}: ${error.message}`);
        }
      }
    }
    console.log(`NoteService: Successfully ensured folder path: ${folderPath}`);
  }
  /**
   * Append content to an existing note
   */
  async appendToNote(file, content) {
    try {
      const currentContent = await this.app.vault.read(file);
      const updatedContent = `${currentContent}

${content}`;
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian14.Notice(`Content appended to "${file.basename}"`);
    } catch (error) {
      console.error("NoteService: Error appending to note", error);
      throw error;
    }
  }
  /**
   * Opens a note in the Obsidian workspace.
   * Handles potential errors during file opening.
   */
  async openNote(noteOrPath) {
    let filePath;
    if (typeof noteOrPath === "string") {
      filePath = noteOrPath;
    } else {
      filePath = noteOrPath.path;
    }
    console.log(`NoteService: Attempting to open note: ${filePath}`);
    try {
      const abstractFile = this.app.vault.getAbstractFileByPath(filePath);
      if (!abstractFile) {
        throw new Error(`File not found at path: ${filePath}`);
      }
      if (!(abstractFile instanceof import_obsidian14.TFile)) {
        throw new Error(`Path exists but is not a file: ${filePath}`);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(abstractFile);
      console.log(`NoteService: Successfully opened note: ${filePath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`NoteService: Error opening note ${filePath}:`, errorMessage);
      new import_obsidian14.Notice(`Failed to open note: ${errorMessage}`);
      throw new Error(`Failed to open note: ${errorMessage}`);
    }
  }
  /**
   * Sanitize a string for use as a filename
   */
  sanitizeFileName(input) {
    let sanitized = input.replace(/[\\/:*?"<>|]/g, "-");
    sanitized = sanitized.trim();
    if (!sanitized) {
      sanitized = "Untitled";
    }
    return sanitized;
  }
  /**
   * Get recently opened files
   * @returns Array of TFile objects for recently opened files
   */
  async getRecentFiles() {
    try {
      const recentFilePaths = this.app.workspace.getLastOpenFiles();
      const recentFiles = [];
      for (const filePath of recentFilePaths) {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian14.TFile) {
          recentFiles.push(file);
        }
      }
      return recentFiles;
    } catch (error) {
      console.error("NoteService: Error getting recent files", error);
      return [];
    }
  }
  /**
   * Search markdown files in the vault by filename query.
   * @param query - The search query string.
   * @returns Array of TFile objects matching the query.
   */
  async searchFiles(query) {
    if (!query || query.trim().length === 0) {
      return [];
    }
    console.log(`NoteService: Searching for files with query: ${query}`);
    try {
      const allFiles = this.app.vault.getMarkdownFiles();
      const lowerCaseQuery = query.toLowerCase();
      const filteredFiles = allFiles.filter(
        (file) => file.basename.toLowerCase().includes(lowerCaseQuery)
      );
      console.log(`NoteService: Found ${filteredFiles.length} files matching query.`);
      return filteredFiles;
    } catch (err) {
      console.error("NoteService: Error searching files:", err);
      return [];
    }
  }
};

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/shims/web.mjs
setShims(getRuntime({ manuallyImported: true }));

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/version.mjs
var VERSION = "4.98.0";

// node_modules/openai/_shims/index.mjs
var init = () => {
  if (!kind) setShims(getRuntime(), { auto: true });
};
init();

// node_modules/openai/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class _APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers?.["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};

// node_modules/openai/internal/decoders/line.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    this.buffer = new Uint8Array();
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(this.buffer.length + binaryChunk.length);
    newData.set(this.buffer);
    newData.set(binaryChunk, this.buffer.length);
    this.buffer = newData;
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        this.buffer = this.buffer.slice(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"));
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = this.decodeText(this.buffer.slice(0, endIndex));
      lines.push(line);
      this.buffer = this.buffer.slice(patternIndex.index);
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/openai/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise2 = reader.cancel();
      reader.releaseLock();
      await cancelPromise2;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/streaming.mjs
var Stream = class _Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || sse.event.startsWith("response.") || sse.event.startsWith("transcript.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, createResponseHeaders(response.headers));
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller),
      new _Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options?.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
init();
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const mediaType = contentType?.split(";")[0]?.trim();
  const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var APIPromise = class _APIPromise extends Promise {
  constructor(responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
  }
  _thenUnwrap(transform) {
    return new _APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch ?? fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = options.timeout + 1e3;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!inputOptions.idempotencyKey)
        inputOptions.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = inputOptions.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout: options.timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    if (getHeader(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader(headers, "x-stainless-timeout") === void 0 && options.timeout) {
      reqHeaders["x-stainless-timeout"] = String(Math.trunc(options.timeout / 1e3));
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init2, ms, controller) {
    const { signal, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet2(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet2(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __metadata: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
var readEnv = (env) => {
  if (typeof process !== "undefined") {
    return process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action2, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg ?? (modifiedArg = { ...arg });
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg ?? arg;
    });
    console.log(`OpenAI:DEBUG:${action2}`, ...modifiedArgs);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof headers?.get === "function";
};
var getHeader = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resources/vector-stores/files.mjs
var Files = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(vectorStoreId, fileId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(vectorStoreId, fileId, options) {
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, { ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers } });
  }
};
var VectorStoreFilesPage = class extends CursorPage {
};
var FileContentResponsesPage = class extends Page {
};
Files.VectorStoreFilesPage = VectorStoreFilesPage;
Files.FileContentResponsesPage = FileContentResponsesPage;

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreId, body, options) {
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {
      body,
      method: "post",
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var VectorStoresPage = class extends CursorPage {
};
var VectorStoreSearchResponsesPage = class extends Page {
};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
VectorStores.Files = Files;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileContentResponsesPage = FileContentResponsesPage;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var is_array = Array.isArray;
var hex_table = (() => {
  const array2 = [];
  for (let i = 0; i < 256; ++i) {
    array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array2;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var has2 = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push2 = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push2.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort2, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object2;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder(obj, defaults.encoder, charset, "value", format))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort2 ? keys.sort(sort2) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object2, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder,
      filter,
      sort2,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has2.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object2, opts = {}) {
  let obj = object2;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (is_array2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages = class extends APIResource {
  list(completionId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(completionId, {}, query);
    }
    return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, { query, ...options });
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions = class extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionId, options) {
    return this._client.get(`/chat/completions/${completionId}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionId, body, options) {
    return this._client.post(`/chat/completions/${completionId}`, { body, ...options });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/chat/completions", ChatCompletionsPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.del('completion_id');
   * ```
   */
  del(completionId, options) {
    return this._client.delete(`/chat/completions/${completionId}`, options);
  }
};
var ChatCompletionsPage = class extends CursorPage {
};
var ChatCompletionStoreMessagesPage = class extends CursorPage {
};
Completions.ChatCompletionsPage = ChatCompletionsPage;
Completions.Messages = Messages;

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;
Chat.ChatCompletionsPage = ChatCompletionsPage;

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options?.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio2.Transcriptions = Transcriptions;
Audio2.Translations = Translations;
Audio2.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
};
var BatchesPage = class extends CursorPage {
};
Batches.BatchesPage = BatchesPage;

// node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet3(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet3(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet3(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet3(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet3(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet3(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet3(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet3(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet3(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet3(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet3(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet3(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet3(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet3(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet3(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet3(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet3(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet3(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet3(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet3(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet3(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet3(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet3(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet3(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet3(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet3(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet3(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet3(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class _AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _AssistantStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new _AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run3, threadId, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run3.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet4(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet4(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet4(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet4(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet4(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet4(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run3, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run3.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run3) {
    return run3;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
};
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet4(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet4(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet4(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet4(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet4(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet4(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet4(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet4(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet4(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet4(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet4(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet4(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet4(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet4(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet4(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet4(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet4(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet4(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet4(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet4(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever(_x) {
}

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted = await client.beta.assistants.del(
   *   'assistant_id',
   * );
   * ```
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
Assistants.AssistantsPage = AssistantsPage;

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
var isFunctionMessage = (message) => {
  return message?.role === "function";
};
var isToolMessage = (message) => {
  return message?.role === "tool";
};

// node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => ({
        ...choice,
        message: {
          ...choice.message,
          parsed: null,
          ...choice.message.tool_calls ? {
            tool_calls: choice.message.tool_calls
          } : void 0
        }
      }))
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => inputTool2.function?.name === toolCall.function.name);
  return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet5 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runFunctions(client, params, options) {
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && function_call?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet5(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.function_call) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet5 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet5(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet5(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet6(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new _ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet5(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet6(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet6(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever2(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet6(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever2(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    const state = __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet6(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet5(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet5(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet6(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    const responseFormat = __classPrivateFieldGet6(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a4, _b2, _c, _d;
    let snapshot = __classPrivateFieldGet6(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet5(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a4 = choice.logprobs).content ?? (_a4.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = choice.logprobs).refusal ?? (_b2.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet6(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet6(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet6(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet6(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever2(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages2 = class extends APIResource {
  /**
   * Create a message.
   *
   * @example
   * ```ts
   * const message = await client.beta.threads.messages.create(
   *   'thread_id',
   *   { content: 'string', role: 'user' },
   * );
   * ```
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieve a message.
   *
   * @example
   * ```ts
   * const message = await client.beta.threads.messages.retrieve(
   *   'thread_id',
   *   'message_id',
   * );
   * ```
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a message.
   *
   * @example
   * ```ts
   * const message = await client.beta.threads.messages.update(
   *   'thread_id',
   *   'message_id',
   * );
   * ```
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Deletes a message.
   *
   * @example
   * ```ts
   * const messageDeleted =
   *   await client.beta.threads.messages.del(
   *     'thread_id',
   *     'message_id',
   *   );
   * ```
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var MessagesPage = class extends CursorPage {
};
Messages2.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
Steps.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @example
   * ```ts
   * const run = await client.beta.threads.runs.retrieve(
   *   'thread_id',
   *   'run_id',
   * );
   * ```
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a run.
   *
   * @example
   * ```ts
   * const run = await client.beta.threads.runs.update(
   *   'thread_id',
   *   'run_id',
   * );
   * ```
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @example
   * ```ts
   * const run = await client.beta.threads.runs.cancel(
   *   'thread_id',
   *   'run_id',
   * );
   * ```
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run3 = await this.create(threadId, body, options);
    return await this.poll(threadId, run3.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run3, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run3.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run3;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run3 = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run3.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
var RunsPage = class extends CursorPage {
};
Runs.RunsPage = RunsPage;
Runs.Steps = Steps;
Runs.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages2(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a thread.
   *
   * @example
   * ```ts
   * const thread = await client.beta.threads.retrieve(
   *   'thread_id',
   * );
   * ```
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a thread.
   *
   * @example
   * ```ts
   * const thread = await client.beta.threads.update(
   *   'thread_id',
   * );
   * ```
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a thread.
   *
   * @example
   * ```ts
   * const threadDeleted = await client.beta.threads.del(
   *   'thread_id',
   * );
   * ```
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run3 = await this.createAndRun(body, options);
    return await this.runs.poll(run3.thread_id, run3.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads.Runs = Runs;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages2;
Threads.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      debug("Request", "User defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    debug("response", "Decoding base64 embeddings to float32 array");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};

// node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems = class extends APIResource {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(evalId, runId, outputItemId, options) {
    return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);
  }
  list(evalId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(evalId, runId, {}, query);
    }
    return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, { query, ...options });
  }
};
var OutputItemListResponsesPage = class extends CursorPage {
};
OutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage;

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Create a new evaluation run. This is the endpoint that will kick off grading.
   */
  create(evalId, body, options) {
    return this._client.post(`/evals/${evalId}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(evalId, runId, options) {
    return this._client.get(`/evals/${evalId}/runs/${runId}`, options);
  }
  list(evalId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(evalId, {}, query);
    }
    return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, { query, ...options });
  }
  /**
   * Delete an eval run.
   */
  del(evalId, runId, options) {
    return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(evalId, runId, options) {
    return this._client.post(`/evals/${evalId}/runs/${runId}`, options);
  }
};
var RunListResponsesPage = class extends CursorPage {
};
Runs2.RunListResponsesPage = RunListResponsesPage;
Runs2.OutputItems = OutputItems;
Runs2.OutputItemListResponsesPage = OutputItemListResponsesPage;

// node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and a datasource. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalId, options) {
    return this._client.get(`/evals/${evalId}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalId, body, options) {
    return this._client.post(`/evals/${evalId}`, { body, ...options });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/evals", EvalListResponsesPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  del(evalId, options) {
    return this._client.delete(`/evals/${evalId}`, options);
  }
};
var EvalListResponsesPage = class extends CursorPage {
};
Evals.EvalListResponsesPage = EvalListResponsesPage;
Evals.Runs = Runs2;
Evals.RunListResponsesPage = RunListResponsesPage;

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options?.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends CursorPage {
};
Files2.FileObjectsPage = FileObjectsPage;

// node_modules/openai/resources/fine-tuning/methods.mjs
var Methods = class extends APIResource {
};

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders = class extends APIResource {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   *   reference_answer: 'string',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha = class extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
};
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions = class extends APIResource {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, { body, method: "post", ...options });
  }
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(fineTunedModelCheckpoint, {}, query);
    }
    return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.del(
   *     'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *   );
   * ```
   */
  del(fineTunedModelCheckpoint, permissionId, options) {
    return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`, options);
  }
};
var PermissionCreateResponsesPage = class extends Page {
};
Permissions.PermissionCreateResponsesPage = PermissionCreateResponsesPage;

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints.Permissions = Permissions;
Checkpoints.PermissionCreateResponsesPage = PermissionCreateResponsesPage;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2 = class extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
};
var FineTuningJobCheckpointsPage = class extends CursorPage {
};
Checkpoints2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`, options);
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints2;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
};
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;

// node_modules/openai/resources/graders/grader-models.mjs
var GraderModels = class extends APIResource {
};

// node_modules/openai/resources/graders/graders.mjs
var Graders2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
};
Graders2.GraderModels = GraderModels;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given one or more source images and a
   * prompt. This endpoint only supports `gpt-image-1` and `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.edit({
   *   image: fs.createReadStream('path/to/file'),
   *   prompt: 'A cute baby sea otter wearing a beret',
   * });
   * ```
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   * [Learn more](https://platform.openai.com/docs/guides/images).
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.generate({
   *   prompt: 'A cute baby sea otter',
   * });
   * ```
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
Models.ModelsPage = ModelsPage;

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// node_modules/openai/resources/responses/input-items.mjs
var InputItems = class extends APIResource {
  list(responseId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(responseId, {}, query);
    }
    return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {
      query,
      ...options
    });
  }
};

// node_modules/openai/lib/responses/ResponseStream.mjs
var __classPrivateFieldSet6 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet7 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;
var ResponseStream = class _ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet6(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new _ResponseStream(params);
    runner._run(() => runner._createResponse(client, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createResponse(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet7(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    const stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet7(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet7(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet6(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event) {
    if (this.ended)
      return;
    const response = __classPrivateFieldGet7(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    this._emit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          this._emit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          this._emit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        this._emit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet7(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet6(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet7(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet6(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    let snapshot = __classPrivateFieldGet7(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet6(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          output.content.push(event.part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet6(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet7(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
};
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(responseId, {}, query);
    }
    return this._client.get(`/responses/${responseId}`, { query, ...options });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.del(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  del(responseId, options) {
    return this._client.delete(`/responses/${responseId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
};
var ResponseItemsPage = class extends CursorPage {
};
Responses.InputItems = InputItems;

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/index.mjs
var _a3;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio2(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.evals = new Evals(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
};
_a3 = OpenAI;
OpenAI.OpenAI = _a3;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.ChatCompletionsPage = ChatCompletionsPage;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio2;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.VectorStoresPage = VectorStoresPage;
OpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Evals = Evals;
OpenAI.EvalListResponsesPage = EvalListResponsesPage;
var openai_default = OpenAI;

// src/core/services/OpenAIService.ts
console.log(typeof VectorStores);
var OpenAIService = class {
  constructor(settings) {
    this.settings = settings;
    this.client = null;
    // Proper OpenAI type instead of any
    this.apiKey = null;
    // Store the injected ID
    // File upload cache: content hash -> file ID
    this.fileCache = /* @__PURE__ */ new Map();
    this.presetAssistantId = "asst_oPHViKRn9BzTPCEP5TAzFIIP";
    if (this.settings.openAiApiKey) {
      this.apiKey = this.settings.openAiApiKey;
      try {
        const clientOptions = {
          apiKey: this.apiKey,
          dangerouslyAllowBrowser: true,
          defaultHeaders: { "OpenAI-Beta": "assistants=v2" }
        };
        this.client = new openai_default(clientOptions);
      } catch (_error) {
        this.client = null;
      }
    } else {
      this.client = null;
    }
  }
  isAvailable() {
    return !!this.client;
  }
  isAssistantConfigured() {
    const hasApiKey = !!this.apiKey;
    const hasValidAssistantId = !!this.presetAssistantId && this.presetAssistantId.startsWith("asst_");
    const configured = hasApiKey && hasValidAssistantId;
    return configured;
  }
  getApiKey() {
    return this.apiKey;
  }
  /**
   * Transcribes the given audio blob using the OpenAI STT API.
   * @param audioBlob The audio data to transcribe.
   * @returns A promise that resolves with the transcription text or null if an error occurs or the service is unavailable.
   */
  async transcribeAudio(audioBlob) {
    console.time("OpenAIService_transcribeAudio");
    try {
      if (!this.apiKey) {
        return null;
      }
      if (!audioBlob || audioBlob.size === 0) {
        return null;
      }
      const formData = new FormData();
      formData.append("file", audioBlob, "audio.webm");
      formData.append("model", "gpt-4o-mini-transcribe");
      formData.append("temperature", "0.0");
      const apiUrl = "https://api.openai.com/v1/audio/transcriptions";
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
          // 'Content-Type': 'multipart/form-data' // Usually set automatically by fetch with FormData
        },
        body: formData
      });
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch (_error) {
          errorData = { message: await response.text() };
        }
        let errorMessage = `OpenAI API Error (${response.status}): ${errorData?.error?.message || response.statusText || "Unknown error"}`;
        if (response.status === 401) {
          errorMessage = "OpenAI Authentication Error. Please check your API key.";
        } else if (response.status === 429) {
          errorMessage = "OpenAI Rate Limit Exceeded. Please try again later.";
        } else if (response.status === 400) {
          errorMessage = `OpenAI API Bad Request (${response.status}): ${errorData?.error?.message || "Check request parameters."}`;
        }
        console.error(errorMessage);
        return null;
      }
      const transcription = await response.json();
      if (transcription && transcription.text) {
        return transcription.text;
      } else {
        return null;
      }
    } catch (_error) {
      return null;
    } finally {
      console.timeEnd("OpenAIService_transcribeAudio");
    }
  }
  async getAssistantResponse(userInput, vectorStoreId, onChunk, abortSignal) {
    const timerLabel = "OpenAIService_getAssistantResponse_FullCall";
    console.time(timerLabel);
    let accumulatedText = "";
    let operationError = null;
    let runIdFromStream = null;
    const safeResolve = (result) => {
      console.timeEnd(timerLabel);
      return result;
    };
    const internalOnChunk = (textChunk, isFinalChunk, error) => {
      if (error) {
        operationError = error;
      }
      if (textChunk) {
        accumulatedText += textChunk;
      }
      if (onChunk) {
        onChunk(textChunk, isFinalChunk, runIdFromStream, error);
      }
    };
    try {
      if (abortSignal?.aborted) {
        const errorMessage = "Request was cancelled before starting.";
        internalOnChunk("", true, errorMessage);
        return safeResolve({ responseId: null, responseText: null, error: errorMessage });
      }
      if (!this.isAssistantConfigured()) {
        const errorMessage = "OpenAIService: Assistant not configured (API Key or valid Assistant ID).";
        internalOnChunk("", true, errorMessage);
        return safeResolve({ responseId: null, responseText: null, error: errorMessage });
      }
      if (!this.client) {
        const errorMessage = "OpenAIService: OpenAI client not initialized.";
        internalOnChunk("", true, errorMessage);
        return safeResolve({ responseId: null, responseText: null, error: errorMessage });
      }
      console.log("[OpenAIService.getAssistantResponse SDK] Creating thread with vector store:", vectorStoreId);
      const currentTimestamp = (/* @__PURE__ */ new Date()).toISOString();
      console.log("[OpenAIService.getAssistantResponse] Including timestamp in request:", currentTimestamp);
      const timestampedUserInput = `[System Note: Current date and time: ${currentTimestamp}]

${userInput}`;
      const threadCreateParams = {
        messages: [
          {
            role: "user",
            content: timestampedUserInput
          }
        ]
      };
      if (vectorStoreId) {
        threadCreateParams.tool_resources = {
          file_search: {
            vector_store_ids: [vectorStoreId]
          }
        };
      }
      console.log("[OpenAIService.getAssistantResponse SDK] Thread creation params:", JSON.stringify(threadCreateParams, null, 2));
      const thread = await this.client.beta.threads.create(threadCreateParams);
      console.log("[OpenAIService.getAssistantResponse SDK] Thread created:", thread.id);
      console.log("[OpenAIService.getAssistantResponse SDK] Checking assistant configuration...");
      try {
        const assistantConfig = await this.getAssistantConfiguration();
        const tools = assistantConfig?.tools;
        console.log("[OpenAIService.getAssistantResponse SDK] Assistant tools:", tools?.map((t) => t.type) || "None");
        console.log("[OpenAIService.getAssistantResponse SDK] Assistant model:", assistantConfig?.model || "Unknown");
      } catch (configError) {
        console.warn("[OpenAIService.getAssistantResponse SDK] Could not check assistant config:", configError);
      }
      console.log("[OpenAIService.getAssistantResponse SDK] Creating streaming run with assistant:", this.presetAssistantId);
      const runParams = {
        assistant_id: this.presetAssistantId
        // Try without additional_instructions first - this might be causing the server error
        // additional_instructions: "After using file_search to find relevant information, you MUST generate a comprehensive response to the user's question based on the search results. Always provide a helpful answer."
      };
      console.log("[OpenAIService.getAssistantResponse SDK] Run params:", JSON.stringify(runParams, null, 2));
      let stream;
      const maxRetries = 2;
      let attempt = 0;
      while (attempt < maxRetries) {
        try {
          attempt++;
          console.log(`[OpenAIService.getAssistantResponse SDK] Creating stream attempt ${attempt}/${maxRetries}`);
          stream = this.client.beta.threads.runs.createAndStream(thread.id, runParams);
          break;
        } catch (streamCreationError) {
          const error = streamCreationError;
          console.error(`[OpenAIService.getAssistantResponse SDK] Stream creation attempt ${attempt} failed:`, error);
          if (attempt >= maxRetries) {
            const errorMessage = `Failed to create stream after ${maxRetries} attempts: ${error.message}`;
            internalOnChunk("", true, errorMessage);
            return safeResolve({ responseId: null, responseText: null, error: errorMessage });
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3 * attempt));
        }
      }
      if (!stream) {
        const errorMessage = "Failed to create stream after all retry attempts";
        internalOnChunk("", true, errorMessage);
        return safeResolve({ responseId: null, responseText: null, error: errorMessage });
      }
      return new Promise((resolve) => {
        let isAborted = false;
        const abortListener = () => {
          isAborted = true;
          console.log("[OpenAIService.getAssistantResponse] Request aborted by user");
          const errorMessage = "Request was cancelled by user.";
          internalOnChunk("", true, errorMessage);
          resolve(safeResolve({ responseId: runIdFromStream, responseText: null, error: errorMessage }));
        };
        if (abortSignal) {
          if (abortSignal.aborted) {
            abortListener();
            return;
          }
          abortSignal.addEventListener("abort", abortListener);
        }
        stream.on("textCreated", () => {
          console.log("[OpenAIService SDK STREAM] Text creation started");
        }).on("textDelta", (textDelta) => {
          if (isAborted) return;
          console.log("[OpenAIService SDK STREAM] Text delta:", textDelta.value);
          if (textDelta.value) {
            const cleanedTextChunk = removeCitationAnnotations(textDelta.value);
            internalOnChunk(cleanedTextChunk, false, null);
          }
        }).on("textDone", (text) => {
          console.log("[OpenAIService SDK STREAM] Text completed:", text.value?.length || 0, "characters");
        }).on("toolCallCreated", (toolCall) => {
          console.log("[OpenAIService SDK STREAM] Tool call created:", toolCall.type);
        }).on("toolCallDone", (toolCall) => {
          console.log("[OpenAIService SDK STREAM] Tool call completed:", toolCall.type);
        }).on("runStepCreated", (runStep) => {
          console.log("[OpenAIService SDK STREAM] Run step created:", runStep.type);
        }).on("runStepDone", (runStep) => {
          console.log("[OpenAIService SDK STREAM] Run step completed:", runStep.type, runStep.status);
        }).on("messageDone", (message) => {
          console.log("[OpenAIService SDK STREAM] Message completed:", message.id);
        }).on("runCompleted", (run3) => {
          if (isAborted) return;
          console.log("[OpenAIService SDK STREAM] Run completed successfully:", run3.id);
          runIdFromStream = run3.id;
          if (abortSignal) {
            abortSignal.removeEventListener("abort", abortListener);
          }
          internalOnChunk("", true, null);
          resolve(safeResolve({ responseId: runIdFromStream, responseText: accumulatedText, error: operationError || void 0 }));
        }).on("runFailed", (run3) => {
          if (isAborted) return;
          console.error("[OpenAIService SDK STREAM] Run failed:", run3.last_error);
          if (abortSignal) {
            abortSignal.removeEventListener("abort", abortListener);
          }
          const runError = run3.last_error?.message || "Run failed";
          internalOnChunk("", true, runError);
          resolve(safeResolve({ responseId: run3.id, responseText: null, error: runError }));
        }).on("error", (error) => {
          if (isAborted) return;
          console.error("[OpenAIService SDK STREAM] Stream error:", error);
          if (abortSignal) {
            abortSignal.removeEventListener("abort", abortListener);
          }
          const errorMessage = error.message || "Stream error occurred";
          internalOnChunk("", true, errorMessage);
          resolve(safeResolve({ responseId: runIdFromStream, responseText: null, error: errorMessage }));
        }).on("end", () => {
          if (isAborted) return;
          console.log("[OpenAIService SDK STREAM] Stream ended");
          if (abortSignal) {
            abortSignal.removeEventListener("abort", abortListener);
          }
          if (accumulatedText.length > 0) {
            console.log("[OpenAIService SDK STREAM] Stream ended with accumulated text");
            internalOnChunk("", true, null);
            resolve(safeResolve({ responseId: runIdFromStream, responseText: accumulatedText, error: operationError || void 0 }));
          } else {
            console.log("[OpenAIService SDK STREAM] Stream ended without text - may indicate configuration issue");
            const streamEndError = operationError || "Stream ended without generating response text. This may indicate an assistant configuration issue.";
            internalOnChunk("", true, streamEndError);
            resolve(safeResolve({ responseId: runIdFromStream, responseText: null, error: streamEndError }));
          }
        });
      });
    } catch (error) {
      console.error("OpenAIService.getAssistantResponse (SDK): Error:", error);
      let errorMessage = "Unexpected error during assistant run.";
      if (error instanceof Error) {
        errorMessage = `OpenAIService (SDK) Error: ${error.message}`;
      }
      internalOnChunk("", true, errorMessage);
      return safeResolve({ responseId: runIdFromStream, responseText: null, error: errorMessage });
    }
  }
  // The following methods are kept as they are not directly related to the old Thread/Run assistant flow or are utilities
  // (e.g., getApiKey, transcribeAudio, checkRunStatus - though checkRunStatus might be removed if not used by anything else after this refactor)
  // public async getAssistantLatestMessage(threadId: string): Promise<any | null> { ... } // This should be removed as it's part of the old flow.
  // public async checkRunStatus(threadId: string, runId: string): Promise<any | null> { ... } // This is also part of the old flow.
  // Ensure any other methods related to the old beta.threads, beta.threads.messages, beta.threads.runs are removed.
  // Looking at the file outline, `getAssistantLatestMessage` and `checkRunStatus` are the remaining ones from the old flow.
  // Add vector store management methods for file search integration
  async createVectorStore(name = "NoteChat Session Store") {
    console.time("OpenAIService_createVectorStore");
    try {
      if (!this.client || !this.client.vectorStores || typeof this.client.vectorStores.create !== "function") {
        return null;
      }
      const vectorStore = await this.client.vectorStores.create({ name });
      return vectorStore.id;
    } catch (_error) {
      return null;
    } finally {
      console.timeEnd("OpenAIService_createVectorStore");
    }
  }
  async deleteVectorStore(vectorStoreId) {
    if (!this.isAssistantConfigured()) {
      return false;
    }
    if (!this.client || !this.client.vectorStores) {
      return false;
    }
    console.log(`OpenAIService: Attempting to delete Vector Store [${vectorStoreId}].`);
    try {
      const response = await this.client.vectorStores.del(vectorStoreId);
      if (response && response.deleted) {
        console.log(`OpenAIService: Successfully deleted Vector Store ID [${vectorStoreId}]. API Response:`, response);
        return true;
      } else {
        console.warn(`OpenAIService: Deletion of Vector Store ID [${vectorStoreId}] not confirmed or failed. API Response:`, response);
        return false;
      }
    } catch (_error) {
      const error = _error;
      console.error(`OpenAIService: Error deleting vector store ID ${vectorStoreId}:`, error.message || error, error);
      return false;
    }
  }
  /**
   * Uploads note content as a file for assistant vector search.
   * @param content The file content.
   * @param fileName The name to assign to the file.
   * @returns The created file ID or null on failure.
   */
  async uploadNoteAsFile(content, fileName) {
    console.time(`OpenAIService_uploadNoteAsFile_${fileName}`);
    try {
      if (!this.isAssistantConfigured() || !this.client) {
        return null;
      }
      const fileObject = await this.client.files.create({
        file: new File([content], fileName, { type: "text/plain" }),
        purpose: "assistants"
      });
      return fileObject.id;
    } catch (_error) {
      return null;
    } finally {
      console.timeEnd(`OpenAIService_uploadNoteAsFile_${fileName}`);
    }
  }
  /**
   * Get cached file ID or upload file content.
   * Uses content hash for intelligent caching of frequently used files.
   * @param content The file content to upload
   * @param fileName The file name (for logging and organization)
   * @returns The file ID (cached or newly uploaded) or null on failure
   */
  async getOrUploadFile(content, fileName) {
    const timerLabel = `OpenAIService_getOrUploadFile_${fileName}`;
    console.time(timerLabel);
    try {
      const contentHash = await this.hashContent(content);
      const cacheKey = `${contentHash}_${fileName}`;
      if (this.fileCache.has(cacheKey)) {
        console.log(`OpenAIService.getOrUploadFile: Using cached file for "${fileName}" (hash: ${contentHash})`);
        const cachedFileId = this.fileCache.get(cacheKey);
        console.timeEnd(timerLabel);
        return cachedFileId;
      }
      console.log(`OpenAIService.getOrUploadFile: File "${fileName}" not in cache, uploading (hash: ${contentHash})`);
      const fileId = await this.uploadNoteAsFile(content, fileName);
      if (fileId) {
        this.fileCache.set(cacheKey, fileId);
        console.log(`OpenAIService.getOrUploadFile: Cached file "${fileName}" with ID: ${fileId}`);
      }
      console.timeEnd(timerLabel);
      return fileId;
    } catch (error) {
      console.error(`OpenAIService.getOrUploadFile: Error with file "${fileName}":`, error);
      console.timeEnd(timerLabel);
      return null;
    }
  }
  /**
   * Add an uploaded file to a vector store.
   * @param vectorStoreId The vector store ID
   * @param fileId The file ID to add
   * @param pollUntilIndexed Whether to poll until file status is 'completed'.
   * @returns True on success, false on failure.
   */
  async addFileToVectorStore(vectorStoreId, fileId, pollUntilIndexed = false) {
    console.time(`OpenAIService_addFileToVectorStore_${fileId}`);
    const pollTimerLabel = `OpenAIService_FileIndexingPoll_${fileId}`;
    let attempts = 0;
    try {
      if (!this.client || !vectorStoreId || !fileId) {
        console.error("OpenAIService.addFileToVectorStore: Client not initialized or missing IDs.");
        return false;
      }
      await this.client.vectorStores.files.create(vectorStoreId, { file_id: fileId });
      if (pollUntilIndexed) {
        console.log(`OpenAIService.addFileToVectorStore: Polling explicitly enabled for file ${fileId} in vector store ${vectorStoreId}.`);
        console.time(pollTimerLabel);
        const maxAttempts = 30;
        const pollingInterval = 1e3;
        while (attempts < maxAttempts) {
          try {
            const vectorStoreFile = await this.client.vectorStores.files.retrieve(vectorStoreId, fileId);
            if (vectorStoreFile?.status === "completed") {
              console.log(`OpenAIService.addFileToVectorStore: File ${fileId} indexed successfully (explicit polling).`);
              console.timeEnd(pollTimerLabel);
              return true;
            }
            if (vectorStoreFile?.status === "failed" || vectorStoreFile?.status === "cancelled") {
              console.error(`OpenAIService.addFileToVectorStore: File ${fileId} indexing failed or was cancelled (explicit polling). Status: ${vectorStoreFile.status}`);
              console.timeEnd(pollTimerLabel);
              return false;
            }
          } catch (retrievalError) {
            console.warn(`OpenAIService.addFileToVectorStore: Error during polling retrieve for ${fileId}, attempt ${attempts + 1}:`, retrievalError);
          }
          attempts++;
          await new Promise((resolve) => setTimeout(resolve, pollingInterval));
        }
        console.warn(`OpenAIService.addFileToVectorStore: File ${fileId} did not complete indexing after ${maxAttempts} attempts (explicit polling).`);
        console.timeEnd(pollTimerLabel);
        return false;
      } else {
        console.log(`OpenAIService.addFileToVectorStore: Polling not enabled for file ${fileId} in vector store ${vectorStoreId}.`);
        return true;
      }
    } catch (error) {
      console.error(`OpenAIService.addFileToVectorStore: Error adding file ${fileId} to vector store ${vectorStoreId}:`, error);
      if (error instanceof Error && error.message.includes("404") && error.message.includes("not found")) {
        console.warn(`OpenAIService.addFileToVectorStore: File ${fileId} not found on server, invalidating cache entries`);
        this.invalidateCacheForFileId(fileId);
      }
      return false;
    } finally {
      console.timeEnd(`OpenAIService_addFileToVectorStore_${fileId}`);
    }
  }
  /**
   * Invalidate cache entries that reference a specific file ID
   * @param fileId The file ID to remove from cache
   */
  invalidateCacheForFileId(fileId) {
    const keysToRemove = [];
    for (const [cacheKey, cachedFileId] of this.fileCache.entries()) {
      if (cachedFileId === fileId) {
        keysToRemove.push(cacheKey);
      }
    }
    keysToRemove.forEach((key) => {
      this.fileCache.delete(key);
      console.log(`OpenAIService: Invalidated cache entry for key: ${key}`);
    });
  }
  /**
   * Removes a file from a vector store.
   * @param vectorStoreId The vector store ID.
   * @param fileId The file ID to remove.
   * @returns True on success, false on failure.
   */
  async removeFileFromVectorStore(vectorStoreId, fileId) {
    console.time(`OpenAIService_removeFileFromVectorStore_${fileId}`);
    try {
      if (!this.client || !this.client.vectorStores || !this.client.vectorStores.files || typeof this.client.vectorStores.files.del !== "function") {
        console.error("OpenAIService.removeFileFromVectorStore: Client or vectorStores.files.del function is not available.");
        return false;
      }
      await this.client.vectorStores.files.del(vectorStoreId, fileId);
      return true;
    } catch (_error) {
      const error = _error;
      console.error(`OpenAIService: Error removing file ${fileId} from vector store ${vectorStoreId}:`, error.message || error);
      return false;
    } finally {
      console.timeEnd(`OpenAIService_removeFileFromVectorStore_${fileId}`);
    }
  }
  /**
   * Deletes an uploaded file from the OpenAI files endpoint.
   * @param fileId The file ID to delete.
   * @returns True on success, false on failure.
   */
  async deleteUploadedFile(fileId) {
    console.time(`OpenAIService_deleteUploadedFile_${fileId}`);
    try {
      if (!this.client || !this.client.files || typeof this.client.files.del !== "function") {
        console.error("OpenAIService.deleteUploadedFile: Client or files.del function is not available.");
        return false;
      }
      await this.client.files.del(fileId);
      return true;
    } catch (_error) {
      const error = _error;
      console.error(`OpenAIService: Error deleting OpenAI file ${fileId}:`, error.message || error);
      return false;
    } finally {
      console.timeEnd(`OpenAIService_deleteUploadedFile_${fileId}`);
    }
  }
  /**
   * Updates the assistant with proper instructions to ensure response generation after file search.
   * This fixes the common issue where assistants complete file search but don't generate responses.
   */
  async updateAssistantInstructions() {
    if (!this.isAssistantConfigured() || !this.apiKey) {
      console.log("[OpenAIService] Cannot update assistant - not configured properly");
      return false;
    }
    try {
      const response = await fetch(`https://api.openai.com/v1/assistants/${this.presetAssistantId}`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json",
          "OpenAI-Beta": "assistants=v2"
        },
        body: JSON.stringify({
          instructions: `You are a helpful AI assistant for analyzing and discussing note content. When a user asks a question, you must:

1. ALWAYS use the file_search tool to find relevant information from uploaded documents
2. After completing the file search, you MUST analyze the search results
3. You MUST then generate a comprehensive, helpful response based on what you found
4. If the search doesn't find perfect matches, still provide the best possible answer based on available information
5. NEVER end the conversation after just completing a tool - always provide a response to the user
6. Always provide a detailed analysis and summary when users ask about note content

You have access to documents through file search. Use this tool to find relevant information, then provide thoughtful responses based on that content.`
        })
      });
      if (!response.ok) {
        console.error("[OpenAIService] Failed to update assistant instructions:", response.status);
        return false;
      }
      const updatedAssistant = await response.json();
      console.log("[OpenAIService] Successfully updated assistant instructions:", updatedAssistant.id);
      return true;
    } catch (error) {
      console.error("[OpenAIService] Error updating assistant instructions:", error);
      return false;
    }
  }
  /**
   * Updates the assistant's model to match the current settings.
   * This ensures the assistant uses the model selected by the user.
   */
  async updateAssistantModel(newModel) {
    if (!this.isAssistantConfigured() || !this.apiKey) {
      console.log("[OpenAIService] Cannot update assistant model - not configured properly");
      return false;
    }
    try {
      console.log(`[OpenAIService] Updating assistant model from current to: ${newModel}`);
      const response = await fetch(`https://api.openai.com/v1/assistants/${this.presetAssistantId}`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json",
          "OpenAI-Beta": "assistants=v2"
        },
        body: JSON.stringify({
          model: newModel
        })
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("[OpenAIService] Failed to update assistant model:", response.status, errorData);
        return false;
      }
      const updatedAssistant = await response.json();
      console.log("[OpenAIService] Successfully updated assistant model to:", updatedAssistant.model);
      return true;
    } catch (error) {
      console.error("[OpenAIService] Error updating assistant model:", error);
      return false;
    }
  }
  /**
   * Retrieves and logs the current assistant configuration for debugging
   */
  async getAssistantConfiguration() {
    if (!this.isAssistantConfigured() || !this.apiKey) {
      console.log("[OpenAIService] Cannot retrieve assistant - not configured properly");
      return null;
    }
    try {
      const response = await fetch(`https://api.openai.com/v1/assistants/${this.presetAssistantId}`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json",
          "OpenAI-Beta": "assistants=v2"
        }
      });
      if (!response.ok) {
        console.error("[OpenAIService] Failed to retrieve assistant configuration:", response.status);
        return null;
      }
      const assistant = await response.json();
      console.log("[OpenAIService] Current assistant configuration:", JSON.stringify(assistant, null, 2));
      return assistant;
    } catch (error) {
      console.error("[OpenAIService] Error retrieving assistant configuration:", error);
      return null;
    }
  }
  /**
   * Generate a simple hash of file content for caching purposes
   */
  async hashContent(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  /**
   * Clear the file cache (useful for testing or memory management)
   */
  clearFileCache() {
    console.log(`OpenAIService: Clearing file cache (${this.fileCache.size} entries)`);
    this.fileCache.clear();
  }
  /**
   * Get cache statistics for debugging
   */
  getCacheStats() {
    return {
      size: this.fileCache.size,
      entries: Array.from(this.fileCache.keys())
    };
  }
  /**
   * Converts text to speech using the OpenAI TTS API.
   * @param text The text to convert to speech.
   * @param options Optional TTS configuration options.
   * @returns A promise that resolves with the audio blob or null if an error occurs.
   */
  async textToSpeech(text, options) {
    console.time("OpenAIService_textToSpeech");
    try {
      if (!this.apiKey) {
        console.error("OpenAI API key is not configured. Cannot generate speech.");
        return null;
      }
      if (!text || text.trim().length === 0) {
        console.error("Text input is empty or invalid.");
        return null;
      }
      const ttsOptions = {
        voice: options?.voice || "alloy",
        format: options?.format || "mp3",
        speed: options?.speed || 1,
        ...options
      };
      console.log(`Generating speech via manual fetch: Text length=${text.length}, Voice=${ttsOptions.voice}, Format=${ttsOptions.format}`);
      const requestBody = {
        model: "gpt-4o-mini-tts",
        input: text,
        voice: ttsOptions.voice,
        response_format: ttsOptions.format,
        speed: ttsOptions.speed
      };
      if (ttsOptions.instructions) {
        requestBody.instructions = ttsOptions.instructions;
      }
      const apiUrl = "https://api.openai.com/v1/audio/speech";
      console.log("Sending manual fetch request to OpenAI TTS API...");
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      console.log("Received response from TTS API:", response.status, response.statusText);
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          errorData = { message: await response.text() };
        }
        let errorMessage = `OpenAI TTS API Error (${response.status}): ${errorData?.error?.message || response.statusText || "Unknown error"}`;
        if (response.status === 401) {
          errorMessage = "OpenAI Authentication Error. Please check your API key.";
        } else if (response.status === 429) {
          errorMessage = "OpenAI Rate Limit Exceeded. Please try again later.";
        } else if (response.status === 400) {
          errorMessage = `OpenAI TTS API Bad Request (${response.status}): ${errorData?.error?.message || "Check request parameters."}`;
        }
        console.error(errorMessage);
        return null;
      }
      const audioBlob = await response.blob();
      console.log("TTS audio blob received:", audioBlob.size, "bytes, type:", audioBlob.type);
      if (audioBlob.size === 0) {
        console.error("Received empty audio blob from TTS API");
        return null;
      }
      return audioBlob;
    } catch (error) {
      console.error("Error during text-to-speech conversion:", error);
      return null;
    } finally {
      console.timeEnd("OpenAIService_textToSpeech");
    }
  }
};

// src/main.ts
var NoteChatPlugin = class extends import_obsidian15.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.aiClient = null;
    this.view = null;
    // Correct implementation for the 'events' property
    this.events = {
      on: (name) => {
        console.log(`Mock event listener registered for: ${name}`);
      },
      off: (name) => {
        console.log(`Mock event listener removed for: ${name}`);
      },
      trigger: (name, data) => {
        console.warn(`NoteChatPlugin.events.trigger called for: ${name} - Not implemented`, data);
      }
    };
  }
  async onload() {
    console.log("Loading NoteChat Plugin");
    setAppInstance(this.app);
    this.storageService = new StorageService(this);
    this.noteService = new NoteService(this.app, this.settings.noteFolderPath);
    this.noteContextManager = new NoteContextManager(this.app);
    this.aiClient = null;
    this.conversationManager = new ConversationManager(this, this.aiClient);
    this.chatService = new ChatService(this);
    this.chatService.initialize();
    window.sonoriaPlugin = this;
    try {
      await this.loadSettings();
      this.initializeAIClient();
      this.openAIService = new OpenAIService(this.settings);
      console.log("NoteChat: OpenAIService initialized in onload after settings processing.");
      if (this.openAIService.isAssistantConfigured()) {
        try {
          await this.openAIService.updateAssistantInstructions();
          await this.openAIService.updateAssistantModel(this.settings.llmModel);
          console.log("NoteChat: Assistant instructions and model updated successfully.");
          await this.openAIService.getAssistantConfiguration();
        } catch (error) {
          console.warn("NoteChat: Failed to update assistant instructions:", error);
        }
      }
      if (this.conversationManager) {
        this.conversationManager.setAIClient(this.aiClient);
      } else {
        console.error("NoteChatPlugin: ConversationManager not found during onload, re-initializing.");
        this.conversationManager = new ConversationManager(this, this.aiClient);
      }
      this.addSettingTab(new NoteChatSettingTab(this.app, this));
      await this.saveSettings();
      new import_obsidian15.Notice("Sonoria plugin loaded");
    } catch (error) {
      console.error("NoteChatPlugin: CAUGHT ERROR during onload initialization:", error);
      new import_obsidian15.Notice("Failed to initialize Sonoria plugin. Check the console for details.");
      this.settings = { ...DEFAULT_SETTINGS };
      this.initializeAIClient();
      this.openAIService = new OpenAIService(this.settings);
      if (this.conversationManager) {
        this.conversationManager.setAIClient(this.aiClient);
      }
    }
    this.app.workspace.onLayoutReady(async () => {
      await this.activateView(false);
      console.log("NoteChatPlugin: Layout ready. Re-checking AI Client and OpenAIService initialization.");
      try {
        await this.loadSettings();
        this.initializeAIClient();
        this.openAIService = new OpenAIService(this.settings);
        console.log("NoteChat: OpenAIService re-initialized on layoutReady.");
        if (this.openAIService.isAssistantConfigured()) {
          try {
            await this.openAIService.updateAssistantInstructions();
            await this.openAIService.updateAssistantModel(this.settings.llmModel);
            console.log("NoteChat: Assistant instructions and model updated on layoutReady.");
            await this.openAIService.getAssistantConfiguration();
          } catch (error) {
            console.warn("NoteChat: Failed to update assistant instructions on layoutReady:", error);
          }
        }
        if (this.conversationManager) {
          this.conversationManager.setAIClient(this.aiClient);
        } else {
          console.error("NoteChatPlugin: ConversationManager not found during layout ready re-init.");
          this.conversationManager = new ConversationManager(this, this.aiClient);
        }
      } catch (error) {
        console.error("NoteChatPlugin: Failed to re-initialize AI services on layout ready", error);
        new import_obsidian15.Notice("Failed to re-initialize AI services after layout ready. Please check settings.");
        this.aiClient = new PlaceholderAIClient("Layout ready re-init failed");
        this.openAIService = new OpenAIService(DEFAULT_SETTINGS);
        if (this.conversationManager) {
          this.conversationManager.setAIClient(this.aiClient);
        }
      }
    });
  }
  onunload() {
    console.log("Unloading Sonoria plugin");
    window.sonoriaPlugin = null;
    const workspace = this.app.workspace;
    workspace.detachLeavesOfType(VIEW_TYPE_SONORIA);
    if (this.view) {
      this.view.onClose();
    }
  }
  async loadSettings() {
    try {
      const savedSettings = await this.loadData();
      console.log("NoteChat: Loaded saved settings from disk:", savedSettings ? "Found" : "Not found");
      let currentSettings = {
        ...DEFAULT_SETTINGS,
        ...savedSettings || {}
        // Ensure savedSettings is not null/undefined
      };
      currentSettings = applyDevelopmentSettings(currentSettings);
      this.settings = currentSettings;
      console.log("NoteChat: Settings processed. OpenAI model:", this.settings.llmModel);
      if (this.settings.openAiApiKey && this.settings.openAiApiKey.startsWith("sk-")) {
        console.log("NoteChat: OpenAI API key is configured.");
      } else if (this.settings.openAiApiKey) {
        console.log("NoteChat: OpenAI API key is present (could be DEV key or non-standard format).");
      } else {
        console.warn("NoteChat: OpenAI API key is MISSING in final settings for current session.");
      }
    } catch (error) {
      console.error("NoteChat: Error loading settings:", error);
      this.settings = { ...DEFAULT_SETTINGS };
    }
  }
  async saveSettings() {
    try {
      await this.saveData(this.settings);
      console.log("NoteChat: Settings persisted to disk.");
      this.initializeAIClient();
      if (this.conversationManager) {
        this.conversationManager.setAIClient(this.aiClient);
      }
      if (this.settings.openAiApiKey) {
        if (this.openAIService) {
          if (this.settings.openAiApiKey !== this.openAIService.getApiKey()) {
            console.warn("NoteChat: OpenAI API key setting changed. Re-initializing OpenAIService with new key.");
            this.openAIService = new OpenAIService(this.settings);
            if (this.openAIService.isAssistantConfigured()) {
              try {
                await this.openAIService.updateAssistantInstructions();
                await this.openAIService.updateAssistantModel(this.settings.llmModel);
                console.log("NoteChat: Assistant instructions and model updated after key change.");
              } catch (error) {
                console.warn("NoteChat: Failed to update assistant instructions after key change:", error);
              }
            }
          } else {
          }
        } else {
          console.log("NoteChat: OpenAI API key present in settings and OpenAIService not initialized. Initializing OpenAIService.");
          this.openAIService = new OpenAIService(this.settings);
          if (this.openAIService.isAssistantConfigured()) {
            try {
              await this.openAIService.updateAssistantInstructions();
              await this.openAIService.updateAssistantModel(this.settings.llmModel);
              console.log("NoteChat: Assistant instructions and model updated after initialization.");
            } catch (error) {
              console.warn("NoteChat: Failed to update assistant instructions after initialization:", error);
            }
          }
        }
      } else {
        if (this.openAIService && this.openAIService.getApiKey()) {
          console.warn("NoteChat: OpenAI API key removed from settings. Re-initializing OpenAIService with empty key.");
          this.openAIService = new OpenAIService(this.settings);
        }
      }
    } catch (error) {
      console.error("NoteChat: Error saving settings:", error);
    }
  }
  /**
   * Initialize the AI client based on settings
   */
  initializeAIClient() {
    try {
      const factory = AIClientFactory.getInstance();
      this.aiClient = factory.createClientFromSettings(this.settings);
      if (this.aiClient && this.aiClient.provider !== "placeholder") {
        console.log(`NoteChat: ${this.aiClient.provider} client initialized with ${this.aiClient.model} model`);
      } else if (this.aiClient instanceof PlaceholderAIClient) {
        console.warn(`NoteChat: AI Client is a placeholder. Reason: ${this.aiClient.reason || "API Key missing"}`);
      } else {
        console.error("NoteChat: Failed to initialize AI client (received null from factory unexpectedly)");
        this.aiClient = new PlaceholderAIClient("Fell back to placeholder due to factory error.");
      }
    } catch (error) {
      console.error("NoteChat: Error initializing AI client:", error);
      this.aiClient = new PlaceholderAIClient(`Failed to initialize AI client: ${error.message}`);
    }
  }
  /**
   * Initialize the chat service
   */
  initializeChatService() {
    console.log("NoteChat: Initializing ChatService");
    this.chatService = new ChatService(this);
    this.chatService.initialize();
    console.log("NoteChat: ChatService initialized successfully");
  }
  /**
   * Public method to activate the chat view
   */
  async openChatView() {
    if (this.chatService) {
      await this.chatService.activateView();
    }
  }
  /**
   * Public method to activate the chat view with a note
   */
  async openChatViewWithNote(notePath) {
    if (this.chatService) {
      await this.chatService.activateViewWithNote(notePath);
    }
  }
  /**
   * Activates the NoteChat view, opening it if necessary.
   * Reverted to original logic which might be compatible with the environment.
   * @param focus Whether to focus the view after activating it.
   */
  async activateView(focus = true) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_SONORIA);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        leaf = workspace.getLeftLeaf(false);
      }
      if (!leaf) {
        leaf = workspace.getLeaf(true);
      }
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_SONORIA, active: true });
      }
    }
    if (leaf && focus) {
      workspace.revealLeaf(leaf);
    }
  }
};
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/audio-lines.js:
lucide-react/dist/esm/icons/chevron-down.js:
lucide-react/dist/esm/icons/chevron-up.js:
lucide-react/dist/esm/icons/circle-stop.js:
lucide-react/dist/esm/icons/clock.js:
lucide-react/dist/esm/icons/copy.js:
lucide-react/dist/esm/icons/file-plus.js:
lucide-react/dist/esm/icons/keyboard.js:
lucide-react/dist/esm/icons/lightbulb.js:
lucide-react/dist/esm/icons/loader.js:
lucide-react/dist/esm/icons/mic.js:
lucide-react/dist/esm/icons/pause.js:
lucide-react/dist/esm/icons/plus.js:
lucide-react/dist/esm/icons/refresh-cw.js:
lucide-react/dist/esm/icons/save.js:
lucide-react/dist/esm/icons/search.js:
lucide-react/dist/esm/icons/send.js:
lucide-react/dist/esm/icons/square.js:
lucide-react/dist/esm/icons/triangle-alert.js:
lucide-react/dist/esm/icons/x.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.501.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
